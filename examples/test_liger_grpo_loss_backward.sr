package main

liger_grpo_loss :: import "vendor/liger_grpo_loss"
triton :: import "vendor/triton"
cuda :: import "vendor/cuda"
io :: import "std/io"
alloc :: import "std/alloc"
math :: import "std/math"

main :: proc() {
    res := cuda.cuInit(0)
    if res != cuda.SUCCESS {
        io.println("Failed to init CUDA: %d", res)
        return
    }

    dev: cuda.CUdevice = undefined
    res = cuda.cuDeviceGet(&dev, 0)
    if res != cuda.SUCCESS {
        io.println("Failed to get device", ())
        return
    }

    ctx: cuda.CUcontext = null
    res = cuda.cuCtxCreate(&ctx, 0, dev)
    if res != cuda.SUCCESS {
        io.println("Failed to create context", ())
        return
    }

    B: i32 = 2
    L: i32 = 2
    N: i32 = 32
    logits_size := B.(usize) * (L + 1).(usize) * N.(usize) * 4
    ids_size := B.(usize) * L.(usize) * 4
    out_size := B.(usize) * L.(usize) * 4
    adv_size := B.(usize) * 4

    logits_h_ptr := alloc.alloc(logits_size) orelse return
    logits_h := logits_h_ptr.^*f32
    ids_h_ptr := alloc.alloc(ids_size) orelse return
    ids_h := ids_h_ptr.^*i32
    old_logp_h_ptr := alloc.alloc(out_size) orelse return
    old_logp_h := old_logp_h_ptr.^*f32
    ref_logp_h_ptr := alloc.alloc(out_size) orelse return
    ref_logp_h := ref_logp_h_ptr.^*f32
    adv_h_ptr := alloc.alloc(adv_size) orelse return
    adv_h := adv_h_ptr.^*f32
    lse_h_ptr := alloc.alloc(out_size) orelse return
    lse_h := lse_h_ptr.^*f32
    dloss_h_ptr := alloc.alloc(out_size) orelse return
    dloss_h := dloss_h_ptr.^*f32
    mask_h_ptr := alloc.alloc(ids_size) orelse return
    mask_h := mask_h_ptr.^*i32
    dlogits_ref_ptr := alloc.alloc(logits_size) orelse return
    dlogits_ref := dlogits_ref_ptr.^*f32

    i: i32 = 0
    total_logits: i32 = B * (L + 1) * N
    while i < total_logits {
        logits_h[i] = ((i % 53) - 26).(f32) * 0.01
        i = i + 1
    }
    i = 0
    while i < B * L {
        ids_h[i] = (i * 5) % N
        mask_h[i] = 1
        dloss_h[i] = 1.0
        i = i + 1
    }
    i = 0
    while i < B {
        adv_h[i] = if (i % 2 == 0) { 0.5 } else { -0.25 }
        i = i + 1
    }

    // CPU reference (beta=0, old_logp == logp, dloss=1)
    b: i32 = 0
    while b < B {
        l: i32 = 0
        while l < L {
            base := b * (L + 1) * N + l * N
            maxv := logits_h[base]
            c: i32 = 1
            while c < N {
                v := logits_h[base + c]
                if v > maxv { maxv = v }
                c = c + 1
            }
            sum_exp: f32 = 0.0
            c = 0
            while c < N {
                sum_exp = sum_exp + math.expf(logits_h[base + c] - maxv)
                c = c + 1
            }
            lse := maxv + math.logf(sum_exp)
            lse_h[b * L + l] = lse
            idx := ids_h[b * L + l]
            x := logits_h[base + idx]
            logp := x - lse
            old_logp_h[b * L + l] = logp
            ref_logp_h[b * L + l] = logp
            dlogp := -adv_h[b]

            c = 0
            while c < N {
                probs := math.expf(logits_h[base + c] - lse)
                grad := if c == idx { (1.0 - probs) } else { -probs }
                dlogits_ref[base + c] = grad * dlogp
                c = c + 1
            }
            l = l + 1
        }
        b = b + 1
    }

    logits_d: cuda.CUdeviceptr = 0
    old_logp_d: cuda.CUdeviceptr = 0
    ref_logp_d: cuda.CUdeviceptr = 0
    ids_d: cuda.CUdeviceptr = 0
    adv_d: cuda.CUdeviceptr = 0
    mask_d: cuda.CUdeviceptr = 0
    lse_d: cuda.CUdeviceptr = 0
    dloss_d: cuda.CUdeviceptr = 0
    dlogits_d: cuda.CUdeviceptr = 0

    _ = cuda.cuMemAlloc(&logits_d, logits_size)
    _ = cuda.cuMemAlloc(&old_logp_d, out_size)
    _ = cuda.cuMemAlloc(&ref_logp_d, out_size)
    _ = cuda.cuMemAlloc(&ids_d, ids_size)
    _ = cuda.cuMemAlloc(&adv_d, adv_size)
    _ = cuda.cuMemAlloc(&mask_d, ids_size)
    _ = cuda.cuMemAlloc(&lse_d, out_size)
    _ = cuda.cuMemAlloc(&dloss_d, out_size)
    _ = cuda.cuMemAlloc(&dlogits_d, logits_size)

    _ = cuda.cuMemcpyHtoD(logits_d, logits_h.^?*void, logits_size)
    _ = cuda.cuMemcpyHtoD(old_logp_d, old_logp_h.^?*void, out_size)
    _ = cuda.cuMemcpyHtoD(ref_logp_d, ref_logp_h.^?*void, out_size)
    _ = cuda.cuMemcpyHtoD(ids_d, ids_h.^?*void, ids_size)
    _ = cuda.cuMemcpyHtoD(adv_d, adv_h.^?*void, adv_size)
    _ = cuda.cuMemcpyHtoD(mask_d, mask_h.^?*void, ids_size)
    _ = cuda.cuMemcpyHtoD(lse_d, lse_h.^?*void, out_size)
    _ = cuda.cuMemcpyHtoD(dloss_d, dloss_h.^?*void, out_size)

    triton.launch(
        liger_grpo_loss.grpo_loss_bwd_kernel,
        grid = (B, L, 1),
        block = (1, 1, 1),
        BLOCK_N = 32,
        HAS_MASK = 1,
        dloss_d,
        dlogits_d,
        logits_d,
        old_logp_d,
        ref_logp_d,
        ids_d,
        adv_d,
        mask_d,
        lse_d,
        1.0,
        0.0,
        0.2,
        0.2,
        L,
        N,
    )

    dlogits_h_ptr := alloc.alloc(logits_size) orelse return
    dlogits_h := dlogits_h_ptr.^*f32
    _ = cuda.cuMemcpyDtoH(dlogits_h.^?*void, dlogits_d, logits_size)

    success := true
    epsilon: f32 = 1.e-3
    i = 0
    while i < total_logits {
        diff := dlogits_h[i] - dlogits_ref[i]
        if diff < 0 { diff = -diff }
        if diff > epsilon {
            io.println("dlogits mismatch at %d: expected %f got %f", i, dlogits_ref[i], dlogits_h[i])
            success = false
            break
        }
        i = i + 1
    }
    if success { io.println("GRPO loss backward verification passed", ()) }

    _ = cuda.cuMemFree(logits_d)
    _ = cuda.cuMemFree(old_logp_d)
    _ = cuda.cuMemFree(ref_logp_d)
    _ = cuda.cuMemFree(ids_d)
    _ = cuda.cuMemFree(adv_d)
    _ = cuda.cuMemFree(mask_d)
    _ = cuda.cuMemFree(lse_d)
    _ = cuda.cuMemFree(dloss_d)
    _ = cuda.cuMemFree(dlogits_d)
}
