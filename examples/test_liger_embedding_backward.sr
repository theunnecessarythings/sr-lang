package main

liger_embedding :: import "vendor/liger_embedding"
triton :: import "vendor/triton"
cuda :: import "vendor/cuda"
io :: import "std/io"
alloc :: import "std/alloc"

PtrF32 :: triton.Ptr(f32)
PtrI32 :: triton.Ptr(i32)

main :: proc() {
    res := cuda.cuInit(0)
    if res != cuda.SUCCESS {
        io.println("Failed to init CUDA: %d", res)
        return
    }

    dev: cuda.CUdevice = undefined
    res = cuda.cuDeviceGet(&dev, 0)
    if res != cuda.SUCCESS {
        io.println("Failed to get device", ())
        return
    }

    ctx: cuda.CUcontext = null
    res = cuda.cuCtxCreate(&ctx, 0, dev)
    if res != cuda.SUCCESS {
        io.println("Failed to create context", ())
        return
    }

    n_elements: i32 = 4
    embedding_dim: i32 = 16
    vocab_size: i32 = 8

    grad_size := n_elements.(usize) * embedding_dim.(usize) * 4
    idx_size := n_elements.(usize) * 4
    w_size := vocab_size.(usize) * embedding_dim.(usize) * 4

    grad_h_ptr := alloc.alloc(grad_size) orelse return
    grad_h := grad_h_ptr.^*f32
    idx_h_ptr := alloc.alloc(idx_size) orelse return
    idx_h := idx_h_ptr.^*i32
    w_h_ptr := alloc.alloc(w_size) orelse return
    w_h := w_h_ptr.^*f32

    i: i32 = 0
    total: i32 = n_elements * embedding_dim
    while i < total {
        grad_h[i] = (i % 17).(f32) * 0.03
        i = i + 1
    }
    i = 0
    while i < n_elements {
        idx_h[i] = i
        i = i + 1
    }

    ref_ptr := alloc.alloc(w_size) orelse return
    ref := ref_ptr.^*f32
    i = 0
    while i < vocab_size * embedding_dim {
        ref[i] = 0.0
        i = i + 1
    }
    i = 0
    while i < n_elements {
        base_out := i * embedding_dim
        base_w := idx_h[i] * embedding_dim
        j: i32 = 0
        while j < embedding_dim {
            ref[base_w + j] = grad_h[base_out + j]
            j = j + 1
        }
        i = i + 1
    }

    grad_d: cuda.CUdeviceptr = 0
    idx_d: cuda.CUdeviceptr = 0
    w_d: cuda.CUdeviceptr = 0

    _ = cuda.cuMemAlloc(&grad_d, grad_size)
    _ = cuda.cuMemAlloc(&idx_d, idx_size)
    _ = cuda.cuMemAlloc(&w_d, w_size)

    _ = cuda.cuMemcpyHtoD(grad_d, grad_h.^?*void, grad_size)
    _ = cuda.cuMemcpyHtoD(idx_d, idx_h.^?*void, idx_size)

    triton.launch(
        liger_embedding.embedding_backward_kernel,
        grid = (n_elements, 1, 1),
        block = (128, 1, 1),
        BLOCK_SIZE = 128,
        grad_d,
        w_d,
        idx_d,
        n_elements,
        embedding_dim,
    )

    _ = cuda.cuMemcpyDtoH(w_h.^?*void, w_d, w_size)

    success := true
    epsilon: f32 = 1.e-4
    i = 0
    while i < n_elements {
        base := idx_h[i] * embedding_dim
        j: i32 = 0
        while j < embedding_dim {
            diff := w_h[base + j] - ref[base + j]
            if diff < 0 { diff = -diff }
            if diff > epsilon {
                io.println("embedding bwd mismatch at %d,%d: expected %f got %f", idx_h[i], j, ref[base + j], w_h[base + j])
                success = false
                break
            }
            j = j + 1
        }
        if !success { break }
        i = i + 1
    }
    if success { io.println("Embedding backward verification passed", ()) }

    _ = cuda.cuMemFree(grad_d)
    _ = cuda.cuMemFree(idx_d)
    _ = cuda.cuMemFree(w_d)
}
