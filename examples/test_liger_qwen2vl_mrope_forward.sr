package main

liger_qwen2vl_mrope :: import "vendor/liger_qwen2vl_mrope"
triton :: import "vendor/triton"
cuda :: import "vendor/cuda"
io :: import "std/io"
alloc :: import "std/alloc"

PtrF32 :: triton.Ptr(f32)

main :: proc() {
    res := cuda.cuInit(0)
    if res != cuda.SUCCESS {
        io.println("Failed to init CUDA: %d", res)
        return
    }

    dev: cuda.CUdevice = undefined
    res = cuda.cuDeviceGet(&dev, 0)
    if res != cuda.SUCCESS {
        io.println("Failed to get device", ())
        return
    }

    ctx: cuda.CUcontext = null
    res = cuda.cuCtxCreate(&ctx, 0, dev)
    if res != cuda.SUCCESS {
        io.println("Failed to create context", ())
        return
    }

    bs: i32 = 1
    sl: i32 = 2
    n_qh: i32 = 1
    n_kh: i32 = 1
    hd: i32 = 4
    mrope_t: i32 = 1
    mrope_h: i32 = 1

    rows := bs * sl
    q_stride := n_qh * hd
    k_stride := n_kh * hd

    q_size := rows.(usize) * q_stride.(usize) * 4
    k_size := rows.(usize) * k_stride.(usize) * 4
    // cos/sin store three sections, each [bs*sl*hd]
    cos_size := (rows * hd * 3).(usize) * 4
    sin_size := (rows * hd * 3).(usize) * 4

    q_h_ptr := alloc.alloc(q_size) orelse return
    q_h := q_h_ptr.^*f32
    k_h_ptr := alloc.alloc(k_size) orelse return
    k_h := k_h_ptr.^*f32
    cos_h_ptr := alloc.alloc(cos_size) orelse return
    cos_h := cos_h_ptr.^*f32
    sin_h_ptr := alloc.alloc(sin_size) orelse return
    sin_h := sin_h_ptr.^*f32

    i: i32 = 0
    while i < rows * q_stride {
        q_h[i] = (i + 1).(f32) * 0.01
        k_h[i] = (i + 1).(f32) * 0.02
        i = i + 1
    }
    i = 0
    while i < rows * hd * 3 {
        cos_h[i] = 1.0
        sin_h[i] = 0.0
        i = i + 1
    }

    q_ref_ptr := alloc.alloc(q_size) orelse return
    q_ref := q_ref_ptr.^*f32
    k_ref_ptr := alloc.alloc(k_size) orelse return
    k_ref := k_ref_ptr.^*f32
    i = 0
    while i < rows * q_stride {
        q_ref[i] = q_h[i]
        k_ref[i] = k_h[i]
        i = i + 1
    }

    r: i32 = 0
    while r < rows {
        d: i32 = 0
        while d < hd / 2 {
            cos_val := 1.0
            sin_val := 0.0
            off1 := r * q_stride + d
            off2 := r * q_stride + d + (hd / 2)
            q1 := q_ref[off1]
            q2 := q_ref[off2]
            q_ref[off1] = q1 * cos_val - q2 * sin_val
            q_ref[off2] = q2 * cos_val + q1 * sin_val
            k1 := k_ref[off1]
            k2 := k_ref[off2]
            k_ref[off1] = k1 * cos_val - k2 * sin_val
            k_ref[off2] = k2 * cos_val + k1 * sin_val
            d = d + 1
        }
        r = r + 1
    }

    q_d: cuda.CUdeviceptr = 0
    k_d: cuda.CUdeviceptr = 0
    cos_d: cuda.CUdeviceptr = 0
    sin_d: cuda.CUdeviceptr = 0

    _ = cuda.cuMemAlloc(&q_d, q_size)
    _ = cuda.cuMemAlloc(&k_d, k_size)
    _ = cuda.cuMemAlloc(&cos_d, cos_size)
    _ = cuda.cuMemAlloc(&sin_d, sin_size)

    _ = cuda.cuMemcpyHtoD(q_d, q_h.^?*void, q_size)
    _ = cuda.cuMemcpyHtoD(k_d, k_h.^?*void, k_size)
    _ = cuda.cuMemcpyHtoD(cos_d, cos_h.^?*void, cos_size)
    _ = cuda.cuMemcpyHtoD(sin_d, sin_h.^?*void, sin_size)

    triton.launch(
        liger_qwen2vl_mrope.triton_qwen2vl_mrope_kernel,
        grid = (rows, 1, 1),
        block = (128, 1, 1),
        BS = bs,
        N_QH = n_qh,
        N_KH = n_kh,
        HD = hd,
        PAD_N_QH = n_qh,
        PAD_N_KH = n_kh,
        PAD_HD = hd,
        MROPE_SECTION_T = mrope_t,
        MROPE_SECTION_H = mrope_h,
        BLOCK_SIZE = 128,
        q_d,
        k_d,
        cos_d,
        sin_d,
        sl,
    )

    _ = cuda.cuMemcpyDtoH(q_h.^?*void, q_d, q_size)
    _ = cuda.cuMemcpyDtoH(k_h.^?*void, k_d, k_size)

    success := true
    epsilon: f32 = 1.e-4
    i = 0
    while i < rows * q_stride {
        diff := q_h[i] - q_ref[i]
        if diff < 0 { diff = -diff }
        if diff > epsilon {
            io.println("mrope q mismatch at %d: expected %f got %f", i, q_ref[i], q_h[i])
            success = false
            break
        }
        diff = k_h[i] - k_ref[i]
        if diff < 0 { diff = -diff }
        if diff > epsilon {
            io.println("mrope k mismatch at %d: expected %f got %f", i, k_ref[i], k_h[i])
            success = false
            break
        }
        i = i + 1
    }
    if success { io.println("Qwen2VL M-RoPE forward verification passed", ()) }

    _ = cuda.cuMemFree(q_d)
    _ = cuda.cuMemFree(k_d)
    _ = cuda.cuMemFree(cos_d)
    _ = cuda.cuMemFree(sin_d)
}
