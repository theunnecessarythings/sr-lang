package main

liger_fused_add_rms_norm :: import "vendor/liger_fused_add_rms_norm"
triton :: import "vendor/triton"
cuda :: import "vendor/cuda"
io :: import "std/io"
alloc :: import "std/alloc"
math :: import "std/math"

PtrF32 :: triton.Ptr(f32)

main :: proc() {
    res := cuda.cuInit(0)
    if res != cuda.SUCCESS {
        io.println("Failed to init CUDA: %d", res)
        return
    }

    dev: cuda.CUdevice = undefined
    res = cuda.cuDeviceGet(&dev, 0)
    if res != cuda.SUCCESS {
        io.println("Failed to get device", ())
        return
    }

    ctx: cuda.CUcontext = null
    res = cuda.cuCtxCreate(&ctx, 0, dev)
    if res != cuda.SUCCESS {
        io.println("Failed to create context", ())
        return
    }

    n_rows: i32 = 64
    n_cols: i32 = 1024
    stride: i32 = n_cols
    size := n_rows.(usize) * n_cols.(usize) * 4

    x_h_ptr := alloc.alloc(size) orelse return
    x_h := x_h_ptr.^*f32
    r_h_ptr := alloc.alloc(size) orelse return
    r_h := r_h_ptr.^*f32
    w_h_ptr := alloc.alloc(n_cols.(usize) * 4) orelse return
    w_h := w_h_ptr.^*f32
    y_h_ptr := alloc.alloc(size) orelse return
    y_h := y_h_ptr.^*f32
    s_h_ptr := alloc.alloc(size) orelse return
    s_h := s_h_ptr.^*f32
    rstd_h_ptr := alloc.alloc(n_rows.(usize) * 4) orelse return
    rstd_h := rstd_h_ptr.^*f32

    i: i32 = 0
    total: i32 = n_rows * n_cols
    while i < total {
        x_h[i] = ((i % 97) - 48).(f32) * 0.01
        r_h[i] = ((i % 89) - 44).(f32) * 0.02
        i = i + 1
    }

    i = 0
    while i < n_cols {
        w_h[i] = ((i % 31) - 15).(f32) * 0.02
        i = i + 1
    }

    eps: f32 = 1.e-5
    offset: f32 = 0.0

    y_ref_ptr := alloc.alloc(size) orelse return
    y_ref := y_ref_ptr.^*f32
    s_ref_ptr := alloc.alloc(size) orelse return
    s_ref := s_ref_ptr.^*f32
    rstd_ref_ptr := alloc.alloc(n_rows.(usize) * 4) orelse return
    rstd_ref := rstd_ref_ptr.^*f32

    r: i32 = 0
    while r < n_rows {
        sum_sq: f32 = 0.0
        c: i32 = 0
        while c < n_cols {
            idx := r * n_cols + c
            s_val := x_h[idx] + r_h[idx]
            s_ref[idx] = s_val
            sum_sq = sum_sq + s_val * s_val
            c = c + 1
        }
        mean_sq := sum_sq / n_cols.(f32)
        rstd := 1.0.(f32) / math.sqrtf(mean_sq + eps)
        rstd_ref[r] = rstd
        c = 0
        while c < n_cols {
            idx := r * n_cols + c
            y_ref[idx] = s_ref[idx] * rstd * (offset + w_h[c])
            c = c + 1
        }
        r = r + 1
    }

    x_d: cuda.CUdeviceptr = 0
    r_d: cuda.CUdeviceptr = 0
    w_d: cuda.CUdeviceptr = 0
    y_d: cuda.CUdeviceptr = 0
    s_d: cuda.CUdeviceptr = 0
    rstd_d: cuda.CUdeviceptr = 0

    _ = cuda.cuMemAlloc(&x_d, size)
    _ = cuda.cuMemAlloc(&r_d, size)
    _ = cuda.cuMemAlloc(&w_d, n_cols.(usize) * 4)
    _ = cuda.cuMemAlloc(&y_d, size)
    _ = cuda.cuMemAlloc(&s_d, size)
    _ = cuda.cuMemAlloc(&rstd_d, n_rows.(usize) * 4)

    _ = cuda.cuMemcpyHtoD(x_d, x_h.^?*void, size)
    _ = cuda.cuMemcpyHtoD(r_d, r_h.^?*void, size)
    _ = cuda.cuMemcpyHtoD(w_d, w_h.^?*void, n_cols.(usize) * 4)

    triton.launch(
        liger_fused_add_rms_norm.fused_add_rms_norm_forward_kernel,
        grid = (n_rows, 1, 1),
        block = (128, 1, 1),
        BLOCK_SIZE = 1024,
        y_d,
        stride,
        s_d,
        stride,
        x_d,
        stride,
        r_d,
        stride,
        w_d,
        0,
        rstd_d,
        1,
        n_cols,
        eps,
        offset,
    )

    _ = cuda.cuMemcpyDtoH(y_h.^?*void, y_d, size)
    _ = cuda.cuMemcpyDtoH(s_h.^?*void, s_d, size)
    _ = cuda.cuMemcpyDtoH(rstd_h.^?*void, rstd_d, n_rows.(usize) * 4)

    success := true
    epsilon: f32 = 1.e-3
    i = 0
    while i < total {
        diff := y_h[i] - y_ref[i]
        if diff < 0 { diff = -diff }
        if diff > epsilon {
            io.println("y mismatch at %d: expected %f got %f", i, y_ref[i], y_h[i])
            success = false
            break
        }
        diffs := s_h[i] - s_ref[i]
        if diffs < 0 { diffs = -diffs }
        if diffs > epsilon {
            io.println("s mismatch at %d: expected %f got %f", i, s_ref[i], s_h[i])
            success = false
            break
        }
        i = i + 1
    }

    r = 0
    while r < n_rows and success {
        diff := rstd_h[r] - rstd_ref[r]
        if diff < 0 { diff = -diff }
        if diff > 5.e-4 {
            io.println("rstd mismatch at row %d: expected %f got %f", r, rstd_ref[r], rstd_h[r])
            success = false
            break
        }
        r = r + 1
    }

    if success { io.println("Fused add RMSNorm forward verification passed", ()) }

    _ = cuda.cuMemFree(x_d)
    _ = cuda.cuMemFree(r_d)
    _ = cuda.cuMemFree(w_d)
    _ = cuda.cuMemFree(y_d)
    _ = cuda.cuMemFree(s_d)
    _ = cuda.cuMemFree(rstd_d)
}
