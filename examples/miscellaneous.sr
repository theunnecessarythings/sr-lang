// Miscellaneous Language Features

// --- Optional Types (?T) ---
// The `?` prefix on a type makes it optional. It can hold either a value
// of that type or `null`. This is useful for fields that may not have a value.
MaybeString :: ?string

config :: struct {
    // A name for the configuration, which is optional.
    name: ?string,
}

c1 := config{ name: "my-config" }
c2 := config{ name: null }


// --- Loops with `continue` and `break` values ---

// `continue` example
// Print only the odd numbers from 0 to 9.

loop_examples :: proc() {

    for i in 0..10 {
        if i % 2 == 0 {
            continue // Skip the rest of the loop body for even numbers
        }
        print(i)
    }

    // `break` with a label from a nested loop
    outer_loop: for i in 0..10 {
        for j in 0..10 {
            if i * j > 50 {
                // This breaks out of the outer loop, not just the inner one.
                break :outer_loop
            }
        }
    }

    // `break` with a value example
    // A loop can be an expression that evaluates to a value.
    // The `break` statement can provide the result of the loop expression.
    found_value := for i in 0..100 {
        if items[i] == "needle" {
            break i // Exit the loop and return the index `i`
        }
        // If the loop finishes without finding the value, it evaluates to `null`
        // (assuming the loop expression has an optional return type).
    }
}

// --- Error Type Definition ---
// The `error` keyword defines a set of possible error values.
// This is a shorthand for creating a simple enum-like error set.
MyError :: error {
    ThingNotFound,
    PermissionDenied,
    NetworkFailed,
}

// This is roughly equivalent to:
// MyError_equivalent :: enum {
//     ThingNotFound,
//     PermissionDenied,
//     NetworkFailed,
// }

// It can then be used in an error union type.
operation_that_can_fail :: proc() void!MyError {
    if something_bad_happens {
        return MyError.NetworkFailed
    }
}
