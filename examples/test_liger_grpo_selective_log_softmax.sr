package main

liger_grpo_loss :: import "vendor/liger_grpo_loss"
triton :: import "vendor/triton"
cuda :: import "vendor/cuda"
io :: import "std/io"
alloc :: import "std/alloc"
math :: import "std/math"

PtrF32 :: triton.Ptr(f32)
PtrI32 :: triton.Ptr(i32)

main :: proc() {
    res := cuda.cuInit(0)
    if res != cuda.SUCCESS {
        io.println("Failed to init CUDA: %d", res)
        return
    }

    dev: cuda.CUdevice = undefined
    res = cuda.cuDeviceGet(&dev, 0)
    if res != cuda.SUCCESS {
        io.println("Failed to get device", ())
        return
    }

    ctx: cuda.CUcontext = null
    res = cuda.cuCtxCreate(&ctx, 0, dev)
    if res != cuda.SUCCESS {
        io.println("Failed to create context", ())
        return
    }

    B: i32 = 2
    L: i32 = 3
    N: i32 = 64
    logits_size := B.(usize) * (L + 1).(usize) * N.(usize) * 4
    ids_size := B.(usize) * L.(usize) * 4
    out_size := B.(usize) * L.(usize) * 4

    logits_h_ptr := alloc.alloc(logits_size) orelse return
    logits_h := logits_h_ptr.^*f32
    ids_h_ptr := alloc.alloc(ids_size) orelse return
    ids_h := ids_h_ptr.^*i32
    out_h_ptr := alloc.alloc(out_size) orelse return
    out_h := out_h_ptr.^*f32
    mask_h_ptr := alloc.alloc(ids_size) orelse return
    mask_h := mask_h_ptr.^*i32

    i: i32 = 0
    total_logits: i32 = B * (L + 1) * N
    while i < total_logits {
        logits_h[i] = ((i % 97) - 48).(f32) * 0.01
        i = i + 1
    }
    i = 0
    while i < B * L {
        ids_h[i] = (i * 7) % N
        mask_h[i] = 1
        i = i + 1
    }

    // CPU reference
    ref_ptr := alloc.alloc(out_size) orelse return
    ref := ref_ptr.^*f32
    b: i32 = 0
    while b < B {
        l: i32 = 0
        while l < L {
            base := b * (L + 1) * N + l * N
            maxv := logits_h[base]
            c: i32 = 1
            while c < N {
                v := logits_h[base + c]
                if v > maxv { maxv = v }
                c = c + 1
            }
            sum_exp: f32 = 0.0
            c = 0
            while c < N {
                sum_exp = sum_exp + math.expf(logits_h[base + c] - maxv)
                c = c + 1
            }
            lse := maxv + math.logf(sum_exp)
            idx := ids_h[b * L + l]
            x := logits_h[base + idx]
            ref[b * L + l] = x - lse
            l = l + 1
        }
        b = b + 1
    }

    logits_d: cuda.CUdeviceptr = 0
    ids_d: cuda.CUdeviceptr = 0
    out_d: cuda.CUdeviceptr = 0
    mask_d: cuda.CUdeviceptr = 0

    _ = cuda.cuMemAlloc(&logits_d, logits_size)
    _ = cuda.cuMemAlloc(&ids_d, ids_size)
    _ = cuda.cuMemAlloc(&out_d, out_size)
    _ = cuda.cuMemAlloc(&mask_d, ids_size)

    _ = cuda.cuMemcpyHtoD(logits_d, logits_h.^?*void, logits_size)
    _ = cuda.cuMemcpyHtoD(ids_d, ids_h.^?*void, ids_size)
    _ = cuda.cuMemcpyHtoD(mask_d, mask_h.^?*void, ids_size)

    triton.launch(
        liger_grpo_loss.selective_log_softmax_kernel,
        grid = (B, L, 1),
        block = (1, 1, 1),
        BLOCK_N = 64,
        HAS_MASK = 0,
        logits_d,
        ids_d,
        out_d,
        mask_d,
        1.0,
        L,
        L,
        N,
    )

    _ = cuda.cuMemcpyDtoH(out_h.^?*void, out_d, out_size)

    success := true
    epsilon: f32 = 1.e-3
    i = 0
    while i < B * L {
        diff := out_h[i] - ref[i]
        if diff < 0 { diff = -diff }
        if diff > epsilon {
            io.println("logp mismatch at %d: expected %f got %f", i, ref[i], out_h[i])
            success = false
            break
        }
        i = i + 1
    }
    if success { io.println("Selective log-softmax verification passed", ()) }

    _ = cuda.cuMemFree(logits_d)
    _ = cuda.cuMemFree(ids_d)
    _ = cuda.cuMemFree(out_d)
    _ = cuda.cuMemFree(mask_d)
}
