package main

liger_jsd :: import "vendor/liger_jsd"
triton :: import "vendor/triton"
cuda :: import "vendor/cuda"
io :: import "std/io"
alloc :: import "std/alloc"
math :: import "std/math"

PtrF32 :: triton.Ptr(f32)

main :: proc() {
    res := cuda.cuInit(0)
    if res != cuda.SUCCESS {
        io.println("Failed to init CUDA: %d", res)
        return
    }

    dev: cuda.CUdevice = undefined
    res = cuda.cuDeviceGet(&dev, 0)
    if res != cuda.SUCCESS {
        io.println("Failed to get device", ())
        return
    }

    ctx: cuda.CUcontext = null
    res = cuda.cuCtxCreate(&ctx, 0, dev)
    if res != cuda.SUCCESS {
        io.println("Failed to create context", ())
        return
    }

    n_rows: i32 = 4
    n_cols: i32 = 128
    stride: i32 = n_cols
    size := n_rows.(usize) * n_cols.(usize) * 4

    x_h_ptr := alloc.alloc(size) orelse return
    x_h := x_h_ptr.^*f32
    y_h_ptr := alloc.alloc(size) orelse return
    y_h := y_h_ptr.^*f32
    loss_h_ptr := alloc.alloc(size) orelse return
    loss_h := loss_h_ptr.^*f32
    dx_h_ptr := alloc.alloc(size) orelse return
    dx_h := dx_h_ptr.^*f32

    i: i32 = 0
    total: i32 = n_rows * n_cols
    while i < total {
        x_h[i] = ((i % n_cols) - 64).(f32) * 0.01
        y_h[i] = ((i % n_cols) - 32).(f32) * 0.02
        i = i + 1
    }

    loss_ref_ptr := alloc.alloc(size) orelse return
    loss_ref := loss_ref_ptr.^*f32
    dx_ref_ptr := alloc.alloc(size) orelse return
    dx_ref := dx_ref_ptr.^*f32

    beta: f32 = 0.5
    r: i32 = 0
    while r < n_rows {
        base := r * n_cols
        maxv := x_h[base]
        c: i32 = 0
        while c < n_cols {
            if x_h[base + c] > maxv { maxv = x_h[base + c] }
            if y_h[base + c] > maxv { maxv = y_h[base + c] }
            c = c + 1
        }
        sum_loss: f32 = 0.0
        c = 0
        while c < n_cols {
            q := math.expf(x_h[base + c] - maxv) * math.expf(maxv)
            p := math.expf(y_h[base + c] - maxv) * math.expf(maxv)
            m := beta * p + (1.0.(f32) - beta) * q
            log_m := math.logf(m)
            loss_ref[base + c] = beta * p * y_h[base + c] + (1.0.(f32) - beta) * q * x_h[base + c] - m * log_m
            dx_ref[base + c] = (1.0.(f32) - beta) * q * (x_h[base + c] - log_m)
            c = c + 1
        }
        r = r + 1
    }

    scale: f32 = 1.0.(f32) / n_rows.(f32)
    i = 0
    while i < total {
        loss_ref[i] = loss_ref[i] * scale
        dx_ref[i] = dx_ref[i] * scale
        i = i + 1
    }

    x_d: cuda.CUdeviceptr = 0
    y_d: cuda.CUdeviceptr = 0
    loss_d: cuda.CUdeviceptr = 0
    dx_d: cuda.CUdeviceptr = 0

    _ = cuda.cuMemAlloc(&x_d, size)
    _ = cuda.cuMemAlloc(&y_d, size)
    _ = cuda.cuMemAlloc(&loss_d, size)
    _ = cuda.cuMemAlloc(&dx_d, size)

    _ = cuda.cuMemcpyHtoD(x_d, x_h.^?*void, size)
    _ = cuda.cuMemcpyHtoD(y_d, y_h.^?*void, size)

    triton.launch(
        liger_jsd.jsd_kernel,
        grid = (n_rows, 1, 1),
        block = (128, 1, 1),
        BLOCK_SIZE = 128,
        x_d,
        stride,
        y_d,
        stride,
        loss_d,
        stride,
        dx_d,
        stride,
        n_cols,
        n_rows.(f32),
    )

    _ = cuda.cuMemcpyDtoH(loss_h.^?*void, loss_d, size)
    _ = cuda.cuMemcpyDtoH(dx_h.^?*void, dx_d, size)

    success := true
    epsilon: f32 = 1.e-3
    i = 0
    while i < total {
        diff := loss_h[i] - loss_ref[i]
        if diff < 0 { diff = -diff }
        if diff > epsilon {
            io.println("loss mismatch at %d: expected %f got %f", i, loss_ref[i], loss_h[i])
            success = false
            break
        }
        diffx := dx_h[i] - dx_ref[i]
        if diffx < 0 { diffx = -diffx }
        if diffx > epsilon {
            io.println("dx mismatch at %d: expected %f got %f", i, dx_ref[i], dx_h[i])
            success = false
            break
        }
        i = i + 1
    }
    if success { io.println("JSD verification passed", ()) }

    _ = cuda.cuMemFree(x_d)
    _ = cuda.cuMemFree(y_d)
    _ = cuda.cuMemFree(loss_d)
    _ = cuda.cuMemFree(dx_d)
}
