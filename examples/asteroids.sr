package main

rl :: import "vendor/raylib"
m :: import "std/math"

// -----------------------------------------------------
// Config
// -----------------------------------------------------
SCREEN_W : f32 : 800.0
SCREEN_H : f32 : 480.0

MAX_BULLETS :: 64
MAX_ROCKS   :: 64

// -----------------------------------------------------
// Types
// -----------------------------------------------------
Vec2 :: struct {
    x: f32,
    y: f32,
}

Ship :: struct {
    pos: Vec2,
    vel: Vec2,
    angle: f32, // radians
    cooldown: f32,
    alive: bool,
    invuln: f32,
}

Bullet :: struct {
    pos: Vec2,
    vel: Vec2,
    life: f32,
    alive: bool,
}

RockSize :: enum {
    Large, Medium, Small,
}

Rock :: struct {
    pos: Vec2,
    vel: Vec2,
    radius: f32,
    size: RockSize,
    alive: bool,
}

Star :: struct { x: i32, y: i32 }
stars: [60]Star = undefined
// -----------------------------------------------------
// Globals
// -----------------------------------------------------
ship: Ship = undefined
bullets: [64]Bullet = undefined
rocks: [64]Rock = undefined
// bullets: [MAX_BULLETS]Bullet = undefined
// rocks: [MAX_ROCKS]Rock = undefined
score: i32 = 0
game_over: bool = false

// -----------------------------------------------------
// Helpers
// -----------------------------------------------------
vadd :: proc(a: Vec2, b: Vec2) Vec2 { return Vec2{x: a.x + b.x, y: a.y + b.y} }
vsub :: proc(a: Vec2, b: Vec2) Vec2 { return Vec2{x: a.x - b.x, y: a.y - b.y} }
vmul :: proc(a: Vec2, s: f32)  Vec2 { return Vec2{x: a.x * s, y: a.y * s} }

wrap :: proc(p: *Vec2) {
    if p.x < 0.0    { p.x += SCREEN_W }
    if p.x >= SCREEN_W { p.x -= SCREEN_W }
    if p.y < 0.0    { p.y += SCREEN_H }
    if p.y >= SCREEN_H { p.y -= SCREEN_H }
}


init_stars :: proc() {
    for i in 0..60 {
        stars[i] = Star{
            x: rl.GetRandomValue(0, SCREEN_W.(i64) - 1),
            y: rl.GetRandomValue(0, SCREEN_H.(i64) - 1),
        }
    }
}



len2 :: proc(d: Vec2) f32 {
    return d.x * d.x + d.y * d.y
}

spawn_rock :: proc(size: RockSize, pos: Vec2, inherit_vel: Vec2) {
    // find slot
    for i in 0..MAX_ROCKS {
        if !rocks[i].alive {
            rocks[i].alive = true
            rocks[i].size = size
            rocks[i].pos = pos
            // Radius and base speed by size
            radius: f32 = 0.0
            speed: f32 = 0.0
          match size {
              RockSize.Large => {
                  radius = 42.0
                  speed = 60.0
              },
              RockSize.Medium => {
                  radius = 26.0
                  speed = 90.0
              },
              RockSize.Small => {
                  radius = 16.0
                  speed = 130.0
              },
          }
            rocks[i].radius = radius
            // Random direction
            ang := rl.GetRandomValue(0, 360).(f64) * m.TAU / 360.0
            dir := Vec2{x: m.cos(ang), y: m.sin(ang)}
            rocks[i].vel = vadd(vmul(dir, speed), inherit_vel)
            // If spawning fresh, push to screen edges
            if pos.x == -1.0 and pos.y == -1.0{
                side := rl.GetRandomValue(0, 3)
              match side {
                  0 => { 
                      rocks[i].pos = Vec2{x: 0.0, y: rl.GetRandomValue(0, SCREEN_H.(i64)).(f32)}
                  },
                  1 => { 
                      rocks[i].pos = Vec2{x: SCREEN_W, y: rl.GetRandomValue(0, SCREEN_H.(i64)).(f32)} 
                  },
                  2 => { 
                      rocks[i].pos = Vec2{x: rl.GetRandomValue(0, SCREEN_W.(i64)).(f32), y: 0.0} 
                  },
                  3 => { 
                      rocks[i].pos = Vec2{x: rl.GetRandomValue(0, SCREEN_W.(i64)).(f32), y: rl.GetRandomValue(0, SCREEN_H.(i64)).(f32)} 
                  },
              }
            }
            break
        }
    }
}

reset_game :: proc() {
    ship = Ship{
        pos: Vec2{x:SCREEN_W / 2.0.(f32), y:SCREEN_H / 2.0.(f32)},
        vel: Vec2{x:0.0, y: 0.0},
        angle: -m.PI / 2.0, // facing up
        cooldown: 0.0,
        alive: true,
        invuln: 2.0,
    }
    for i in 0..MAX_BULLETS { 
        bullets[i] = Bullet{ pos: Vec2{x: 0.0, y: 0.0}, vel: Vec2{x:0.0,y:0.0}, life: 0.0, alive: false }
    }
    for i in 0..MAX_ROCKS   { 
        rocks[i] = Rock{ pos: Vec2{x: 0.0, y: 0.0}, vel: Vec2{x:0.0,y:0.0}, radius: 0.0, size: RockSize.Large, alive: false }
    }
    score = 0
    game_over = false
    // initial rocks
    for i in 0..8 {
        spawn_rock(RockSize.Large, Vec2{x:-1.0, y:-1.0}, Vec2{x:0.0, y:0.0})
    }
}

shoot :: proc() {
    // find slot
    for i in 0..MAX_BULLETS {
        if !bullets[i].alive {
            dir := Vec2{x:m.cos(ship.angle), y:m.sin(ship.angle)}
            muzzle := vadd(ship.pos, vmul(dir, 18.0))
            bullets[i] = Bullet{
                pos: muzzle,
                vel: vadd(vmul(dir, 380.0), ship.vel),
                life: 1.3,
                alive: true,
            }
            break
        }
    }
}

explode_rock :: proc(idx: i64) {
    if !rocks[idx].alive { return }
    r := rocks[idx]
    rocks[idx].alive = false
    // score & split
    match r.size {
        RockSize.Large => {
            score += 20.(i32)
            spawn_rock(RockSize.Medium, r.pos, r.vel)
            spawn_rock(RockSize.Medium, r.pos, vmul(r.vel, (-1.0).(f32)))
        },
        RockSize.Medium => {
            score += 50.(i32)
            spawn_rock(RockSize.Small, r.pos, r.vel)
            spawn_rock(RockSize.Small, r.pos, vmul(r.vel, (-1.0).(f32)))
        },
        RockSize.Small => {
            score += 100.(i32)
        },
    }
}

draw_ship :: proc() {
    // triangle points relative to ship
    dir := Vec2{x: m.cos(ship.angle), y: m.sin(ship.angle)}
    left := Vec2{x:m.cos(ship.angle + 2.5.(f32)), y: m.sin(ship.angle + 2.5.(f32))}
    right:= Vec2{x: m.cos(ship.angle - 2.5.(f32)), y: m.sin(ship.angle - 2.5.(f32))}
    p0 := vadd(ship.pos, vmul(dir, 14.0))
    p1 := vadd(ship.pos, vmul(left, 10.0))
    p2 := vadd(ship.pos, vmul(right, 10.0))

    color := if ship.invuln > 0.0 { rl.YELLOW } else { rl.WHITE }
        rl.DrawTriangleLines(rl.Vector2{x: p0.x, y: p0.y}, rl.Vector2{x: p1.x, y: p1.y}, rl.Vector2{x: p2.x, y: p2.y}, color)
}

draw_rock :: proc(r: Rock) {
    c := rl.LIGHTGRAY
    if r.size == RockSize.Small { 
        c = rl.GRAY
    }
    rl.DrawCircleLines(r.pos.x.(i32), r.pos.y.(i32), r.radius, c)
}

draw_hud :: proc() {
    txt := rl.TextFormat("Score: %d", score)
    rl.DrawText(txt.^string, 10, 10, 20, rl.WHITE)
    if game_over {
        rl.DrawText("GAME OVER", (SCREEN_W.(f64)/2.0 - 110.0).(i64), (SCREEN_H.(f64)/2.0 - 20.0).(i64), 40, rl.RED)
        rl.DrawText("Press R to restart", (SCREEN_W.(f64)/2.0 - 120.0).(i64), (SCREEN_H.(f64)/2.0 + 30.0).(i64), 20, rl.WHITE)
    }
}


// -----------------------------------------------------
// Main
// -----------------------------------------------------
main :: proc() {
    rl.InitWindow(SCREEN_W.(i32), SCREEN_H.(i32), "Asteroids-ish (raylib)")
    rl.SetTargetFPS(60)

    reset_game()


    while !rl.WindowShouldClose() {
        dt := rl.GetFrameTime()

        // ----- Input -----
        if !game_over and ship.alive {
            if rl.IsKeyDown(rl.KEY_LEFT)  { ship.angle -= 3.5.(f32) * dt }
            if rl.IsKeyDown(rl.KEY_RIGHT) { ship.angle += 3.5.(f32) * dt }

            if rl.IsKeyDown(rl.KEY_UP) {
                thrust := vmul(Vec2{x: m.cos(ship.angle), y: m.sin(ship.angle)}, 220.0.(f32) * dt)
                ship.vel = vadd(ship.vel, thrust)
                // small speed clamp
                maxs := 240.0
                spd2 := len2(ship.vel)
                if spd2 > maxs * maxs {
                    s := maxs / m.sqrt(spd2)
                    ship.vel = vmul(ship.vel, s)
                }
            }

            if rl.IsKeyPressed(rl.KEY_SPACE) and ship.cooldown <= 0.0 {
                shoot()
                ship.cooldown = 0.18
            }
        }

        if rl.IsKeyPressed(rl.KEY_R) {
            reset_game()
        }

        for s in 0..60 { rl.DrawPixel(stars[s].x, stars[s].y, rl.WHITE) }

        // ----- Update -----
        if ship.cooldown > 0.0 { ship.cooldown -= dt }
        if ship.invuln > 0.0   { ship.invuln -= dt }

        if ship.alive and !game_over {
            ship.pos = vadd(ship.pos, vmul(ship.vel, dt))
            wrap(&ship.pos)
        }

        // bullets
        for i in 0..MAX_BULLETS {
            if !bullets[i].alive { continue }
            bullets[i].pos = vadd(bullets[i].pos, vmul(bullets[i].vel, dt))
            wrap(&bullets[i].pos)
            bullets[i].life -= dt
            if bullets[i].life <= 0.0 { 
                bullets[i].alive = false
            }
        }

        // rocks
        alive_rocks := 0
        for i in 0..MAX_ROCKS {
            if !rocks[i].alive { continue }
            alive_rocks += 1
            rocks[i].pos = vadd(rocks[i].pos, vmul(rocks[i].vel, dt))
            wrap(&rocks[i].pos)
        }

        // collisions: bullet vs rock
        for i in 0..MAX_BULLETS {
            if !bullets[i].alive { continue }
            for j in 0..MAX_ROCKS {
                if !rocks[j].alive { continue }
                d := vsub(bullets[i].pos, rocks[j].pos)
                if len2(d) <= (rocks[j].radius * rocks[j].radius) {
                    bullets[i].alive = false
                    explode_rock(j)
                    break
                }
            }
        }

        // collisions: ship vs rock
        if ship.alive and ship.invuln <= 0.0 and !game_over {
            for j in 0..MAX_ROCKS {
                if !rocks[j].alive { continue }
                d := vsub(ship.pos, rocks[j].pos)
                if len2(d) <= (rocks[j].radius * rocks[j].radius) {
                    ship.alive = false
                    game_over = true
                    break
                }
            }
        }

        // wave clear: respawn bigger set
        if alive_rocks == 0 and !game_over {
            // bonus & wave up
            score += 250.(i32)
            // spawn next wave
            count := rl.GetRandomValue(6, 10)
            for k in 0..count {
                spawn_rock(RockSize.Large, Vec2{x:-1.0, y: -1.0}, vmul(ship.vel, 0.2))
            }
            // a little invuln to not insta-die
            ship.invuln = 1.5
        }

        // ----- Draw -----
        rl.BeginDrawing()
        rl.ClearBackground(rl.BLACK)

       
        // ship
        if ship.alive { draw_ship() }

        // thrust flame if accelerating
        if ship.alive and rl.IsKeyDown(rl.KEY_UP) {
            back := Vec2{x: m.cos(ship.angle + m.PI.(f32)), y: m.sin(ship.angle + m.PI.(f32))}
            p := vadd(ship.pos, vmul(back, 12.0))
            rl.DrawCircle(p.x.(i32), p.y.(i32), 3.0, rl.RED)
        }

        // bullets
        for i in 0..MAX_BULLETS {
            if bullets[i].alive {
                rl.DrawCircle(bullets[i].pos.x.(i64), bullets[i].pos.y.(i64), 2.0, rl.WHITE)
            }
        }

        // rocks
        for i in 0..MAX_ROCKS {
            if rocks[i].alive { draw_rock(rocks[i]) }
        }

        draw_hud()
        rl.EndDrawing()
    }

    rl.CloseWindow()
}
