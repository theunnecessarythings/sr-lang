package behavior_integer_literals

testing :: import "std/testing"

test "literals: decimal integer" {
    x := 123
    if !testing.expect_equal_i64(123, x.(i64)) { return Error.Fail }
}

test "literals: negative decimal integer" {
    x := -456
    if !testing.expect_equal_i64(-456, x.(i64)) { return Error.Fail }
}

test "literals: hexadecimal integer" {
    x := 0xFF
    if !testing.expect_equal_i64(255, x.(i64)) { return Error.Fail }
}

test "literals: octal integer" {
    x := 0o755
    if !testing.expect_equal_i64(493, x.(i64)) { return Error.Fail }
}

test "literals: binary integer" {
    x := 0b1011_0011
    if !testing.expect_equal_i64(179, x.(i64)) { return Error.Fail }
}

test "literals: integer with digit separators" {
    x := 1_000_000
    if !testing.expect_equal_i64(1000000, x.(i64)) { return Error.Fail }
}

test "literals: hexadecimal with digit separators" {
    x := 0x_FF_00
    if !testing.expect_equal_i64(65280, x.(i64)) { return Error.Fail }
}

test "literals: zero integer" {
    x := 0
    if !testing.expect_equal_i64(0, x.(i64)) { return Error.Fail }
}

test "literals: uppercase base prefixes" {
    x := 0XFF
    y := 0B1010
    z := 0O77
    if !testing.expect_equal_i64(255, x.(i64)) { return Error.Fail }
    if !testing.expect_equal_i64(10, y.(i64)) { return Error.Fail }
    if !testing.expect_equal_i64(63, z.(i64)) { return Error.Fail }
}

test "literals: negative hexadecimal integer" {
    x := -0x10
    if !testing.expect_equal_i64(-16, x.(i64)) { return Error.Fail }
}

test "literals: max i64 literal" {
    x := 0x7fff_ffff_ffff_ffff
    if !testing.expect_equal_i64(9223372036854775807, x.(i64)) { return Error.Fail }
}
