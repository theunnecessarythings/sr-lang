package behavior_simd_types

testing :: import "std/testing"

test "special_types: simd vector declaration and initialization" {
    vec: simd(f64, 4) = [1.0, 2.0, 3.0, 4.0]
    if !testing.expect_equal_f64(1.0, vec[0], 0.000001) { return Error.Fail }
    if !testing.expect_equal_f64(2.0, vec[1], 0.000001) { return Error.Fail }
    if !testing.expect_equal_f64(3.0, vec[2], 0.000001) { return Error.Fail }
    if !testing.expect_equal_f64(4.0, vec[3], 0.000001) { return Error.Fail }
}

test "special_types: simd vector element access" {
    vec: simd(i32, 2) = [10, 20]
    if !testing.expect_equal_i64(10, vec[0].(i64)) { return Error.Fail }
}

test "special_types: simd vector addition" {
    vec1: simd(f32, 2) = [1.0, 2.0]
    vec2: simd(f32, 2) = [3.0, 4.0]
    sum := vec1 + vec2
    if !testing.expect_equal_f64(4.0, sum[0].(f64), 0.000001) { return Error.Fail }
    if !testing.expect_equal_f64(6.0, sum[1].(f64), 0.000001) { return Error.Fail }
}

test "special_types: simd vector multiplication" {
    vec1: simd(i32, 2) = [2, 3]
    vec2: simd(i32, 2) = [4, 5]
    prod := vec1 * vec2
    if !testing.expect_equal_i64(8, prod[0].(i64)) { return Error.Fail }
    if !testing.expect_equal_i64(15, prod[1].(i64)) { return Error.Fail }
}

test "special_types: simd vector indexing" {
    vec: simd(i32, 4) = [9, 8, 7, 6]
    if !testing.expect_equal_i64(8, vec[1].(i64)) { return Error.Fail }
    if !testing.expect_equal_i64(6, vec[3].(i64)) { return Error.Fail }
}
