package behavior_functions_closures

testing :: import "std/testing"

// Helper for function pointer test
add_fn :: fn(a: i32, b: i32) i32 {
    return a + b
}

test "functions: function pointer assignment and call" {
    // Basic assignment
    my_add := add_fn
    r := my_add(10, 20)
    if !testing.expect_equal_i64(30, r.(i64)) { return Error.Fail }
}

apply_fn :: fn(f: fn(i32, i32) i32, a: i32, b: i32) i32 {
    return f(a, b)
}

test "functions: higher order function (function param)" {
    r := apply_fn(add_fn, 5, 7)
    if !testing.expect_equal_i64(12, r.(i64)) { return Error.Fail }
}

test "functions: closure expression body" {
    add_one := |x: i32| x + 1
    r := add_one(10)
    if !testing.expect_equal_i64(11, r.(i64)) { return Error.Fail }
}

test "functions: closure block body" {
    add_two := |x: i32| i32 {
        y: i32 = 2
        return x + y
    }

    r := add_two(10)
    if !testing.expect_equal_i64(12, r.(i64)) { return Error.Fail }
}

test "functions: captured closure local" {
    base: i32 = 3
    add_base := |x: i32| x + base
    r := add_base(4)
    if !testing.expect_equal_i64(7, r.(i64)) { return Error.Fail }
}

test "functions: higher order function (closure param)" {
    r := apply_fn(|a: i32, b: i32| a + b, 3, 4)
    if !testing.expect_equal_i64(7, r.(i64)) { return Error.Fail }
}

test "functions: variadic with any" {
    variadic_helper(1, 2, 3)
}

variadic_helper :: proc(args: any) {
}
