package behavior_functions_closures

testing :: import "std/testing"

// Helper for function pointer test
add_fn :: fn(a: i32, b: i32) i32 {
    return a + b
}

/*
test "functions: function pointer assignment and call" {
    // Basic assignment
    my_add := add_fn
    r := my_add(10, 20)
    if !testing.expect_equal_i64(30, r.(i64)) { return Error.Fail }
}

apply_fn :: fn(f: fn(i32, i32) i32, a: i32, b: i32) i32 {
    return f(a, b)
}

test "functions: higher order function (function param)" {
    r := apply_fn(add_fn, 5, 7)
    if !testing.expect_equal_i64(12, r.(i64)) { return Error.Fail }
}
*/

// Closures are currently only implemented for parsing.
/*
test "functions: closure expression body" {
    add_one := |x: i32| x + 1
    r := add_one(10)
    if !testing.expect_equal_i64(11, r.(i64)) { return Error.Fail }
}

test "functions: closure block body" {
    add_two := |x: i32| i32 {
        y := 2
        return x + y
    }
    r := add_two(10)
    if !testing.expect_equal_i64(12, r.(i64)) { return Error.Fail }
}

test "functions: closure capture" {
    y := 10
    add_y := |x: i32| x + y
    r := add_y(5)
    if !testing.expect_equal_i64(15, r.(i64)) { return Error.Fail }
}
*/

test "functions: variadic with any" {
    variadic_helper(1, 2, 3)
}

variadic_helper :: proc(args: any) {
}
