package behavior_async

testing :: import "std/testing"
io :: import "std/io"

my_async_proc :: async proc() {
    io.print("Async proc started\n")
}

my_async_fn :: async fn() i32 {
    return 100
}

async_task1 :: async proc() {
    io.print("Task 1\n")
}

async_task2 :: async proc() {
    io.print("Task 2\n")
}

async_add_one :: async fn(x: i32) i32 {
    if x > 0 { return x + 1 }
    return x - 1
}

async_pair :: async fn(a: i32, b: i32) (i32, i32) {
    return (a, b)
}

async_double :: async fn(x: i32) i32 {
    return x * 2
}

async_plus_one :: async fn(x: i32) i32 {
    y := async_double(x).await
    return y + 1
}

async_noop :: async proc() {
    // no-op
}

test "declarations: basic async proc" {
    my_async_proc().await
    // If we reached here, it didn't crash
}

test "declarations: basic async fn" {
    r := my_async_fn().await
    if !testing.expect_equal_i64(100, r.(i64)) { return Error.Fail }
}

test "declarations: multiple async calls and await" {
    async_task1().await
    async_task2().await
}

test "declarations: async fn with params and branching" {
    r1 := async_add_one(5).await
    r2 := async_add_one(0).await
    if !testing.expect_equal_i64(6, r1.(i64)) { return Error.Fail }
    if !testing.expect_equal_i64(-1, r2.(i64)) { return Error.Fail }
}

test "declarations: async fn returning tuple" {
    pair := async_pair(7, 9).await
    if !testing.expect_equal_i64(7, pair.0.(i64)) { return Error.Fail }
    if !testing.expect_equal_i64(9, pair.1.(i64)) { return Error.Fail }
}

test "declarations: nested await inside async fn" {
    r := async_plus_one(10).await
    if !testing.expect_equal_i64(21, r.(i64)) { return Error.Fail }
}

test "declarations: await in loop and branch" {
    sum := 0
    for i in 0..3 {
        if i == 1 {
            async_task1().await
        } else {
            async_task2().await
        }
        sum = sum + i.(i64)
    }
    if !testing.expect_equal_i64(3, sum) { return Error.Fail }
}

test "declarations: await void future in loop" {
    for _ in 0..2 {
        async_noop().await
    }
}
