package main

rl :: import "vendor/raylib"

ptrcast :: proc(ptr: any) *void {
  return ptr.^*void
}

SDF :: struct {
  shader: rl.Shader,
  resolution_loc: i32,
  circle_center_loc: i32,
  circle_radius_loc: i32,
  rect_center_loc: i32,
  rect_size_loc: i32,
}

CircleBuilder :: struct {
    sdf_ctx: *SDF,
    center: rl.Vector2,
    radius: f32,
}

RectBuilder :: struct {
    sdf_ctx: *SDF,
    center: rl.Vector2,
    size: rl.Vector2,
}

SDF.init :: proc() SDF {
  shader :: rl.LoadShader(0.^string, "frag.glsl")
  
  return SDF {
    shader: shader,
    resolution_loc: rl.GetShaderLocation(shader, "resolution"),
    circle_center_loc: rl.GetShaderLocation(shader, "circle_center"),
    circle_radius_loc: rl.GetShaderLocation(shader, "circle_radius"),
    rect_center_loc: rl.GetShaderLocation(shader, "rect_center"),
    rect_size_loc: rl.GetShaderLocation(shader, "rect_size"),
  }
}

SDF.begin :: proc(self: *SDF) {
    resolution :: rl.Vector2{x: rl.GetScreenWidth().(f32), y: rl.GetScreenHeight().(f32)}
    rl.SetShaderValue(self.shader, self.resolution_loc, ptrcast(&resolution), rl.ShaderUniformDataType.SHADER_UNIFORM_VEC2)
    rl.BeginShaderMode(self.shader)
    rl.DrawRectangle(0, 0, resolution.x.(i32), resolution.y.(i32), rl.WHITE)
}

SDF.end :: proc(self: *SDF) {
    rl.EndShaderMode()
}

SDF.circle :: proc(self: *SDF, center: rl.Vector2, radius: f32) {
  screen_width :: rl.GetScreenWidth().(f32)
  screen_height :: rl.GetScreenHeight().(f32)
  aspect_ratio :: screen_width / screen_height

  // Normalize coordinates and radius
  uv_center :: rl.Vector2 {
    x: (center.x / screen_width) * 2.0.(f32) - 1.0.(f32),
    y: (center.y / screen_height) * -2.0.(f32) + 1.0.(f32), // Y is inverted in shaders
  }
  uv_center.x *= aspect_ratio

  uv_radius :: radius / screen_height

  rl.SetShaderValue(self.shader, self.circle_center_loc, ptrcast(&uv_center), rl.ShaderUniformDataType.SHADER_UNIFORM_VEC2)
  rl.SetShaderValue(self.shader, self.circle_radius_loc, ptrcast(&uv_radius), rl.ShaderUniformDataType.SHADER_UNIFORM_FLOAT)
}

SDF.rect :: proc(self: *SDF, center: rl.Vector2, size: rl.Vector2) {
  screen_width :: rl.GetScreenWidth().(f32)
  screen_height :: rl.GetScreenHeight().(f32)
  aspect_ratio :: screen_width / screen_height

  // Normalize coordinates and size
  uv_center :: rl.Vector2 {
    x: (center.x / screen_width) * 2.0.(f32) - 1.0.(f32),
    y: (center.y / screen_height) * -2.0.(f32) + 1.0.(f32), // Y is inverted
  }
  uv_center.x *= aspect_ratio

  uv_size :: rl.Vector2 {
    x: (size.x / screen_height) / 2.0.(f32),
    y: (size.y / screen_height) / 2.0.(f32),
  }

  rl.SetShaderValue(self.shader, self.rect_center_loc, ptrcast(&uv_center), rl.ShaderUniformDataType.SHADER_UNIFORM_VEC2)
  rl.SetShaderValue(self.shader, self.rect_size_loc, ptrcast(&uv_size), rl.ShaderUniformDataType.SHADER_UNIFORM_VEC2)
}

SDF.build_circle :: proc(self: *SDF) CircleBuilder {
    return CircleBuilder {
        sdf_ctx: self,
        center: rl.Vector2 { x: 0.0, y: 0.0 },
        radius: 0.0,
    }
}

CircleBuilder.center :: proc(self: *CircleBuilder, x: f32, y: f32) *CircleBuilder {
    self.center.x = x
    self.center.y = y
    return self
}

CircleBuilder.radius :: proc(self: *CircleBuilder, r: f32) *CircleBuilder {
    self.radius = r
    return self
}

CircleBuilder.draw :: proc(self: *CircleBuilder) {
    SDF.circle(self.sdf_ctx, self.center, self.radius)
}

SDF.build_rect :: proc(self: *SDF) RectBuilder {
    return RectBuilder {
        sdf_ctx: self,
        center: rl.Vector2 { x: 0.0, y: 0.0 },
        size: rl.Vector2 { x: 0.0, y: 0.0 },
    }
}

RectBuilder.center :: proc(self: *RectBuilder, x: f32, y: f32) *RectBuilder {
    self.center.x = x
    self.center.y = y
    return self
}

RectBuilder.size :: proc(self: *RectBuilder, w: f32, h: f32) *RectBuilder {
    self.size.x = w
    self.size.y = h
    return self
}

RectBuilder.draw :: proc(self: *RectBuilder) {
    SDF.rect(self.sdf_ctx, self.center, self.size)
}
