package str

// ASCII string utilities

rt_strlen :: extern proc(*u8) usize
rt_memcmp :: extern proc(*u8, *u8, usize) i32
rt_ptr_add :: extern proc(*u8, usize) *u8

length :: proc(s: string) usize { return rt_strlen(s.^*u8) }

eq :: proc(a: string, b: string) bool {
    al := rt_strlen(a.^*u8)
    bl := rt_strlen(b.^*u8)
    if (al != bl) { return false }
    return rt_memcmp(a.^*u8, b.^*u8, al) == 0
}

starts_with :: proc(s: string, prefix: string) bool {
    sl := rt_strlen(s.^*u8)
    pl := rt_strlen(prefix.^*u8)
    if (pl > sl) { return false }
    return rt_memcmp(s.^*u8, prefix.^*u8, pl) == 0
}

ends_with :: proc(s: string, suffix: string) bool {
    sl := rt_strlen(s.^*u8)
    tl := rt_strlen(suffix.^*u8)
    if (tl > sl) { return false }
    off := sl - tl
    return rt_memcmp(rt_ptr_add(s.^*u8, off), suffix.^*u8, tl) == 0
}

contains :: proc(s: string, sub: string) bool { return find(s, sub) != null }

// Naive search; returns index or null if not found
find :: proc(s: string, sub: string) ?usize {
    sl := rt_strlen(s.^*u8)
    tl := rt_strlen(sub.^*u8)
    if (tl == 0) { return 0 }
    if (tl > sl) { return null }
    i: usize = 0
    while (i + tl <= sl) {
        if (rt_memcmp(rt_ptr_add(s.^*u8, i), sub.^*u8, tl) == 0) { return i }
        i = i + 1
    }
    return null
}
