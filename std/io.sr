package io

// Minimal std I/O wrappers built on C printf and runtime helpers.

// C stdio printf (varargs enabled by trailing `any`).
printf :: extern proc(*void, any) i32

// Runtime helpers for raw printing and panic.
rt_print  :: extern proc(*u8, usize) void
rt_eprint :: extern proc(*u8, usize) void
rt_panic  :: extern proc(*u8, usize) noreturn
rt_strlen :: extern proc(*u8) usize

// Writer interface
Writer :: struct { ctx: *void, write: proc(*void, *u8, usize) usize }

// Write all helper: attempts to write the full buffer; returns whether succeeded
write_all :: proc(w: *Writer, buf: *u8, len: usize) bool {
    // For stdout/stderr we assume full writes; loop kept for future fd writers
    n := w.write(w.ctx, buf, len)
    return n == len
}

// stdout writer implementation
stdout_write_impl :: proc(ctx: *void, buf: *u8, len: usize) usize {
    rt_print(buf, len)
    return len
}

// stderr writer implementation
stderr_write_impl :: proc(ctx: *void, buf: *u8, len: usize) usize {
    rt_eprint(buf, len)
    return len
}

stdout :: proc() Writer { return Writer{ ctx: 0.^*void, write: stdout_write_impl } }
stderr :: proc() Writer { return Writer{ ctx: 0.^*void, write: stderr_write_impl } }

// Print with one argument. Example: print("%d", 42)
print :: proc(fmt: string, arg: any) void { printf(fmt.^*void, arg) }

// Print a format string with no additional args.
print0 :: proc(fmt: string) void { printf(fmt.^*void) }

// Print line with one argument (appends newline)
println :: proc(fmt: string, arg: any) void { printf(fmt.^*void, arg); printf("\n".^*void) }

// Print line with no args (just prints fmt then newline)
println0 :: proc(fmt: string) void { printf(fmt.^*void); printf("\n".^*void) }

// Write a raw string to stderr (no formatting)
eprint0 :: proc(s: string) void { rt_eprint(s.^*u8, rt_strlen(s.^*u8)) }

// Write a raw string to stderr with newline
eprintln0 :: proc(s: string) void { rt_eprint(s.^*u8, rt_strlen(s.^*u8)); rt_eprint("\n".^*u8, 1) }

// Panic with message (noreturn)
panic :: proc(msg: string) noreturn { rt_panic(msg.^*u8, rt_strlen(msg.^*u8)) }

// Assert
assert :: proc(cond: bool, msg: string) noreturn {
    if !cond  { panic(msg) }
}
