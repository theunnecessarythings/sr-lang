package meta

str :: import "std/str"

TypeInfo :: typeof(typeinfo(void))

typeInfo :: proc(comptime T: type) TypeInfo {
    return typeinfo(T)
}

tag :: proc(comptime info: TypeInfo) string {
    return match info {
        TypeInfo.Void => "Void",
        TypeInfo.Bool => "Bool",
        TypeInfo.I8 => "I8",
        TypeInfo.I16 => "I16",
        TypeInfo.I32 => "I32",
        TypeInfo.I64 => "I64",
        TypeInfo.U8 => "U8",
        TypeInfo.U16 => "U16",
        TypeInfo.U32 => "U32",
        TypeInfo.U64 => "U64",
        TypeInfo.F32 => "F32",
        TypeInfo.F64 => "F64",
        TypeInfo.Usize => "Usize",
        TypeInfo.Complex(_) => "Complex",
        TypeInfo.Tensor(_) => "Tensor",
        TypeInfo.Simd(_) => "Simd",
        TypeInfo.String => "String",
        TypeInfo.Any => "Any",
        TypeInfo.Code => "Code",
        TypeInfo.Undef => "Undef",
        TypeInfo.Ptr(_) => "Ptr",
        TypeInfo.Slice(_) => "Slice",
        TypeInfo.Array(_) => "Array",
        TypeInfo.DynArray(_) => "DynArray",
        TypeInfo.Map(_) => "Map",
        TypeInfo.Optional(_) => "Optional",
        TypeInfo.Tuple(_) => "Tuple",
        TypeInfo.Function(_) => "Function",
        TypeInfo.Struct(_) => "Struct",
        TypeInfo.Union(_) => "Union",
        TypeInfo.Enum(_) => "Enum",
        TypeInfo.Variant(_) => "Variant",
        TypeInfo.Error(_) => "Error",
        TypeInfo.ErrorSet(_) => "ErrorSet",
        TypeInfo.MlirModule => "MlirModule",
        TypeInfo.MlirAttribute(_) => "MlirAttribute",
        TypeInfo.MlirType(_) => "MlirType",
        TypeInfo.TypeType(_) => "TypeType",
        TypeInfo.Future(_) => "Future",
        TypeInfo.Noreturn => "Noreturn",
        TypeInfo.Ast(_) => "Ast",
        TypeInfo.TypeError => "TypeError",
    }
}

isKind :: proc(comptime info: TypeInfo, kind: string) bool {
    return str.eq(tag(info), kind)
}

code_empty :: proc() Code {
    return code { }
}

code_concat :: proc(left: Code, right: Code) Code {
    return code {
        `left`
        `right`
    }
}

code_join :: proc(comptime blocks: []Code) Code {
    if blocks.len == 0 {
        return code_empty()
    }

    out := blocks[0]
    for b in blocks[1..blocks.len] {
        out = code_concat(out, b)
    }
    return out
}

code_expr :: proc(comptime value: any) Code {
    return code { `value` }
}


// CodeInfo :: typeof(codeinfo(code {}))

// codeInfo :: proc(comptime c: Code) CodeInfo {
//     return codeinfo(c)
// }

// codeFromInfo :: proc(comptime info: CodeInfo) Code {
//     return codeFromInfo(info)
// }
