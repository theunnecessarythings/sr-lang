package mem

// Memory operations: wrappers over runtime functions
rt_memcpy :: extern proc(*u8, *u8, usize) void
rt_memmove :: extern proc(*u8, *u8, usize) void
rt_memset :: extern proc(*u8, u8, usize) void

// Copy memory from src to dst
copy :: proc(dst: *void, src: *void, len: usize) void {
    rt_memcpy(dst.^*u8, src.^*u8, len)
}

// Move memory (safe for overlap)
move :: proc(dst: *void, src: *void, len: usize) void {
    rt_memmove(dst.^*u8, src.^*u8, len)
}

// Set memory to byte value
set :: proc(dst: *void, value: u8, len: usize) void {
    rt_memset(dst.^*u8, value, len)
}

// Generic slice operations

eql :: proc(comptime T: type, a: []T, b: []T) bool {
    if a.len != b.len {
        return false
    }
    i: usize = 0
    while i < a.len {
        v1 := a[i]
        v2 := b[i]
        if v1 != v2 {
            return false
        }
        i = i + 1
    }
    return true
}

index_of :: proc(comptime T: type, haystack: []T, needle: []T) ?usize {
    if needle.len == 0 { return 0 }
    if needle.len > haystack.len { return null }
    
    end := haystack.len - needle.len + 1
    i: usize = 0
    while i < end {
        if eql(T, haystack[i .. i + needle.len], needle) {
            return i
        }
        i = i + 1
    }
    return null
}

index_of_scalar :: proc(comptime T: type, slice: []T, value: T) ?usize {
    i: usize = 0
    while i < slice.len {
        v := slice[i]
        if v == value {
            return i
        }
        i = i + 1
    }
    return null
}

last_index_of_scalar :: proc(comptime T: type, slice: []T, value: T) ?usize {
    i := slice.len
    while i > 0 {
        i -= 1
        if slice[i] == value {
            return i
        }
    }
    return null
}

starts_with :: proc(comptime T: type, haystack: []T, needle: []T) bool {
    if needle.len > haystack.len {
        return false
    }
    return eql(T, haystack[0 .. needle.len], needle)
}

ends_with :: proc(comptime T: type, haystack: []T, needle: []T) bool {
    if needle.len > haystack.len {
        return false
    }
    return eql(T, haystack[haystack.len - needle.len .. haystack.len], needle)
}

count :: proc(comptime T: type, slice: []T, value: T) usize {
    c: usize = 0
    i: usize = 0
    while i < slice.len {
        if slice[i] == value {
            c += 1
        }
        i = i + 1
    }
    return c
}

swap :: proc(comptime T: type, a: *T, b: *T) void {
    tmp := a.*
    a.* = b.*
    b.* = tmp
}

reverse :: proc(comptime T: type, slice: []T) void {
    if slice.len == 0 { return }
    i: usize = 0
    j := slice.len - 1
    while i < j {
        swap(T, &slice[i], &slice[j])
        i += 1
        j -= 1
    }
}

// Alignment utils

align_forward :: proc(addr: usize, alignment: usize) usize {
    mask := 0 -% alignment
    return (addr + alignment - 1) & mask
}

is_aligned :: proc(addr: usize, alignment: usize) bool {
    return (addr & (alignment - 1)) == 0
}
