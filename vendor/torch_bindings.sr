package torch_bindings

// THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT BY HAND!

Tensor :: ?*void
Scalar :: ?*void
Optimizer :: ?*void
Module :: ?*void
IValue :: ?*void

free :: extern proc(ptr: *void)

// --- Bindings ---

// Manual addition: print a tensor via C++ stream operator
at_print :: extern proc(t: Tensor)

// --- Manual Torch API helpers (from torch_api.h) ---

// Error utilities
get_and_reset_last_err :: extern fn() *const u8

// RNG / seeding
at_manual_seed :: extern proc(seed: i64)

// Tensor construction and data access
at_new_tensor :: extern fn() Tensor
at_tensor_of_data :: extern fn(vs: *void, dims: *i64, ndims: usize, element_size_in_bytes: usize, type_: i32) Tensor
at_tensor_of_blob :: extern fn(data: *void, dims: *i64, ndims: usize, strides: *i64, nstrides: usize, type_: i32, device: i32) Tensor
at_copy_data :: extern proc(t: Tensor, vs: *void, numel: usize, element_size_in_bytes: usize)
at_shallow_clone :: extern fn(t: Tensor) Tensor
at_data_ptr :: extern fn(t: Tensor) *void

// Tensor properties
at_defined :: extern fn(t: Tensor) i32
at_is_mkldnn :: extern fn(t: Tensor) i32
at_is_sparse :: extern fn(t: Tensor) i32
at_is_contiguous :: extern fn(t: Tensor) i32
at_device :: extern fn(t: Tensor) i32
at_dim :: extern fn(t: Tensor) usize
at_shape :: extern proc(t: Tensor, out_sizes: *i64)
at_stride :: extern proc(t: Tensor, out_strides: *i64)
at_scalar_type :: extern fn(t: Tensor) i32

// Autocast helpers
at__amp_non_finite_check_and_unscale :: extern proc(g: Tensor, found_inf: Tensor, inv_scale: Tensor)
at_autocast_clear_cache :: extern proc()
at_autocast_decrement_nesting :: extern fn() i32
at_autocast_increment_nesting :: extern fn() i32
at_autocast_is_enabled :: extern fn() bool
at_autocast_set_enabled :: extern fn(enabled: bool) bool

// Autograd
at_backward :: extern proc(t: Tensor, keep_graph: i32, create_graph: i32)
at_requires_grad :: extern fn(t: Tensor) i32
at_grad_set_enabled :: extern fn(enabled: i32) i32
at_run_backward :: extern proc(tensors: *Tensor, ntensors: i32, inputs: *Tensor, ninputs: i32, outputs: *Tensor, keep_graph: i32, create_graph: i32)

// Tensor element/value helpers
at_get :: extern fn(t: Tensor, index: i32) Tensor
at_fill_double :: extern proc(t: Tensor, v: f64)
at_fill_int64 :: extern proc(t: Tensor, v: i64)
at_double_value_at_indexes :: extern fn(t: Tensor, indexes: *i64, indexes_len: i32) f64
at_int64_value_at_indexes :: extern fn(t: Tensor, indexes: *i64, indexes_len: i32) i64
at_set_double_value_at_indexes :: extern proc(t: Tensor, indexes: *i32, indexes_len: i32, v: f64)
at_set_int64_value_at_indexes :: extern proc(t: Tensor, indexes: *i32, indexes_len: i32, v: i64)
at_copy_ :: extern proc(dst: Tensor, src: Tensor)

// IO helpers
at_to_string :: extern fn(t: Tensor, line_size: i32) *const u8
at_save :: extern proc(t: Tensor, filename: *const u8)
at_save_to_stream :: extern proc(t: Tensor, stream_ptr: *void)
at_load :: extern fn(filename: *const u8) Tensor
at_load_from_stream :: extern fn(stream_ptr: *void) Tensor
at_load_image :: extern fn(filename: *const u8) Tensor
at_load_image_from_memory :: extern fn(img_data: *const u8, img_size: usize) Tensor
at_save_image :: extern fn(t: Tensor, filename: *const u8) i32
at_resize_image :: extern fn(t: Tensor, w: i32, h: i32) Tensor
at_save_multi :: extern proc(tensors: *Tensor, tensor_names: **u8, ntensors: i32, filename: *const u8)
at_save_multi_to_stream :: extern proc(tensors: *Tensor, tensor_names: **u8, ntensors: i32, stream_ptr: *void)
at_load_multi :: extern proc(tensors: *Tensor, tensor_names: **u8, ntensors: i32, filename: *const u8)
at_load_multi_ :: extern proc(tensors: *Tensor, tensor_names: **u8, ntensors: i32, filename: *const u8)

// Threading and engine
at_get_num_interop_threads :: extern fn() i32
at_get_num_threads :: extern fn() i32
at_set_num_interop_threads :: extern proc(n_threads: i32)
at_set_num_threads :: extern proc(n_threads: i32)
at_set_qengine :: extern proc(qengine: i32)

// Resource management
at_free :: extern proc(t: Tensor)

// Optimizers
ato_adam :: extern fn(learning_rate: f64, beta1: f64, beta2: f64, weight_decay: f64, eps: f64, amsgrad: bool) Optimizer
ato_adamw :: extern fn(learning_rate: f64, beta1: f64, beta2: f64, weight_decay: f64, eps: f64, amsgrad: bool) Optimizer
ato_rms_prop :: extern fn(learning_rate: f64, alpha: f64, eps: f64, weight_decay: f64, momentum: f64, centered: i32) Optimizer
ato_sgd :: extern fn(learning_rate: f64, momentum: f64, dampening: f64, weight_decay: f64, nesterov: i32) Optimizer
ato_add_parameters :: extern proc(opt: Optimizer, t: Tensor, group: usize)
ato_set_learning_rate :: extern proc(opt: Optimizer, learning_rate: f64)
ato_set_momentum :: extern proc(opt: Optimizer, momentum: f64)
ato_set_learning_rate_group :: extern proc(opt: Optimizer, group: usize, learning_rate: f64)
ato_set_momentum_group :: extern proc(opt: Optimizer, group: usize, momentum: f64)
ato_set_weight_decay :: extern proc(opt: Optimizer, weight_decay: f64)
ato_set_weight_decay_group :: extern proc(opt: Optimizer, group: usize, weight_decay: f64)
ato_zero_grad :: extern proc(opt: Optimizer)
ato_step :: extern proc(opt: Optimizer)
ato_free :: extern proc(opt: Optimizer)

// Scalars
ats_int :: extern fn(v: i64) Scalar
ats_float :: extern fn(v: f64) Scalar
ats_to_int :: extern fn(s: Scalar) i64
ats_to_float :: extern fn(s: Scalar) f64
ats_to_string :: extern fn(s: Scalar) *const u8
ats_free :: extern proc(s: Scalar)
at_tensor_item_float :: extern proc(t: Tensor) f32

// Build/context capabilities
at_context_has_openmp :: extern fn() bool
at_context_has_mkl :: extern fn() bool
at_context_has_lapack :: extern fn() bool
at_context_has_mkldnn :: extern fn() bool
at_context_has_magma :: extern fn() bool
at_context_has_cuda :: extern fn() bool
at_context_has_cudart :: extern fn() bool
at_context_has_cudnn :: extern fn() bool
at_context_version_cudnn :: extern fn() i64
at_context_version_cudart :: extern fn() i64
at_context_has_cusolver :: extern fn() bool
at_context_has_hip :: extern fn() bool
at_context_has_ipu :: extern fn() bool
at_context_has_xla :: extern fn() bool
at_context_has_lazy :: extern fn() bool
at_context_has_mps :: extern fn() bool

// CUDA helpers
atc_cuda_device_count :: extern fn() i32
atc_cuda_is_available :: extern fn() i32
atc_cudnn_is_available :: extern fn() i32
atc_manual_seed :: extern proc(seed: u64)
atc_manual_seed_all :: extern proc(seed: u64)
atc_synchronize :: extern proc(device_index: i64)
atc_user_enabled_cudnn :: extern fn() i32
atc_set_user_enabled_cudnn :: extern proc(b: i32)
atc_set_benchmark_cudnn :: extern proc(b: i32)

// TorchScript module (subset)
atm_load :: extern fn(path: *const u8) Module
atm_load_on_device :: extern fn(path: *const u8, device: i32) Module
atm_eval :: extern proc(m: Module)
atm_train :: extern proc(m: Module)
atm_free :: extern proc(m: Module)
atm_to :: extern proc(m: Module, device: i32, dtype: i32, non_blocking: bool)
atm_save :: extern proc(m: Module, path: *const u8)
atm_forward :: extern fn(m: Module, tensors: *Tensor, ntensors: i32) Tensor

// IValue (subset)
ati_tensor :: extern fn(t: Tensor) IValue
ati_int :: extern fn(v: i64) IValue
ati_double :: extern fn(v: f64) IValue
ati_bool :: extern fn(v: i32) IValue
ati_string :: extern fn(ptr: *const u8) IValue
ati_free :: extern proc(v: IValue)

atg___and__ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg___and__tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg___iand__ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg___iand__tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg___ilshift__ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg___ilshift__tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg___ior__ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg___ior__tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg___irshift__ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg___irshift__tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg___ixor__ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg___ixor__tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg___lshift__ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg___lshift__scalar_out_ :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg___lshift__tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg___lshift__tensor_out_ :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg___or__ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg___or__tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg___rshift__ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg___rshift__scalar_out_ :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg___rshift__tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg___rshift__tensor_out_ :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg___xor__ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg___xor__tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg__adaptive_avg_pool2d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg__adaptive_avg_pool2d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor)
atg__adaptive_avg_pool2d_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, self: Tensor)
atg__adaptive_avg_pool2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg__adaptive_avg_pool3d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg__adaptive_avg_pool3d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor)
atg__adaptive_avg_pool3d_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, self: Tensor)
atg__adaptive_avg_pool3d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg__add_batch_dim :: extern proc(out__: *Tensor, self: Tensor, batch_dim: i64, level: i64)
atg__add_relu :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg__add_relu_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg__add_relu_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg__add_relu_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg__add_relu_scalar_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg__add_relu_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg__addmm_activation :: extern proc(out__: *Tensor, self: Tensor, mat1: Tensor, mat2: Tensor, use_gelu: bool)
atg__addmm_activation_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mat1: Tensor, mat2: Tensor, use_gelu: bool)
atg__aminmax :: extern proc(out__: *Tensor, self: Tensor)
atg__aminmax_dim :: extern proc(out__: *Tensor, self: Tensor, dim: i64, keepdim: bool)
atg__aminmax_dim_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, self: Tensor, dim: i64, keepdim: bool)
atg__aminmax_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, self: Tensor)
atg__amp_update_scale :: extern proc(out__: *Tensor, self: Tensor, growth_tracker: Tensor, found_inf: Tensor, scale_growth_factor: f64, scale_backoff_factor: f64, growth_interval: i64)
atg__amp_update_scale_ :: extern proc(out__: *Tensor, self: Tensor, growth_tracker: Tensor, found_inf: Tensor, scale_growth_factor: f64, scale_backoff_factor: f64, growth_interval: i64)
atg__amp_update_scale_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, growth_tracker: Tensor, found_inf: Tensor, scale_growth_factor: f64, scale_backoff_factor: f64, growth_interval: i64)
atg__assert_scalar :: extern proc(self_scalar: Scalar, assert_msg_ptr: *const u8, assert_msg_len: i32)
atg__assert_tensor_metadata :: extern proc(a: Tensor, size_data: *i64, size_len: i32, stride_data: *i64, stride_len: i32, dtype: i32, device: i32, layout: i8)
atg__autocast_to_full_precision :: extern proc(out__: *Tensor, self: Tensor, cuda_enabled: bool, cpu_enabled: bool)
atg__autocast_to_reduced_precision :: extern proc(out__: *Tensor, self: Tensor, cuda_enabled: bool, cpu_enabled: bool, cuda_dtype: i32, cpu_dtype: i32)
atg__batch_norm_no_update :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, momentum: f64, eps: f64)
atg__batch_norm_no_update_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, out3: Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, momentum: f64, eps: f64)
atg__batch_norm_with_update :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, momentum: f64, eps: f64)
atg__batch_norm_with_update_functional :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, momentum: f64, eps: f64)
atg__batch_norm_with_update_out :: extern proc(out__: *Tensor, out: Tensor, save_mean: Tensor, save_invstd: Tensor, reserve: Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, momentum: f64, eps: f64)
atg__cast_byte :: extern proc(out__: *Tensor, self: Tensor, non_blocking: bool)
atg__cast_char :: extern proc(out__: *Tensor, self: Tensor, non_blocking: bool)
atg__cast_double :: extern proc(out__: *Tensor, self: Tensor, non_blocking: bool)
atg__cast_float :: extern proc(out__: *Tensor, self: Tensor, non_blocking: bool)
atg__cast_half :: extern proc(out__: *Tensor, self: Tensor, non_blocking: bool)
atg__cast_int :: extern proc(out__: *Tensor, self: Tensor, non_blocking: bool)
atg__cast_long :: extern proc(out__: *Tensor, self: Tensor, non_blocking: bool)
atg__cast_short :: extern proc(out__: *Tensor, self: Tensor, non_blocking: bool)
atg__cdist_backward :: extern proc(out__: *Tensor, grad: Tensor, x1: Tensor, x2: Tensor, p: f64, cdist: Tensor)
atg__cdist_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad: Tensor, x1: Tensor, x2: Tensor, p: f64, cdist: Tensor)
atg__cholesky_solve_helper :: extern proc(out__: *Tensor, self: Tensor, A: Tensor, upper: bool)
atg__cholesky_solve_helper_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, A: Tensor, upper: bool)
atg__chunk_cat :: extern proc(out__: *Tensor, tensors_data: *Tensor, tensors_len: i32, dim: i64, num_chunks: i64)
atg__chunk_cat_out :: extern proc(out__: *Tensor, out: Tensor, tensors_data: *Tensor, tensors_len: i32, dim: i64, num_chunks: i64)
atg__coalesce :: extern proc(out__: *Tensor, self: Tensor)
atg__coalesce_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg__coalesced :: extern proc(out__: *Tensor, self: Tensor, coalesced: bool)
atg__coalesced_ :: extern proc(out__: *Tensor, self: Tensor, coalesced: bool)
atg__coalesced_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, coalesced: bool)
atg__compute_linear_combination :: extern proc(out__: *Tensor, input: Tensor, coefficients: Tensor)
atg__compute_linear_combination_out :: extern proc(out__: *Tensor, out: Tensor, input: Tensor, coefficients: Tensor)
atg__conj :: extern proc(out__: *Tensor, self: Tensor)
atg__conj_copy :: extern proc(out__: *Tensor, self: Tensor)
atg__conj_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg__conj_physical :: extern proc(out__: *Tensor, self: Tensor)
atg__conj_physical_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg__conv_depthwise2d :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, kernel_size_data: *i64, kernel_size_len: i32, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32)
atg__conv_depthwise2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, kernel_size_data: *i64, kernel_size_len: i32, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32)
atg__convert_indices_from_coo_to_csr :: extern proc(out__: *Tensor, self: Tensor, size: i64, out_int32: bool)
atg__convert_indices_from_coo_to_csr_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size: i64, out_int32: bool)
atg__convert_indices_from_csr_to_coo :: extern proc(out__: *Tensor, crow_indices: Tensor, col_indices: Tensor, out_int32: bool, transpose: bool)
atg__convert_indices_from_csr_to_coo_out :: extern proc(out__: *Tensor, out: Tensor, crow_indices: Tensor, col_indices: Tensor, out_int32: bool, transpose: bool)
atg__convert_weight_to_int4pack :: extern proc(out__: *Tensor, self: Tensor, innerKTiles: i64)
atg__convert_weight_to_int4pack_for_cpu :: extern proc(out__: *Tensor, self: Tensor, innerKTiles: i64)
atg__convolution :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, transposed: bool, output_padding_data: *i64, output_padding_len: i32, groups: i64, benchmark: bool, deterministic: bool, cudnn_enabled: bool, allow_tf32: bool)
atg__convolution_deprecated :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, transposed: bool, output_padding_data: *i64, output_padding_len: i32, groups: i64, benchmark: bool, deterministic: bool, cudnn_enabled: bool)
atg__convolution_mode :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_ptr: *u8, padding_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg__convolution_out :: extern proc(out__: *Tensor, out: Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, transposed: bool, output_padding_data: *i64, output_padding_len: i32, groups: i64, benchmark: bool, deterministic: bool, cudnn_enabled: bool, allow_tf32: bool)
atg__copy_from :: extern proc(out__: *Tensor, self: Tensor, dst: Tensor, non_blocking: bool)
atg__copy_from_and_resize :: extern proc(out__: *Tensor, self: Tensor, dst: Tensor)
atg__copy_from_and_resize_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dst: Tensor)
atg__copy_from_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dst: Tensor, non_blocking: bool)
atg__cslt_compress :: extern proc(out__: *Tensor, input: Tensor)
atg__cslt_sparse_mm :: extern proc(out__: *Tensor, compressed_A: Tensor, dense_B: Tensor, bias: Tensor, alpha: Tensor, out_dtype: i32, transpose_result: bool, alg_id: i64, split_k: i64, split_k_mode: i64)
atg__cslt_sparse_mm_search :: extern fn(compressed_A: Tensor, dense_B: Tensor, bias: Tensor, alpha: Tensor, out_dtype: i32, transpose_result: bool) i64
atg__ctc_loss :: extern proc(out__: *Tensor, log_probs: Tensor, targets: Tensor, input_lengths_data: *i64, input_lengths_len: i32, target_lengths_data: *i64, target_lengths_len: i32, blank: i64, zero_infinity: bool)
atg__ctc_loss_backward :: extern proc(out__: *Tensor, grad: Tensor, log_probs: Tensor, targets: Tensor, input_lengths_data: *i64, input_lengths_len: i32, target_lengths_data: *i64, target_lengths_len: i32, neg_log_likelihood: Tensor, log_alpha: Tensor, blank: i64, zero_infinity: bool)
atg__ctc_loss_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad: Tensor, log_probs: Tensor, targets: Tensor, input_lengths_data: *i64, input_lengths_len: i32, target_lengths_data: *i64, target_lengths_len: i32, neg_log_likelihood: Tensor, log_alpha: Tensor, blank: i64, zero_infinity: bool)
atg__ctc_loss_backward_tensor :: extern proc(out__: *Tensor, grad: Tensor, log_probs: Tensor, targets: Tensor, input_lengths: Tensor, target_lengths: Tensor, neg_log_likelihood: Tensor, log_alpha: Tensor, blank: i64, zero_infinity: bool)
atg__ctc_loss_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, log_probs: Tensor, targets: Tensor, input_lengths_data: *i64, input_lengths_len: i32, target_lengths_data: *i64, target_lengths_len: i32, blank: i64, zero_infinity: bool)
atg__ctc_loss_tensor :: extern proc(out__: *Tensor, log_probs: Tensor, targets: Tensor, input_lengths: Tensor, target_lengths: Tensor, blank: i64, zero_infinity: bool)
atg__ctc_loss_tensor_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, log_probs: Tensor, targets: Tensor, input_lengths: Tensor, target_lengths: Tensor, blank: i64, zero_infinity: bool)
atg__cudnn_attention_backward :: extern proc(out__: *Tensor, grad_out: Tensor, query: Tensor, key: Tensor, value: Tensor, out: Tensor, logsumexp: Tensor, philox_seed: Tensor, philox_offset: Tensor, attn_bias: Tensor, cum_seq_q: Tensor, cum_seq_k: Tensor, max_q: i64, max_k: i64, dropout_p: f64, is_causal: bool, scale_v: f64, scale_null: u8)
atg__cudnn_ctc_loss :: extern proc(out__: *Tensor, log_probs: Tensor, targets: Tensor, input_lengths_data: *i64, input_lengths_len: i32, target_lengths_data: *i64, target_lengths_len: i32, blank: i64, deterministic: bool, zero_infinity: bool)
atg__cudnn_ctc_loss_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, log_probs: Tensor, targets: Tensor, input_lengths_data: *i64, input_lengths_len: i32, target_lengths_data: *i64, target_lengths_len: i32, blank: i64, deterministic: bool, zero_infinity: bool)
atg__cudnn_ctc_loss_tensor :: extern proc(out__: *Tensor, log_probs: Tensor, targets: Tensor, input_lengths: Tensor, target_lengths: Tensor, blank: i64, deterministic: bool, zero_infinity: bool)
atg__cudnn_init_dropout_state :: extern proc(out__: *Tensor, dropout: f64, train: bool, dropout_seed: i64, options_kind: i32, options_device: i32)
atg__cudnn_init_dropout_state_out :: extern proc(out__: *Tensor, out: Tensor, dropout: f64, train: bool, dropout_seed: i64)
atg__cudnn_rnn :: extern proc(out__: *Tensor, input: Tensor, weight_data: *Tensor, weight_len: i32, weight_stride0: i64, weight_buf: Tensor, hx: Tensor, cx: Tensor, mode: i64, hidden_size: i64, proj_size: i64, num_layers: i64, batch_first: bool, dropout: f64, train: bool, bidirectional: bool, batch_sizes_data: *i64, batch_sizes_len: i32, dropout_state: Tensor)
atg__cudnn_rnn_flatten_weight :: extern proc(out__: *Tensor, weight_arr_data: *Tensor, weight_arr_len: i32, weight_stride0: i64, input_size: i64, mode: i64, hidden_size: i64, proj_size: i64, num_layers: i64, batch_first: bool, bidirectional: bool)
atg__cudnn_rnn_flatten_weight_out :: extern proc(out__: *Tensor, out: Tensor, weight_arr_data: *Tensor, weight_arr_len: i32, weight_stride0: i64, input_size: i64, mode: i64, hidden_size: i64, proj_size: i64, num_layers: i64, batch_first: bool, bidirectional: bool)
atg__cudnn_rnn_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, out3: Tensor, out4: Tensor, input: Tensor, weight_data: *Tensor, weight_len: i32, weight_stride0: i64, weight_buf: Tensor, hx: Tensor, cx: Tensor, mode: i64, hidden_size: i64, proj_size: i64, num_layers: i64, batch_first: bool, dropout: f64, train: bool, bidirectional: bool, batch_sizes_data: *i64, batch_sizes_len: i32, dropout_state: Tensor)
atg__debug_has_internal_overlap :: extern fn(self: Tensor) i64
atg__dim_arange :: extern proc(out__: *Tensor, like: Tensor, dim: i64)
atg__dimi :: extern fn(self: Tensor) i64
atg__dimv :: extern fn(self: Tensor) i64
atg__dirichlet_grad :: extern proc(out__: *Tensor, x: Tensor, alpha: Tensor, total: Tensor)
atg__dirichlet_grad_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, alpha: Tensor, total: Tensor)
atg__dyn_quant_matmul_4bit :: extern proc(out__: *Tensor, inp: Tensor, packed_weights: Tensor, block_size: i64, in_features: i64, out_features: i64)
atg__dyn_quant_pack_4bit_weight :: extern proc(out__: *Tensor, weights: Tensor, scales_zeros: Tensor, bias: Tensor, block_size: i64, in_features: i64, out_features: i64)
atg__efficient_attention_backward :: extern proc(out__: *Tensor, grad_out_: Tensor, query: Tensor, key: Tensor, value: Tensor, bias: Tensor, out: Tensor, cu_seqlens_q: Tensor, cu_seqlens_k: Tensor, max_seqlen_q: i64, max_seqlen_k: i64, logsumexp: Tensor, dropout_p: f64, philox_seed: Tensor, philox_offset: Tensor, custom_mask_type: i64, bias_requires_grad: bool, scale_v: f64, scale_null: u8, num_splits_key_v: i64, num_splits_key_null: u8, window_size_v: i64, window_size_null: u8, shared_storage_dqdkdv: bool)
atg__efficientzerotensor :: extern proc(out__: *Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg__efficientzerotensor_out :: extern proc(out__: *Tensor, out: Tensor, size_data: *i64, size_len: i32)
atg__embedding_bag :: extern proc(out__: *Tensor, weight: Tensor, indices: Tensor, offsets: Tensor, scale_grad_by_freq: bool, mode: i64, sparse: bool, per_sample_weights: Tensor, include_last_offset: bool, padding_idx: i64)
atg__embedding_bag_backward :: extern proc(out__: *Tensor, grad: Tensor, indices: Tensor, offsets: Tensor, offset2bag: Tensor, bag_size: Tensor, maximum_indices: Tensor, num_weights: i64, scale_grad_by_freq: bool, mode: i64, sparse: bool, per_sample_weights: Tensor, padding_idx: i64)
atg__embedding_bag_dense_backward :: extern proc(out__: *Tensor, grad: Tensor, indices: Tensor, offset2bag: Tensor, bag_size: Tensor, maximum_indices: Tensor, num_weights: i64, scale_grad_by_freq: bool, mode: i64, per_sample_weights: Tensor, padding_idx: i64)
atg__embedding_bag_dense_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad: Tensor, indices: Tensor, offset2bag: Tensor, bag_size: Tensor, maximum_indices: Tensor, num_weights: i64, scale_grad_by_freq: bool, mode: i64, per_sample_weights: Tensor, padding_idx: i64)
atg__embedding_bag_forward_only :: extern proc(out__: *Tensor, weight: Tensor, indices: Tensor, offsets: Tensor, scale_grad_by_freq: bool, mode: i64, sparse: bool, per_sample_weights: Tensor, include_last_offset: bool, padding_idx: i64)
atg__embedding_bag_forward_only_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, out3: Tensor, weight: Tensor, indices: Tensor, offsets: Tensor, scale_grad_by_freq: bool, mode: i64, sparse: bool, per_sample_weights: Tensor, include_last_offset: bool, padding_idx: i64)
atg__embedding_bag_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, out3: Tensor, weight: Tensor, indices: Tensor, offsets: Tensor, scale_grad_by_freq: bool, mode: i64, sparse: bool, per_sample_weights: Tensor, include_last_offset: bool, padding_idx: i64)
atg__embedding_bag_per_sample_weights_backward :: extern proc(out__: *Tensor, grad: Tensor, weight: Tensor, indices: Tensor, offsets: Tensor, offset2bag: Tensor, mode: i64, padding_idx: i64)
atg__embedding_bag_per_sample_weights_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad: Tensor, weight: Tensor, indices: Tensor, offsets: Tensor, offset2bag: Tensor, mode: i64, padding_idx: i64)
atg__embedding_bag_sparse_backward :: extern proc(out__: *Tensor, grad: Tensor, indices: Tensor, offsets: Tensor, offset2bag: Tensor, bag_size: Tensor, num_weights: i64, scale_grad_by_freq: bool, mode: i64, per_sample_weights: Tensor, padding_idx: i64)
atg__empty_affine_quantized :: extern proc(out__: *Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32, scale: f64, zero_point: i64)
atg__empty_affine_quantized_out :: extern proc(out__: *Tensor, out: Tensor, size_data: *i64, size_len: i32, scale: f64, zero_point: i64)
atg__empty_per_channel_affine_quantized :: extern proc(out__: *Tensor, size_data: *i64, size_len: i32, scales: Tensor, zero_points: Tensor, axis: i64, options_kind: i32, options_device: i32)
atg__empty_per_channel_affine_quantized_out :: extern proc(out__: *Tensor, out: Tensor, size_data: *i64, size_len: i32, scales: Tensor, zero_points: Tensor, axis: i64)
atg__euclidean_dist :: extern proc(out__: *Tensor, x1: Tensor, x2: Tensor)
atg__euclidean_dist_out :: extern proc(out__: *Tensor, out: Tensor, x1: Tensor, x2: Tensor)
atg__fake_quantize_learnable_per_channel_affine :: extern proc(out__: *Tensor, self: Tensor, scale: Tensor, zero_point: Tensor, axis: i64, quant_min: i64, quant_max: i64, grad_factor: f64)
atg__fake_quantize_learnable_per_channel_affine_backward :: extern proc(out__: *Tensor, grad: Tensor, self: Tensor, scale: Tensor, zero_point: Tensor, axis: i64, quant_min: i64, quant_max: i64, grad_factor: f64)
atg__fake_quantize_learnable_per_channel_affine_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, scale: Tensor, zero_point: Tensor, axis: i64, quant_min: i64, quant_max: i64, grad_factor: f64)
atg__fake_quantize_learnable_per_tensor_affine :: extern proc(out__: *Tensor, self: Tensor, scale: Tensor, zero_point: Tensor, quant_min: i64, quant_max: i64, grad_factor: f64)
atg__fake_quantize_learnable_per_tensor_affine_backward :: extern proc(out__: *Tensor, grad: Tensor, self: Tensor, scale: Tensor, zero_point: Tensor, quant_min: i64, quant_max: i64, grad_factor: f64)
atg__fake_quantize_learnable_per_tensor_affine_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, scale: Tensor, zero_point: Tensor, quant_min: i64, quant_max: i64, grad_factor: f64)
atg__fake_quantize_per_tensor_affine_cachemask_tensor_qparams :: extern proc(out__: *Tensor, self: Tensor, scale: Tensor, zero_point: Tensor, fake_quant_enabled: Tensor, quant_min: i64, quant_max: i64)
atg__fake_quantize_per_tensor_affine_cachemask_tensor_qparams_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, self: Tensor, scale: Tensor, zero_point: Tensor, fake_quant_enabled: Tensor, quant_min: i64, quant_max: i64)
atg__fft_c2c :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, normalization: i64, forward: bool)
atg__fft_c2c_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, normalization: i64, forward: bool)
atg__fft_c2r :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, normalization: i64, last_dim_size: i64)
atg__fft_c2r_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, normalization: i64, last_dim_size: i64)
atg__fft_r2c :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, normalization: i64, onesided: bool)
atg__fft_r2c_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, normalization: i64, onesided: bool)
atg__fill_mem_eff_dropout_mask_ :: extern proc(out__: *Tensor, self: Tensor, dropout_p: f64, seed: i64, offset: i64)
atg__flash_attention_backward :: extern proc(out__: *Tensor, grad_out: Tensor, query: Tensor, key: Tensor, value: Tensor, out: Tensor, logsumexp: Tensor, cum_seq_q: Tensor, cum_seq_k: Tensor, max_q: i64, max_k: i64, dropout_p: f64, is_causal: bool, rng_state: Tensor, unused: Tensor, scale_v: f64, scale_null: u8, window_size_left_v: i64, window_size_left_null: u8, window_size_right_v: i64, window_size_right_null: u8)
atg__foobar :: extern proc(out__: *Tensor, self: Tensor, arg1: bool, arg2: bool, arg3: bool)
atg__foobar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, arg1: bool, arg2: bool, arg3: bool)
atg__functional_assert_async :: extern proc(out__: *Tensor, self: Tensor, assert_msg_ptr: *const u8, assert_msg_len: i32, dep_token: Tensor)
atg__functional_assert_scalar :: extern proc(out__: *Tensor, self_scalar: Scalar, assert_msg_ptr: *const u8, assert_msg_len: i32, dep_token: Tensor)
atg__functional_sym_constrain_range :: extern proc(out__: *Tensor, size: Scalar, min_v: i64, min_null: u8, max_v: i64, max_null: u8, dep_token: Tensor)
atg__functional_sym_constrain_range_for_size :: extern proc(out__: *Tensor, size: Scalar, min_v: i64, min_null: u8, max_v: i64, max_null: u8, dep_token: Tensor)
atg__fused_dropout :: extern proc(out__: *Tensor, self: Tensor, p: f64)
atg__fused_dropout_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, self: Tensor, p: f64)
atg__fused_moving_avg_obs_fq_helper :: extern proc(out__: *Tensor, self: Tensor, observer_on: Tensor, fake_quant_on: Tensor, running_min: Tensor, running_max: Tensor, scale: Tensor, zero_point: Tensor, averaging_const: f64, quant_min: i64, quant_max: i64, ch_axis: i64, per_row_fake_quant: bool, symmetric_quant: bool)
atg__fused_moving_avg_obs_fq_helper_functional :: extern proc(out__: *Tensor, self: Tensor, observer_on: Tensor, fake_quant_on: Tensor, running_min: Tensor, running_max: Tensor, scale: Tensor, zero_point: Tensor, averaging_const: f64, quant_min: i64, quant_max: i64, ch_axis: i64, per_row_fake_quant: bool, symmetric_quant: bool)
atg__fused_moving_avg_obs_fq_helper_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, self: Tensor, observer_on: Tensor, fake_quant_on: Tensor, running_min: Tensor, running_max: Tensor, scale: Tensor, zero_point: Tensor, averaging_const: f64, quant_min: i64, quant_max: i64, ch_axis: i64, per_row_fake_quant: bool, symmetric_quant: bool)
atg__fused_rms_norm :: extern proc(out__: *Tensor, input: Tensor, normalized_shape_data: *i64, normalized_shape_len: i32, weight: Tensor, eps_v: f64, eps_null: u8)
atg__fused_sdp_choice :: extern fn(query: Tensor, key: Tensor, value: Tensor, attn_mask: Tensor, dropout_p: f64, is_causal: bool, scale_v: f64, scale_null: u8, enable_gqa: bool) i64
atg__fw_primal :: extern proc(out__: *Tensor, self: Tensor, level: i64)
atg__fw_primal_copy :: extern proc(out__: *Tensor, self: Tensor, level: i64)
atg__fw_primal_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, level: i64)
atg__gather_sparse_backward :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, grad: Tensor)
atg__grid_sampler_2d_cpu_fallback :: extern proc(out__: *Tensor, input: Tensor, grid: Tensor, interpolation_mode: i64, padding_mode: i64, align_corners: bool)
atg__grid_sampler_2d_cpu_fallback_backward :: extern proc(out__: *Tensor, grad_output: Tensor, input: Tensor, grid: Tensor, interpolation_mode: i64, padding_mode: i64, align_corners: bool)
atg__grid_sampler_2d_cpu_fallback_out :: extern proc(out__: *Tensor, out: Tensor, input: Tensor, grid: Tensor, interpolation_mode: i64, padding_mode: i64, align_corners: bool)
atg__grouped_mm :: extern proc(out__: *Tensor, self: Tensor, mat2: Tensor, offs: Tensor, bias: Tensor, out_dtype: i32)
atg__has_compatible_shallow_copy_type :: extern fn(self: Tensor, from: Tensor) bool
atg__has_same_storage_numel :: extern fn(self: Tensor, other: Tensor) bool
atg__histogramdd_bin_edges :: extern fn(self: Tensor, bins_data: *i64, bins_len: i32, range_data: *f64, range_len: i32, weight: Tensor, density: bool) *Tensor
atg__histogramdd_bin_edges_out :: extern proc(out_data: *Tensor, out_len: i32, self: Tensor, bins_data: *i64, bins_len: i32, range_data: *f64, range_len: i32, weight: Tensor, density: bool)
atg__histogramdd_from_bin_cts :: extern proc(out__: *Tensor, self: Tensor, bins_data: *i64, bins_len: i32, range_data: *f64, range_len: i32, weight: Tensor, density: bool)
atg__histogramdd_from_bin_cts_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, bins_data: *i64, bins_len: i32, range_data: *f64, range_len: i32, weight: Tensor, density: bool)
atg__histogramdd_from_bin_tensors :: extern proc(out__: *Tensor, self: Tensor, bins_data: *Tensor, bins_len: i32, weight: Tensor, density: bool)
atg__histogramdd_from_bin_tensors_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, bins_data: *Tensor, bins_len: i32, weight: Tensor, density: bool)
atg__index_put_impl :: extern proc(out__: *Tensor, self: Tensor, indices_data: *Tensor, indices_len: i32, values: Tensor, accumulate: bool, unsafe: bool)
atg__index_put_impl_ :: extern proc(out__: *Tensor, self: Tensor, indices_data: *Tensor, indices_len: i32, values: Tensor, accumulate: bool, unsafe: bool)
atg__index_put_impl_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, indices_data: *Tensor, indices_len: i32, values: Tensor, accumulate: bool, unsafe: bool)
atg__indices :: extern proc(out__: *Tensor, self: Tensor)
atg__indices_copy :: extern proc(out__: *Tensor, self: Tensor)
atg__indices_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg__int_mm :: extern proc(out__: *Tensor, self: Tensor, mat2: Tensor)
atg__int_mm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mat2: Tensor)
atg__is_all_true :: extern proc(out__: *Tensor, self: Tensor)
atg__is_any_true :: extern proc(out__: *Tensor, self: Tensor)
atg__is_zerotensor :: extern fn(self: Tensor) bool
atg__lazy_clone :: extern proc(out__: *Tensor, self: Tensor)
atg__linalg_check_errors :: extern proc(info: Tensor, api_name_ptr: *const u8, api_name_len: i32, is_matrix: bool)
atg__linalg_det :: extern proc(out__: *Tensor, A: Tensor)
atg__linalg_det_result :: extern proc(out__: *Tensor, result: Tensor, LU: Tensor, pivots: Tensor, A: Tensor)
atg__linalg_eigh :: extern proc(out__: *Tensor, A: Tensor, UPLO_ptr: *u8, UPLO_len: i32, compute_v: bool)
atg__linalg_eigh_eigenvalues :: extern proc(out__: *Tensor, eigenvalues: Tensor, eigenvectors: Tensor, A: Tensor, UPLO_ptr: *u8, UPLO_len: i32, compute_v: bool)
atg__linalg_eigvals :: extern proc(out__: *Tensor, self: Tensor)
atg__linalg_slogdet :: extern proc(out__: *Tensor, A: Tensor)
atg__linalg_slogdet_sign :: extern proc(out__: *Tensor, sign: Tensor, logabsdet: Tensor, LU: Tensor, pivots: Tensor, A: Tensor)
atg__linalg_solve_ex :: extern proc(out__: *Tensor, A: Tensor, B: Tensor, left: bool, check_errors: bool)
atg__linalg_solve_ex_result :: extern proc(out__: *Tensor, result: Tensor, LU: Tensor, pivots: Tensor, info: Tensor, A: Tensor, B: Tensor, left: bool, check_errors: bool)
atg__linalg_svd :: extern proc(out__: *Tensor, A: Tensor, full_matrices: bool, compute_uv: bool, driver_ptr: *u8, driver_len: i32)
atg__linalg_svd_u :: extern proc(out__: *Tensor, U: Tensor, S: Tensor, Vh: Tensor, A: Tensor, full_matrices: bool, compute_uv: bool, driver_ptr: *u8, driver_len: i32)
atg__log_softmax :: extern proc(out__: *Tensor, self: Tensor, dim: i64, half_to_float: bool)
atg__log_softmax_backward_data :: extern proc(out__: *Tensor, grad_output: Tensor, output: Tensor, dim: i64, input_dtype: i32)
atg__log_softmax_backward_data_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, output: Tensor, dim: i64, input_dtype: i32)
atg__log_softmax_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, half_to_float: bool)
atg__logcumsumexp :: extern proc(out__: *Tensor, self: Tensor, dim: i64)
atg__logcumsumexp_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64)
atg__lstm_mps :: extern proc(out__: *Tensor, input: Tensor, hx_data: *Tensor, hx_len: i32, params_data: *Tensor, params_len: i32, has_biases: bool, num_layers: i64, dropout: f64, train: bool, bidirectional: bool, batch_first: bool)
atg__lstm_mps_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, out3: Tensor, out4: Tensor, out5: Tensor, input: Tensor, hx_data: *Tensor, hx_len: i32, params_data: *Tensor, params_len: i32, has_biases: bool, num_layers: i64, dropout: f64, train: bool, bidirectional: bool, batch_first: bool)
atg__lu_with_info :: extern proc(out__: *Tensor, self: Tensor, pivot: bool, check_errors: bool)
atg__make_dep_token :: extern proc(out__: *Tensor, options_kind: i32, options_device: i32)
atg__make_dual :: extern proc(out__: *Tensor, primal: Tensor, tangent: Tensor, level: i64)
atg__make_dual_copy :: extern proc(out__: *Tensor, primal: Tensor, tangent: Tensor, level: i64)
atg__make_dual_copy_out :: extern proc(out__: *Tensor, out: Tensor, primal: Tensor, tangent: Tensor, level: i64)
atg__make_per_channel_quantized_tensor :: extern proc(out__: *Tensor, self: Tensor, scale: Tensor, zero_point: Tensor, axis: i64)
atg__make_per_channel_quantized_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, scale: Tensor, zero_point: Tensor, axis: i64)
atg__make_per_tensor_quantized_tensor :: extern proc(out__: *Tensor, self: Tensor, scale: f64, zero_point: i64)
atg__make_per_tensor_quantized_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, scale: f64, zero_point: i64)
atg__masked_scale :: extern proc(out__: *Tensor, self: Tensor, mask: Tensor, scale: f64)
atg__masked_scale_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mask: Tensor, scale: f64)
atg__masked_softmax :: extern proc(out__: *Tensor, self: Tensor, mask: Tensor, dim_v: i64, dim_null: u8, mask_type_v: i64, mask_type_null: u8)
atg__masked_softmax_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output: Tensor, mask: Tensor, dim_v: i64, dim_null: u8)
atg__masked_softmax_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, output: Tensor, mask: Tensor, dim_v: i64, dim_null: u8)
atg__masked_softmax_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mask: Tensor, dim_v: i64, dim_null: u8, mask_type_v: i64, mask_type_null: u8)
atg__mixed_dtypes_linear :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, scale: Tensor, bias: Tensor, activation_ptr: *u8, activation_len: i32)
atg__mkldnn_reshape :: extern proc(out__: *Tensor, self: Tensor, shape_data: *i64, shape_len: i32)
atg__mkldnn_reshape_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, shape_data: *i64, shape_len: i32)
atg__mkldnn_transpose :: extern proc(out__: *Tensor, self: Tensor, dim0: i64, dim1: i64)
atg__mkldnn_transpose_ :: extern proc(out__: *Tensor, self: Tensor, dim0: i64, dim1: i64)
atg__mkldnn_transpose_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim0: i64, dim1: i64)
atg__mps_convolution :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, bias: Tensor, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg__mps_convolution_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, bias: Tensor, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg__mps_convolution_transpose :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, padding_data: *i64, padding_len: i32, output_padding_data: *i64, output_padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg__mps_convolution_transpose_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, padding_data: *i64, padding_len: i32, output_padding_data: *i64, output_padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg__native_batch_norm_legit :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, momentum: f64, eps: f64)
atg__native_batch_norm_legit_functional :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, momentum: f64, eps: f64)
atg__native_batch_norm_legit_no_stats :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, training: bool, momentum: f64, eps: f64)
atg__native_batch_norm_legit_no_stats_out :: extern proc(out__: *Tensor, out: Tensor, save_mean: Tensor, save_invstd: Tensor, input: Tensor, weight: Tensor, bias: Tensor, training: bool, momentum: f64, eps: f64)
atg__native_batch_norm_legit_no_training :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, momentum: f64, eps: f64)
atg__native_batch_norm_legit_no_training_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, momentum: f64, eps: f64)
atg__native_batch_norm_legit_out :: extern proc(out__: *Tensor, out: Tensor, save_mean: Tensor, save_invstd: Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, momentum: f64, eps: f64)
atg__native_multi_head_attention :: extern proc(out__: *Tensor, query: Tensor, key: Tensor, value: Tensor, embed_dim: i64, num_head: i64, qkv_weight: Tensor, qkv_bias: Tensor, proj_weight: Tensor, proj_bias: Tensor, mask: Tensor, need_weights: bool, average_attn_weights: bool, mask_type_v: i64, mask_type_null: u8)
atg__native_multi_head_attention_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, query: Tensor, key: Tensor, value: Tensor, embed_dim: i64, num_head: i64, qkv_weight: Tensor, qkv_bias: Tensor, proj_weight: Tensor, proj_bias: Tensor, mask: Tensor, need_weights: bool, average_attn_weights: bool, mask_type_v: i64, mask_type_null: u8)
atg__neg_view :: extern proc(out__: *Tensor, self: Tensor)
atg__neg_view_copy :: extern proc(out__: *Tensor, self: Tensor)
atg__neg_view_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg__nested_compute_contiguous_strides_offsets :: extern proc(out__: *Tensor, nested_size: Tensor)
atg__nested_from_padded :: extern proc(out__: *Tensor, padded: Tensor, cpu_nested_shape_example: Tensor, fuse_transform_0213: bool)
atg__nested_from_padded_and_nested_example :: extern proc(out__: *Tensor, padded: Tensor, nt_example: Tensor)
atg__nested_from_padded_and_nested_example_out :: extern proc(out__: *Tensor, out: Tensor, padded: Tensor, nt_example: Tensor)
atg__nested_from_padded_out :: extern proc(out__: *Tensor, out: Tensor, padded: Tensor, cpu_nested_shape_example: Tensor, fuse_transform_0213: bool)
atg__nested_from_padded_tensor :: extern proc(out__: *Tensor, padded: Tensor, offsets: Tensor, dummy: Tensor, ragged_idx: i64, min_seqlen: Tensor, max_seqlen: Tensor, sum_S_v: i64, sum_S_null: u8)
atg__nested_get_jagged_dummy :: extern proc(out__: *Tensor, r#any: Tensor)
atg__nested_get_lengths :: extern proc(out__: *Tensor, self: Tensor)
atg__nested_get_max_seqlen :: extern proc(out__: *Tensor, self: Tensor)
atg__nested_get_min_seqlen :: extern proc(out__: *Tensor, self: Tensor)
atg__nested_get_offsets :: extern proc(out__: *Tensor, self: Tensor)
atg__nested_get_ragged_idx :: extern fn(self: Tensor) i64
atg__nested_get_values :: extern proc(out__: *Tensor, self: Tensor)
atg__nested_get_values_copy :: extern proc(out__: *Tensor, self: Tensor)
atg__nested_get_values_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg__nested_select_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, dim: i64, index: i64)
atg__nested_sum_backward :: extern proc(out__: *Tensor, grad: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg__nested_view_from_buffer :: extern proc(out__: *Tensor, self: Tensor, nested_size: Tensor, nested_strides: Tensor, offsets: Tensor)
atg__nested_view_from_buffer_copy :: extern proc(out__: *Tensor, self: Tensor, nested_size: Tensor, nested_strides: Tensor, offsets: Tensor)
atg__nested_view_from_buffer_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, nested_size: Tensor, nested_strides: Tensor, offsets: Tensor)
atg__nested_view_from_jagged :: extern proc(out__: *Tensor, self: Tensor, offsets: Tensor, dummy: Tensor, lengths: Tensor, ragged_idx: i64, min_seqlen: Tensor, max_seqlen: Tensor)
atg__nested_view_from_jagged_copy :: extern proc(out__: *Tensor, self: Tensor, offsets: Tensor, dummy: Tensor, lengths: Tensor, ragged_idx: i64, min_seqlen: Tensor, max_seqlen: Tensor)
atg__nested_view_from_jagged_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, offsets: Tensor, dummy: Tensor, lengths: Tensor, ragged_idx: i64, min_seqlen: Tensor, max_seqlen: Tensor)
atg__new_zeros_with_same_feature_meta :: extern proc(out__: *Tensor, self: Tensor, other: Tensor, self_num_batch_dims: i64)
atg__new_zeros_with_same_feature_meta_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor, self_num_batch_dims: i64)
atg__nnpack_available :: extern fn() bool
atg__nnpack_spatial_convolution :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32)
atg__nnpack_spatial_convolution_out :: extern proc(out__: *Tensor, out: Tensor, input: Tensor, weight: Tensor, bias: Tensor, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32)
atg__nnz :: extern fn(self: Tensor) i64
atg__pack_padded_sequence :: extern proc(out__: *Tensor, input: Tensor, lengths: Tensor, batch_first: bool)
atg__pack_padded_sequence_backward :: extern proc(out__: *Tensor, grad: Tensor, input_size_data: *i64, input_size_len: i32, batch_sizes: Tensor, batch_first: bool)
atg__pack_padded_sequence_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, input: Tensor, lengths: Tensor, batch_first: bool)
atg__pad_circular :: extern proc(out__: *Tensor, self: Tensor, pad_data: *i64, pad_len: i32)
atg__pad_enum :: extern proc(out__: *Tensor, self: Tensor, pad_data: *i64, pad_len: i32, mode: i64, value_v: f64, value_null: u8)
atg__pad_packed_sequence :: extern proc(out__: *Tensor, data: Tensor, batch_sizes: Tensor, batch_first: bool, padding_value: Scalar, total_length: i64)
atg__pdist_backward :: extern proc(out__: *Tensor, grad: Tensor, self: Tensor, p: f64, pdist: Tensor)
atg__pdist_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad: Tensor, self: Tensor, p: f64, pdist: Tensor)
atg__pin_memory :: extern proc(out__: *Tensor, self: Tensor, device: i32)
atg__pin_memory_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, device: i32)
atg__prelu_kernel :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor)
atg__prelu_kernel_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, weight: Tensor)
atg__print :: extern proc(s_ptr: *u8, s_len: i32)
atg__propagate_xla_data :: extern proc(input: Tensor, output: Tensor)
atg__remove_batch_dim :: extern proc(out__: *Tensor, self: Tensor, level: i64, batch_size: i64, out_dim: i64)
atg__reshape_alias :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, stride_data: *i64, stride_len: i32)
atg__reshape_alias_copy :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, stride_data: *i64, stride_len: i32)
atg__reshape_alias_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size_data: *i64, size_len: i32, stride_data: *i64, stride_len: i32)
atg__reshape_copy :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg__reshape_from_tensor :: extern proc(out__: *Tensor, self: Tensor, shape: Tensor)
atg__resize_output :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, device: i32)
atg__resize_output_ :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, device: i32)
atg__resize_output_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size_data: *i64, size_len: i32, device: i32)
atg__rowwise_prune :: extern proc(out__: *Tensor, weight: Tensor, mask: Tensor, compressed_indices_dtype: i32)
atg__safe_softmax :: extern proc(out__: *Tensor, self: Tensor, dim: i64, dtype: i32)
atg__sample_dirichlet :: extern proc(out__: *Tensor, self: Tensor)
atg__sample_dirichlet_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg__saturate_weight_to_fp16 :: extern proc(out__: *Tensor, weight: Tensor)
atg__scaled_dot_product_attention_math :: extern proc(out__: *Tensor, query: Tensor, key: Tensor, value: Tensor, attn_mask: Tensor, dropout_p: f64, is_causal: bool, dropout_mask: Tensor, scale_v: f64, scale_null: u8, enable_gqa: bool)
atg__scaled_dot_product_attention_math_for_mps :: extern proc(out__: *Tensor, query: Tensor, key: Tensor, value: Tensor, attn_mask: Tensor, dropout_p: f64, is_causal: bool, dropout_mask: Tensor, scale_v: f64, scale_null: u8)
atg__scaled_dot_product_cudnn_attention_backward :: extern proc(out__: *Tensor, grad_out: Tensor, query: Tensor, key: Tensor, value: Tensor, out: Tensor, logsumexp: Tensor, philox_seed: Tensor, philox_offset: Tensor, attn_bias: Tensor, cum_seq_q: Tensor, cum_seq_k: Tensor, max_q: i64, max_k: i64, dropout_p: f64, is_causal: bool, scale_v: f64, scale_null: u8)
atg__scaled_dot_product_efficient_attention :: extern proc(out__: *Tensor, query: Tensor, key: Tensor, value: Tensor, attn_bias: Tensor, compute_log_sumexp: bool, dropout_p: f64, is_causal: bool, scale_v: f64, scale_null: u8)
atg__scaled_dot_product_flash_attention_backward :: extern proc(out__: *Tensor, grad_out: Tensor, query: Tensor, key: Tensor, value: Tensor, out: Tensor, logsumexp: Tensor, cum_seq_q: Tensor, cum_seq_k: Tensor, max_q: i64, max_k: i64, dropout_p: f64, is_causal: bool, philox_seed: Tensor, philox_offset: Tensor, scale_v: f64, scale_null: u8)
atg__scaled_dot_product_flash_attention_for_cpu :: extern proc(out__: *Tensor, query: Tensor, key: Tensor, value: Tensor, dropout_p: f64, is_causal: bool, attn_mask: Tensor, scale_v: f64, scale_null: u8)
atg__scaled_dot_product_flash_attention_for_cpu_backward :: extern proc(out__: *Tensor, grad_out: Tensor, query: Tensor, key: Tensor, value: Tensor, out: Tensor, logsumexp: Tensor, dropout_p: f64, is_causal: bool, attn_mask: Tensor, scale_v: f64, scale_null: u8)
atg__scaled_grouped_mm :: extern proc(out__: *Tensor, self: Tensor, mat2: Tensor, scale_a: Tensor, scale_b: Tensor, offs: Tensor, bias: Tensor, scale_result: Tensor, out_dtype: i32, use_fast_accum: bool)
atg__scaled_mm :: extern proc(out__: *Tensor, self: Tensor, mat2: Tensor, scale_a: Tensor, scale_b: Tensor, bias: Tensor, scale_result: Tensor, out_dtype: i32, use_fast_accum: bool)
atg__scaled_mm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mat2: Tensor, scale_a: Tensor, scale_b: Tensor, bias: Tensor, scale_result: Tensor, out_dtype: i32, use_fast_accum: bool)
atg__scatter_reduce :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, src: Tensor, reduce_ptr: *u8, reduce_len: i32, include_self: bool)
atg__scatter_reduce_ :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, src: Tensor, reduce_ptr: *u8, reduce_len: i32, include_self: bool)
atg__scatter_reduce_two_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, index: Tensor, src: Tensor, reduce_ptr: *u8, reduce_len: i32, include_self: bool)
atg__segment_reduce_backward :: extern proc(out__: *Tensor, grad: Tensor, output: Tensor, data: Tensor, reduce_ptr: *u8, reduce_len: i32, lengths: Tensor, offsets: Tensor, axis: i64, initial: Scalar)
atg__segment_reduce_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad: Tensor, output: Tensor, data: Tensor, reduce_ptr: *u8, reduce_len: i32, lengths: Tensor, offsets: Tensor, axis: i64, initial: Scalar)
atg__shape_as_tensor :: extern proc(out__: *Tensor, self: Tensor)
atg__slow_conv2d_backward :: extern proc(out__: *Tensor, grad_input: Tensor, grad_weight: Tensor, grad_bias: Tensor, grad_output: Tensor, self: Tensor, weight: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32)
atg__sobol_engine_draw :: extern proc(out__: *Tensor, quasi: Tensor, n: i64, sobolstate: Tensor, dimension: i64, num_generated: i64, dtype: i32)
atg__sobol_engine_ff_ :: extern proc(out__: *Tensor, self: Tensor, n: i64, sobolstate: Tensor, dimension: i64, num_generated: i64)
atg__sobol_engine_initialize_state_ :: extern proc(out__: *Tensor, self: Tensor, dimension: i64)
atg__sobol_engine_scramble_ :: extern proc(out__: *Tensor, self: Tensor, ltm: Tensor, dimension: i64)
atg__softmax :: extern proc(out__: *Tensor, self: Tensor, dim: i64, half_to_float: bool)
atg__softmax_backward_data :: extern proc(out__: *Tensor, grad_output: Tensor, output: Tensor, dim: i64, input_dtype: i32)
atg__softmax_backward_data_out :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, output: Tensor, dim: i64, input_dtype: i32)
atg__softmax_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, half_to_float: bool)
atg__sparse_addmm :: extern proc(out__: *Tensor, self: Tensor, mat1: Tensor, mat2: Tensor)
atg__sparse_addmm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mat1: Tensor, mat2: Tensor)
atg__sparse_broadcast_to :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg__sparse_broadcast_to_copy :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg__sparse_broadcast_to_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg__sparse_bsc_tensor_unsafe :: extern proc(out__: *Tensor, ccol_indices: Tensor, row_indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg__sparse_bsr_tensor_unsafe :: extern proc(out__: *Tensor, crow_indices: Tensor, col_indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg__sparse_compressed_tensor_unsafe :: extern proc(out__: *Tensor, compressed_indices: Tensor, plain_indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg__sparse_compressed_tensor_with_dims :: extern proc(out__: *Tensor, nnz: i64, dense_dim: i64, size_data: *i64, size_len: i32, blocksize_data: *i64, blocksize_len: i32, index_dtype: i32, options_kind: i32, options_device: i32)
atg__sparse_coo_tensor_unsafe :: extern proc(out__: *Tensor, indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32, is_coalesced: bool)
atg__sparse_coo_tensor_with_dims :: extern proc(out__: *Tensor, sparse_dim: i64, dense_dim: i64, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg__sparse_coo_tensor_with_dims_and_tensors :: extern proc(out__: *Tensor, sparse_dim: i64, dense_dim: i64, size_data: *i64, size_len: i32, indices: Tensor, values: Tensor, options_kind: i32, options_device: i32, is_coalesced: bool)
atg__sparse_coo_tensor_with_dims_and_tensors_out :: extern proc(out__: *Tensor, out: Tensor, sparse_dim: i64, dense_dim: i64, size_data: *i64, size_len: i32, indices: Tensor, values: Tensor, is_coalesced: bool)
atg__sparse_coo_tensor_with_dims_out :: extern proc(out__: *Tensor, out: Tensor, sparse_dim: i64, dense_dim: i64, size_data: *i64, size_len: i32)
atg__sparse_csc_tensor_unsafe :: extern proc(out__: *Tensor, ccol_indices: Tensor, row_indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg__sparse_csr_prod :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg__sparse_csr_prod_dim_dtype_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg__sparse_csr_sum :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg__sparse_csr_sum_dim_dtype_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg__sparse_csr_tensor_unsafe :: extern proc(out__: *Tensor, crow_indices: Tensor, col_indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg__sparse_log_softmax :: extern proc(out__: *Tensor, self: Tensor, dim: i64, half_to_float: bool)
atg__sparse_log_softmax_backward_data :: extern proc(out__: *Tensor, grad_output: Tensor, output: Tensor, dim: i64, self: Tensor)
atg__sparse_log_softmax_backward_data_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, output: Tensor, dim: i64, self: Tensor)
atg__sparse_log_softmax_int :: extern proc(out__: *Tensor, self: Tensor, dim: i64, dtype: i32)
atg__sparse_log_softmax_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, half_to_float: bool)
atg__sparse_mask_projection :: extern proc(out__: *Tensor, self: Tensor, mask: Tensor, accumulate_matches: bool)
atg__sparse_mask_projection_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mask: Tensor, accumulate_matches: bool)
atg__sparse_mm :: extern proc(out__: *Tensor, sparse: Tensor, dense: Tensor)
atg__sparse_mm_reduce :: extern proc(out__: *Tensor, sparse: Tensor, dense: Tensor, reduce_ptr: *u8, reduce_len: i32)
atg__sparse_mm_reduce_impl :: extern proc(out__: *Tensor, self: Tensor, other: Tensor, reduce_ptr: *u8, reduce_len: i32)
atg__sparse_semi_structured_apply :: extern proc(out__: *Tensor, input: Tensor, thread_masks: Tensor)
atg__sparse_semi_structured_apply_dense :: extern proc(out__: *Tensor, input: Tensor, thread_masks: Tensor)
atg__sparse_semi_structured_linear :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, meta: Tensor, bias: Tensor, activation_ptr: *u8, activation_len: i32, out_dtype: i32)
atg__sparse_semi_structured_mm :: extern proc(out__: *Tensor, mat1: Tensor, mat1_meta: Tensor, mat2: Tensor, out_dtype: i32)
atg__sparse_semi_structured_tile :: extern proc(out__: *Tensor, input: Tensor, algorithm_ptr: *u8, algorithm_len: i32, use_cutlass: bool)
atg__sparse_softmax :: extern proc(out__: *Tensor, self: Tensor, dim: i64, half_to_float: bool)
atg__sparse_softmax_backward_data :: extern proc(out__: *Tensor, grad_output: Tensor, output: Tensor, dim: i64, self: Tensor)
atg__sparse_softmax_backward_data_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, output: Tensor, dim: i64, self: Tensor)
atg__sparse_softmax_int :: extern proc(out__: *Tensor, self: Tensor, dim: i64, dtype: i32)
atg__sparse_softmax_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, half_to_float: bool)
atg__sparse_sparse_matmul :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg__sparse_sparse_matmul_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg__sparse_sum :: extern proc(out__: *Tensor, self: Tensor)
atg__sparse_sum_backward :: extern proc(out__: *Tensor, grad: Tensor, self: Tensor, dim_data: *i64, dim_len: i32)
atg__sparse_sum_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad: Tensor, self: Tensor, dim_data: *i64, dim_len: i32)
atg__sparse_sum_dim :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32)
atg__sparse_sum_dim_dtype :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, dtype: i32)
atg__sparse_sum_dim_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32)
atg__sparse_sum_dtype :: extern proc(out__: *Tensor, self: Tensor, dtype: i32)
atg__spdiags :: extern proc(out__: *Tensor, diagonals: Tensor, offsets: Tensor, shape_data: *i64, shape_len: i32, layout: i8)
atg__spdiags_out :: extern proc(out__: *Tensor, out: Tensor, diagonals: Tensor, offsets: Tensor, shape_data: *i64, shape_len: i32, layout: i8)
atg__spsolve :: extern proc(out__: *Tensor, A: Tensor, B: Tensor, left: bool)
atg__stack :: extern proc(out__: *Tensor, tensors_data: *Tensor, tensors_len: i32, dim: i64)
atg__stack_out :: extern proc(out__: *Tensor, out: Tensor, tensors_data: *Tensor, tensors_len: i32, dim: i64)
atg__standard_gamma :: extern proc(out__: *Tensor, self: Tensor)
atg__standard_gamma_grad :: extern proc(out__: *Tensor, self: Tensor, output: Tensor)
atg__standard_gamma_grad_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output: Tensor)
atg__standard_gamma_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg__test_ambiguous_defaults :: extern proc(out__: *Tensor, dummy: Tensor, a: i64, b: i64)
atg__test_ambiguous_defaults_b :: extern proc(out__: *Tensor, dummy: Tensor, a: i64, b_ptr: *u8, b_len: i32)
atg__test_autograd_multiple_dispatch :: extern proc(out__: *Tensor, self: Tensor)
atg__test_autograd_multiple_dispatch_fullcoverage_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg__test_autograd_multiple_dispatch_ntonly :: extern proc(out__: *Tensor, self: Tensor, b: bool)
atg__test_autograd_multiple_dispatch_view :: extern proc(out__: *Tensor, self: Tensor)
atg__test_autograd_multiple_dispatch_view_copy :: extern proc(out__: *Tensor, self: Tensor)
atg__test_autograd_multiple_dispatch_view_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg__test_check_tensor :: extern proc(out__: *Tensor, self: Tensor)
atg__test_functorch_fallback :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg__test_functorch_fallback_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg__test_optional_filled_intlist :: extern proc(out__: *Tensor, values: Tensor, addends_data: *i64, addends_len: i32)
atg__test_optional_filled_intlist_out :: extern proc(out__: *Tensor, out: Tensor, values: Tensor, addends_data: *i64, addends_len: i32)
atg__test_optional_floatlist :: extern proc(out__: *Tensor, values: Tensor, addends_data: *f64, addends_len: i32)
atg__test_optional_floatlist_out :: extern proc(out__: *Tensor, out: Tensor, values: Tensor, addends_data: *f64, addends_len: i32)
atg__test_optional_intlist :: extern proc(out__: *Tensor, values: Tensor, addends_data: *i64, addends_len: i32)
atg__test_optional_intlist_out :: extern proc(out__: *Tensor, out: Tensor, values: Tensor, addends_data: *i64, addends_len: i32)
atg__test_parallel_materialize :: extern proc(out__: *Tensor, self: Tensor, num_parallel: i64, skip_first: bool)
atg__test_serialization_subcmul :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg__test_string_default :: extern proc(out__: *Tensor, dummy: Tensor, a_ptr: *u8, a_len: i32, b_ptr: *u8, b_len: i32)
atg__test_warn_in_autograd :: extern proc(out__: *Tensor, self: Tensor)
atg__test_warn_in_autograd_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg__to_copy :: extern proc(out__: *Tensor, self: Tensor, options_kind: i32, options_device: i32, non_blocking: bool)
atg__to_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, non_blocking: bool)
atg__to_cpu :: extern fn(tensors_data: *Tensor, tensors_len: i32) *Tensor
atg__to_dense :: extern proc(out__: *Tensor, self: Tensor, dtype: i32, masked_grad: bool)
atg__to_dense_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dtype: i32, masked_grad: bool)
atg__to_sparse :: extern proc(out__: *Tensor, self: Tensor, layout: i8, blocksize_data: *i64, blocksize_len: i32, dense_dim_v: i64, dense_dim_null: u8)
atg__to_sparse_bsc :: extern proc(out__: *Tensor, self: Tensor, blocksize_data: *i64, blocksize_len: i32, dense_dim_v: i64, dense_dim_null: u8)
atg__to_sparse_bsc_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, blocksize_data: *i64, blocksize_len: i32, dense_dim_v: i64, dense_dim_null: u8)
atg__to_sparse_bsr :: extern proc(out__: *Tensor, self: Tensor, blocksize_data: *i64, blocksize_len: i32, dense_dim_v: i64, dense_dim_null: u8)
atg__to_sparse_bsr_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, blocksize_data: *i64, blocksize_len: i32, dense_dim_v: i64, dense_dim_null: u8)
atg__to_sparse_csc :: extern proc(out__: *Tensor, self: Tensor, dense_dim_v: i64, dense_dim_null: u8)
atg__to_sparse_csc_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dense_dim_v: i64, dense_dim_null: u8)
atg__to_sparse_csr :: extern proc(out__: *Tensor, self: Tensor, dense_dim_v: i64, dense_dim_null: u8)
atg__to_sparse_csr_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dense_dim_v: i64, dense_dim_null: u8)
atg__to_sparse_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, layout: i8, blocksize_data: *i64, blocksize_len: i32, dense_dim_v: i64, dense_dim_null: u8)
atg__to_sparse_semi_structured :: extern proc(out__: *Tensor, dense: Tensor)
atg__to_sparse_sparse_dim :: extern proc(out__: *Tensor, self: Tensor, sparse_dim: i64)
atg__to_sparse_sparse_dim_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, sparse_dim: i64)
atg__transform_bias_rescale_qkv :: extern proc(out__: *Tensor, qkv: Tensor, qkv_bias: Tensor, num_heads: i64)
atg__transform_bias_rescale_qkv_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, qkv: Tensor, qkv_bias: Tensor, num_heads: i64)
atg__transformer_encoder_layer_fwd :: extern proc(out__: *Tensor, src: Tensor, embed_dim: i64, num_heads: i64, qkv_weight: Tensor, qkv_bias: Tensor, proj_weight: Tensor, proj_bias: Tensor, use_gelu: bool, norm_first: bool, eps: f64, norm_weight_1: Tensor, norm_bias_1: Tensor, norm_weight_2: Tensor, norm_bias_2: Tensor, ffn_weight_1: Tensor, ffn_bias_1: Tensor, ffn_weight_2: Tensor, ffn_bias_2: Tensor, mask: Tensor, mask_type_v: i64, mask_type_null: u8)
atg__transformer_encoder_layer_fwd_out :: extern proc(out__: *Tensor, out: Tensor, src: Tensor, embed_dim: i64, num_heads: i64, qkv_weight: Tensor, qkv_bias: Tensor, proj_weight: Tensor, proj_bias: Tensor, use_gelu: bool, norm_first: bool, eps: f64, norm_weight_1: Tensor, norm_bias_1: Tensor, norm_weight_2: Tensor, norm_bias_2: Tensor, ffn_weight_1: Tensor, ffn_bias_1: Tensor, ffn_weight_2: Tensor, ffn_bias_2: Tensor, mask: Tensor, mask_type_v: i64, mask_type_null: u8)
atg__trilinear :: extern proc(out__: *Tensor, i1: Tensor, i2: Tensor, i3: Tensor, expand1_data: *i64, expand1_len: i32, expand2_data: *i64, expand2_len: i32, expand3_data: *i64, expand3_len: i32, sumdim_data: *i64, sumdim_len: i32, unroll_dim: i64)
atg__trilinear_out :: extern proc(out__: *Tensor, out: Tensor, i1: Tensor, i2: Tensor, i3: Tensor, expand1_data: *i64, expand1_len: i32, expand2_data: *i64, expand2_len: i32, expand3_data: *i64, expand3_len: i32, sumdim_data: *i64, sumdim_len: i32, unroll_dim: i64)
atg__triton_multi_head_attention :: extern proc(out__: *Tensor, query: Tensor, key: Tensor, value: Tensor, embed_dim: i64, num_head: i64, qkv_weight: Tensor, qkv_bias: Tensor, proj_weight: Tensor, proj_bias: Tensor, mask: Tensor)
atg__triton_multi_head_attention_out :: extern proc(out__: *Tensor, out: Tensor, query: Tensor, key: Tensor, value: Tensor, embed_dim: i64, num_head: i64, qkv_weight: Tensor, qkv_bias: Tensor, proj_weight: Tensor, proj_bias: Tensor, mask: Tensor)
atg__triton_scaled_dot_attention :: extern proc(out__: *Tensor, q: Tensor, k: Tensor, v: Tensor, dropout_p: f64)
atg__triton_scaled_dot_attention_out :: extern proc(out__: *Tensor, out: Tensor, q: Tensor, k: Tensor, v: Tensor, dropout_p: f64)
atg__unique :: extern proc(out__: *Tensor, self: Tensor, sorted: bool, return_inverse: bool)
atg__unique2 :: extern proc(out__: *Tensor, self: Tensor, sorted: bool, return_inverse: bool, return_counts: bool)
atg__unique2_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, self: Tensor, sorted: bool, return_inverse: bool, return_counts: bool)
atg__unique_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, self: Tensor, sorted: bool, return_inverse: bool)
atg__unpack_dual :: extern proc(out__: *Tensor, dual: Tensor, level: i64)
atg__unsafe_index :: extern proc(out__: *Tensor, self: Tensor, indices_data: *Tensor, indices_len: i32)
atg__unsafe_index_put :: extern proc(out__: *Tensor, self: Tensor, indices_data: *Tensor, indices_len: i32, values: Tensor, accumulate: bool)
atg__unsafe_masked_index :: extern proc(out__: *Tensor, self: Tensor, mask: Tensor, indices_data: *Tensor, indices_len: i32, fill: Scalar)
atg__unsafe_masked_index_put_accumulate :: extern proc(out__: *Tensor, self: Tensor, mask: Tensor, indices_data: *Tensor, indices_len: i32, values: Tensor)
atg__unsafe_view :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg__unsafe_view_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg__upsample_bicubic2d_aa :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg__upsample_bicubic2d_aa_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, align_corners: bool, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg__upsample_bicubic2d_aa_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, align_corners: bool, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg__upsample_bicubic2d_aa_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg__upsample_bicubic2d_aa_vec :: extern proc(out__: *Tensor, input: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scale_factors_data: *f64, scale_factors_len: i32)
atg__upsample_bilinear2d_aa :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg__upsample_bilinear2d_aa_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, align_corners: bool, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg__upsample_bilinear2d_aa_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, align_corners: bool, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg__upsample_bilinear2d_aa_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg__upsample_bilinear2d_aa_vec :: extern proc(out__: *Tensor, input: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scale_factors_data: *f64, scale_factors_len: i32)
atg__upsample_nearest_exact1d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, scales_v: f64, scales_null: u8)
atg__upsample_nearest_exact1d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, scales_v: f64, scales_null: u8)
atg__upsample_nearest_exact1d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, scales_v: f64, scales_null: u8)
atg__upsample_nearest_exact1d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, scales_v: f64, scales_null: u8)
atg__upsample_nearest_exact1d_vec :: extern proc(out__: *Tensor, input: Tensor, output_size_data: *i64, output_size_len: i32, scale_factors_data: *f64, scale_factors_len: i32)
atg__upsample_nearest_exact2d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg__upsample_nearest_exact2d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg__upsample_nearest_exact2d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg__upsample_nearest_exact2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg__upsample_nearest_exact2d_vec :: extern proc(out__: *Tensor, input: Tensor, output_size_data: *i64, output_size_len: i32, scale_factors_data: *f64, scale_factors_len: i32)
atg__upsample_nearest_exact3d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, scales_d_v: f64, scales_d_null: u8, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg__upsample_nearest_exact3d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, scales_d_v: f64, scales_d_null: u8, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg__upsample_nearest_exact3d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, scales_d_v: f64, scales_d_null: u8, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg__upsample_nearest_exact3d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, scales_d_v: f64, scales_d_null: u8, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg__upsample_nearest_exact3d_vec :: extern proc(out__: *Tensor, input: Tensor, output_size_data: *i64, output_size_len: i32, scale_factors_data: *f64, scale_factors_len: i32)
atg__use_cudnn_ctc_loss :: extern fn(log_probs: Tensor, targets: Tensor, input_lengths_data: *i64, input_lengths_len: i32, target_lengths_data: *i64, target_lengths_len: i32, blank: i64) bool
atg__use_cudnn_ctc_loss_tensor :: extern fn(log_probs: Tensor, targets: Tensor, input_lengths: Tensor, target_lengths: Tensor, blank: i64) bool
atg__use_cudnn_rnn_flatten_weight :: extern fn() bool
atg__validate_compressed_sparse_indices :: extern proc(is_crow: bool, compressed_idx: Tensor, plain_idx: Tensor, cdim: i64, dim: i64, nnz: i64)
atg__validate_sparse_bsc_tensor_args :: extern proc(ccol_indices: Tensor, row_indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, check_pinning: bool)
atg__validate_sparse_bsr_tensor_args :: extern proc(crow_indices: Tensor, col_indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, check_pinning: bool)
atg__validate_sparse_compressed_tensor_args :: extern proc(compressed_indices: Tensor, plain_indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, layout: i8, check_pinning: bool)
atg__validate_sparse_csc_tensor_args :: extern proc(ccol_indices: Tensor, row_indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, check_pinning: bool)
atg__validate_sparse_csr_tensor_args :: extern proc(crow_indices: Tensor, col_indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, check_pinning: bool)
atg__values :: extern proc(out__: *Tensor, self: Tensor)
atg__values_copy :: extern proc(out__: *Tensor, self: Tensor)
atg__values_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg__version :: extern fn(self: Tensor) i64
atg__weight_int4pack_mm :: extern proc(out__: *Tensor, self: Tensor, mat2: Tensor, qGroupSize: i64, qScaleAndZeros: Tensor)
atg__weight_int4pack_mm_for_cpu :: extern proc(out__: *Tensor, self: Tensor, mat2: Tensor, qGroupSize: i64, qScaleAndZeros: Tensor)
atg__weight_int4pack_mm_with_scales_and_zeros :: extern proc(out__: *Tensor, self: Tensor, mat2: Tensor, qGroupSize: i64, qScale: Tensor, qZeros: Tensor)
atg__weight_int8pack_mm :: extern proc(out__: *Tensor, self: Tensor, mat2: Tensor, scales: Tensor)
atg__weight_norm :: extern proc(out__: *Tensor, v: Tensor, g: Tensor, dim: i64)
atg__weight_norm_differentiable_backward :: extern proc(out__: *Tensor, grad_w: Tensor, saved_v: Tensor, saved_g: Tensor, saved_norms: Tensor, dim: i64)
atg__weight_norm_interface :: extern proc(out__: *Tensor, v: Tensor, g: Tensor, dim: i64)
atg__weight_norm_interface_backward :: extern proc(out__: *Tensor, grad_w: Tensor, saved_v: Tensor, saved_g: Tensor, saved_norms: Tensor, dim: i64)
atg__weight_norm_interface_backward_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, grad_w: Tensor, saved_v: Tensor, saved_g: Tensor, saved_norms: Tensor, dim: i64)
atg__weight_norm_interface_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, v: Tensor, g: Tensor, dim: i64)
atg__wrapped_linear_prepack :: extern proc(out__: *Tensor, weight: Tensor, weight_scale: Tensor, weight_zero_point: Tensor, bias: Tensor)
atg__wrapped_quantized_linear_prepacked :: extern proc(out__: *Tensor, input: Tensor, input_scale: Tensor, input_zero_point: Tensor, packed_weight: Tensor, output_scale: Tensor, output_zero_point: Tensor, out_channel: i64)
atg_abs :: extern proc(out__: *Tensor, self: Tensor)
atg_abs_ :: extern proc(out__: *Tensor, self: Tensor)
atg_abs_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_absolute :: extern proc(out__: *Tensor, self: Tensor)
atg_absolute_ :: extern proc(out__: *Tensor, self: Tensor)
atg_absolute_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_acos :: extern proc(out__: *Tensor, self: Tensor)
atg_acos_ :: extern proc(out__: *Tensor, self: Tensor)
atg_acos_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_acosh :: extern proc(out__: *Tensor, self: Tensor)
atg_acosh_ :: extern proc(out__: *Tensor, self: Tensor)
atg_acosh_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_adaptive_avg_pool1d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg_adaptive_avg_pool1d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg_adaptive_avg_pool2d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg_adaptive_avg_pool2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg_adaptive_avg_pool3d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg_adaptive_avg_pool3d_backward :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor)
atg_adaptive_avg_pool3d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg_adaptive_max_pool1d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg_adaptive_max_pool2d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg_adaptive_max_pool2d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, indices: Tensor)
atg_adaptive_max_pool2d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, indices: Tensor)
atg_adaptive_max_pool2d_out :: extern proc(out__: *Tensor, out: Tensor, indices: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg_adaptive_max_pool3d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg_adaptive_max_pool3d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, indices: Tensor)
atg_adaptive_max_pool3d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, indices: Tensor)
atg_adaptive_max_pool3d_out :: extern proc(out__: *Tensor, out: Tensor, indices: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg_add :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_add_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_add_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_add_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_add_scalar_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_add_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_addbmm :: extern proc(out__: *Tensor, self: Tensor, batch1: Tensor, batch2: Tensor)
atg_addbmm_ :: extern proc(out__: *Tensor, self: Tensor, batch1: Tensor, batch2: Tensor)
atg_addbmm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, batch1: Tensor, batch2: Tensor)
atg_addcdiv :: extern proc(out__: *Tensor, self: Tensor, tensor1: Tensor, tensor2: Tensor)
atg_addcdiv_ :: extern proc(out__: *Tensor, self: Tensor, tensor1: Tensor, tensor2: Tensor)
atg_addcdiv_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, tensor1: Tensor, tensor2: Tensor)
atg_addcmul :: extern proc(out__: *Tensor, self: Tensor, tensor1: Tensor, tensor2: Tensor)
atg_addcmul_ :: extern proc(out__: *Tensor, self: Tensor, tensor1: Tensor, tensor2: Tensor)
atg_addcmul_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, tensor1: Tensor, tensor2: Tensor)
atg_addmm :: extern proc(out__: *Tensor, self: Tensor, mat1: Tensor, mat2: Tensor)
atg_addmm_ :: extern proc(out__: *Tensor, self: Tensor, mat1: Tensor, mat2: Tensor)
atg_addmm_dtype :: extern proc(out__: *Tensor, self: Tensor, mat1: Tensor, mat2: Tensor, out_dtype: i32)
atg_addmm_dtype_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mat1: Tensor, mat2: Tensor, out_dtype: i32)
atg_addmm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mat1: Tensor, mat2: Tensor)
atg_addmv :: extern proc(out__: *Tensor, self: Tensor, mat: Tensor, vec: Tensor)
atg_addmv_ :: extern proc(out__: *Tensor, self: Tensor, mat: Tensor, vec: Tensor)
atg_addmv_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mat: Tensor, vec: Tensor)
atg_addr :: extern proc(out__: *Tensor, self: Tensor, vec1: Tensor, vec2: Tensor)
atg_addr_ :: extern proc(out__: *Tensor, self: Tensor, vec1: Tensor, vec2: Tensor)
atg_addr_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, vec1: Tensor, vec2: Tensor)
atg_adjoint :: extern proc(out__: *Tensor, self: Tensor)
atg_affine_grid_generator :: extern proc(out__: *Tensor, theta: Tensor, size_data: *i64, size_len: i32, align_corners: bool)
atg_affine_grid_generator_backward :: extern proc(out__: *Tensor, grad: Tensor, size_data: *i64, size_len: i32, align_corners: bool)
atg_affine_grid_generator_out :: extern proc(out__: *Tensor, out: Tensor, theta: Tensor, size_data: *i64, size_len: i32, align_corners: bool)
atg_alias :: extern proc(out__: *Tensor, self: Tensor)
atg_alias_copy :: extern proc(out__: *Tensor, self: Tensor)
atg_alias_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_align_as :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_align_tensors :: extern fn(tensors_data: *Tensor, tensors_len: i32) *Tensor
atg_all :: extern proc(out__: *Tensor, self: Tensor)
atg_all_all_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_all_dim :: extern proc(out__: *Tensor, self: Tensor, dim: i64, keepdim: bool)
atg_all_dims :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_all_dims_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_all_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, keepdim: bool)
atg_allclose :: extern fn(self: Tensor, other: Tensor, rtol: f64, atol: f64, equal_nan: bool) bool
atg_alpha_dropout :: extern proc(out__: *Tensor, input: Tensor, p: f64, train: bool)
atg_alpha_dropout_ :: extern proc(out__: *Tensor, self: Tensor, p: f64, train: bool)
atg_amax :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_amax_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_amin :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_amin_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_aminmax :: extern proc(out__: *Tensor, self: Tensor, dim_v: i64, dim_null: u8, keepdim: bool)
atg_aminmax_out :: extern proc(out__: *Tensor, min: Tensor, max: Tensor, self: Tensor, dim_v: i64, dim_null: u8, keepdim: bool)
atg_angle :: extern proc(out__: *Tensor, self: Tensor)
atg_angle_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_any :: extern proc(out__: *Tensor, self: Tensor)
atg_any_all_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_any_dim :: extern proc(out__: *Tensor, self: Tensor, dim: i64, keepdim: bool)
atg_any_dims :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_any_dims_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_any_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, keepdim: bool)
atg_arange :: extern proc(out__: *Tensor, end: Scalar, options_kind: i32, options_device: i32)
atg_arange_start :: extern proc(out__: *Tensor, start: Scalar, end: Scalar, options_kind: i32, options_device: i32)
atg_arange_start_step :: extern proc(out__: *Tensor, start: Scalar, end: Scalar, step: Scalar, options_kind: i32, options_device: i32)
atg_arccos :: extern proc(out__: *Tensor, self: Tensor)
atg_arccos_ :: extern proc(out__: *Tensor, self: Tensor)
atg_arccos_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_arccosh :: extern proc(out__: *Tensor, self: Tensor)
atg_arccosh_ :: extern proc(out__: *Tensor, self: Tensor)
atg_arccosh_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_arcsin :: extern proc(out__: *Tensor, self: Tensor)
atg_arcsin_ :: extern proc(out__: *Tensor, self: Tensor)
atg_arcsin_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_arcsinh :: extern proc(out__: *Tensor, self: Tensor)
atg_arcsinh_ :: extern proc(out__: *Tensor, self: Tensor)
atg_arcsinh_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_arctan :: extern proc(out__: *Tensor, self: Tensor)
atg_arctan2 :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_arctan2_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_arctan2_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_arctan_ :: extern proc(out__: *Tensor, self: Tensor)
atg_arctan_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_arctanh :: extern proc(out__: *Tensor, self: Tensor)
atg_arctanh_ :: extern proc(out__: *Tensor, self: Tensor)
atg_arctanh_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_argmax :: extern proc(out__: *Tensor, self: Tensor, dim_v: i64, dim_null: u8, keepdim: bool)
atg_argmax_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_v: i64, dim_null: u8, keepdim: bool)
atg_argmin :: extern proc(out__: *Tensor, self: Tensor, dim_v: i64, dim_null: u8, keepdim: bool)
atg_argmin_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_v: i64, dim_null: u8, keepdim: bool)
atg_argsort :: extern proc(out__: *Tensor, self: Tensor, dim: i64, descending: bool)
atg_argsort_stable :: extern proc(out__: *Tensor, self: Tensor, stable: bool, dim: i64, descending: bool)
atg_argsort_stable_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, stable: bool, dim: i64, descending: bool)
atg_argwhere :: extern proc(out__: *Tensor, self: Tensor)
atg_as_strided :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, stride_data: *i64, stride_len: i32, storage_offset_v: i64, storage_offset_null: u8)
atg_as_strided_ :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, stride_data: *i64, stride_len: i32, storage_offset_v: i64, storage_offset_null: u8)
atg_as_strided_copy :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, stride_data: *i64, stride_len: i32, storage_offset_v: i64, storage_offset_null: u8)
atg_as_strided_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size_data: *i64, size_len: i32, stride_data: *i64, stride_len: i32, storage_offset_v: i64, storage_offset_null: u8)
atg_as_strided_scatter :: extern proc(out__: *Tensor, self: Tensor, src: Tensor, size_data: *i64, size_len: i32, stride_data: *i64, stride_len: i32, storage_offset_v: i64, storage_offset_null: u8)
atg_as_strided_scatter_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, src: Tensor, size_data: *i64, size_len: i32, stride_data: *i64, stride_len: i32, storage_offset_v: i64, storage_offset_null: u8)
atg_asin :: extern proc(out__: *Tensor, self: Tensor)
atg_asin_ :: extern proc(out__: *Tensor, self: Tensor)
atg_asin_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_asinh :: extern proc(out__: *Tensor, self: Tensor)
atg_asinh_ :: extern proc(out__: *Tensor, self: Tensor)
atg_asinh_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_atan :: extern proc(out__: *Tensor, self: Tensor)
atg_atan2 :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_atan2_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_atan2_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_atan_ :: extern proc(out__: *Tensor, self: Tensor)
atg_atan_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_atanh :: extern proc(out__: *Tensor, self: Tensor)
atg_atanh_ :: extern proc(out__: *Tensor, self: Tensor)
atg_atanh_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_atleast_1d :: extern proc(out__: *Tensor, self: Tensor)
atg_atleast_1d_sequence :: extern fn(tensors_data: *Tensor, tensors_len: i32) *Tensor
atg_atleast_2d :: extern proc(out__: *Tensor, self: Tensor)
atg_atleast_2d_sequence :: extern fn(tensors_data: *Tensor, tensors_len: i32) *Tensor
atg_atleast_3d :: extern proc(out__: *Tensor, self: Tensor)
atg_atleast_3d_sequence :: extern fn(tensors_data: *Tensor, tensors_len: i32) *Tensor
atg_avg_pool1d :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, ceil_mode: bool, count_include_pad: bool)
atg_avg_pool1d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, ceil_mode: bool, count_include_pad: bool)
atg_avg_pool2d :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, ceil_mode: bool, count_include_pad: bool, divisor_override_v: i64, divisor_override_null: u8)
atg_avg_pool2d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, ceil_mode: bool, count_include_pad: bool, divisor_override_v: i64, divisor_override_null: u8)
atg_avg_pool2d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, ceil_mode: bool, count_include_pad: bool, divisor_override_v: i64, divisor_override_null: u8)
atg_avg_pool2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, ceil_mode: bool, count_include_pad: bool, divisor_override_v: i64, divisor_override_null: u8)
atg_avg_pool3d :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, ceil_mode: bool, count_include_pad: bool, divisor_override_v: i64, divisor_override_null: u8)
atg_avg_pool3d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, ceil_mode: bool, count_include_pad: bool, divisor_override_v: i64, divisor_override_null: u8)
atg_avg_pool3d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, ceil_mode: bool, count_include_pad: bool, divisor_override_v: i64, divisor_override_null: u8)
atg_avg_pool3d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, ceil_mode: bool, count_include_pad: bool, divisor_override_v: i64, divisor_override_null: u8)
atg_baddbmm :: extern proc(out__: *Tensor, self: Tensor, batch1: Tensor, batch2: Tensor, beta: Scalar, alpha: Scalar)
atg_baddbmm_ :: extern proc(out__: *Tensor, self: Tensor, batch1: Tensor, batch2: Tensor)
atg_baddbmm_dtype :: extern proc(out__: *Tensor, self: Tensor, batch1: Tensor, batch2: Tensor, out_dtype: i32, beta: Scalar, alpha: Scalar)
atg_baddbmm_dtype_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, batch1: Tensor, batch2: Tensor, out_dtype: i32)
atg_baddbmm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, batch1: Tensor, batch2: Tensor)
atg_bartlett_window :: extern proc(out__: *Tensor, window_length: i64, options_kind: i32, options_device: i32)
atg_bartlett_window_out :: extern proc(out__: *Tensor, out: Tensor, window_length: i64)
atg_bartlett_window_periodic :: extern proc(out__: *Tensor, window_length: i64, periodic: bool, options_kind: i32, options_device: i32)
atg_bartlett_window_periodic_out :: extern proc(out__: *Tensor, out: Tensor, window_length: i64, periodic: bool)
atg_batch_norm :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, momentum: f64, eps: f64, cudnn_enabled: bool)
atg_batch_norm_backward_elemt :: extern proc(out__: *Tensor, grad_out: Tensor, input: Tensor, mean: Tensor, invstd: Tensor, weight: Tensor, sum_dy: Tensor, sum_dy_xmu: Tensor, count: Tensor)
atg_batch_norm_backward_elemt_out :: extern proc(out__: *Tensor, out: Tensor, grad_out: Tensor, input: Tensor, mean: Tensor, invstd: Tensor, weight: Tensor, sum_dy: Tensor, sum_dy_xmu: Tensor, count: Tensor)
atg_batch_norm_backward_reduce :: extern proc(out__: *Tensor, grad_out: Tensor, input: Tensor, mean: Tensor, invstd: Tensor, weight: Tensor, input_g: bool, weight_g: bool, bias_g: bool)
atg_batch_norm_backward_reduce_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, out3: Tensor, grad_out: Tensor, input: Tensor, mean: Tensor, invstd: Tensor, weight: Tensor, input_g: bool, weight_g: bool, bias_g: bool)
atg_batch_norm_elemt :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, mean: Tensor, invstd: Tensor, eps: f64)
atg_batch_norm_elemt_out :: extern proc(out__: *Tensor, out: Tensor, input: Tensor, weight: Tensor, bias: Tensor, mean: Tensor, invstd: Tensor, eps: f64)
atg_batch_norm_gather_stats :: extern proc(out__: *Tensor, input: Tensor, mean: Tensor, invstd: Tensor, running_mean: Tensor, running_var: Tensor, momentum: f64, eps: f64, count: i64)
atg_batch_norm_gather_stats_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, input: Tensor, mean: Tensor, invstd: Tensor, running_mean: Tensor, running_var: Tensor, momentum: f64, eps: f64, count: i64)
atg_batch_norm_gather_stats_with_counts :: extern proc(out__: *Tensor, input: Tensor, mean: Tensor, invstd: Tensor, running_mean: Tensor, running_var: Tensor, momentum: f64, eps: f64, counts: Tensor)
atg_batch_norm_gather_stats_with_counts_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, input: Tensor, mean: Tensor, invstd: Tensor, running_mean: Tensor, running_var: Tensor, momentum: f64, eps: f64, counts: Tensor)
atg_batch_norm_stats :: extern proc(out__: *Tensor, input: Tensor, eps: f64)
atg_batch_norm_stats_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, input: Tensor, eps: f64)
atg_batch_norm_update_stats :: extern proc(out__: *Tensor, input: Tensor, running_mean: Tensor, running_var: Tensor, momentum: f64)
atg_batch_norm_update_stats_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, input: Tensor, running_mean: Tensor, running_var: Tensor, momentum: f64)
atg_bernoulli :: extern proc(out__: *Tensor, self: Tensor)
atg_bernoulli_ :: extern proc(out__: *Tensor, self: Tensor, p: Tensor)
atg_bernoulli_float_ :: extern proc(out__: *Tensor, self: Tensor, p: f64)
atg_bernoulli_p :: extern proc(out__: *Tensor, self: Tensor, p: f64)
atg_bernoulli_tensor :: extern proc(out__: *Tensor, self: Tensor, p: Tensor)
atg_bilinear :: extern proc(out__: *Tensor, input1: Tensor, input2: Tensor, weight: Tensor, bias: Tensor)
atg_binary_cross_entropy :: extern proc(out__: *Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: i64)
atg_binary_cross_entropy_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: i64)
atg_binary_cross_entropy_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: i64)
atg_binary_cross_entropy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: i64)
atg_binary_cross_entropy_with_logits :: extern proc(out__: *Tensor, self: Tensor, target: Tensor, weight: Tensor, pos_weight: Tensor, reduction: i64)
atg_binary_cross_entropy_with_logits_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, target: Tensor, weight: Tensor, pos_weight: Tensor, reduction: i64)
atg_bincount :: extern proc(out__: *Tensor, self: Tensor, weights: Tensor, minlength: i64)
atg_bincount_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weights: Tensor, minlength: i64)
atg_binomial :: extern proc(out__: *Tensor, count: Tensor, prob: Tensor)
atg_binomial_out :: extern proc(out__: *Tensor, out: Tensor, count: Tensor, prob: Tensor)
atg_bitwise_and :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_bitwise_and_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_bitwise_and_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_bitwise_and_scalar_tensor :: extern proc(out__: *Tensor, self_scalar: Scalar, other: Tensor)
atg_bitwise_and_scalar_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self_scalar: Scalar, other: Tensor)
atg_bitwise_and_tensor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_bitwise_and_tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_bitwise_and_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_bitwise_left_shift :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_bitwise_left_shift_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_bitwise_left_shift_scalar_tensor :: extern proc(out__: *Tensor, self_scalar: Scalar, other: Tensor)
atg_bitwise_left_shift_scalar_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self_scalar: Scalar, other: Tensor)
atg_bitwise_left_shift_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_bitwise_left_shift_tensor_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_bitwise_left_shift_tensor_scalar_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_bitwise_left_shift_tensor_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_bitwise_not :: extern proc(out__: *Tensor, self: Tensor)
atg_bitwise_not_ :: extern proc(out__: *Tensor, self: Tensor)
atg_bitwise_not_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_bitwise_or :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_bitwise_or_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_bitwise_or_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_bitwise_or_scalar_tensor :: extern proc(out__: *Tensor, self_scalar: Scalar, other: Tensor)
atg_bitwise_or_scalar_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self_scalar: Scalar, other: Tensor)
atg_bitwise_or_tensor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_bitwise_or_tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_bitwise_or_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_bitwise_right_shift :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_bitwise_right_shift_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_bitwise_right_shift_scalar_tensor :: extern proc(out__: *Tensor, self_scalar: Scalar, other: Tensor)
atg_bitwise_right_shift_scalar_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self_scalar: Scalar, other: Tensor)
atg_bitwise_right_shift_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_bitwise_right_shift_tensor_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_bitwise_right_shift_tensor_scalar_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_bitwise_right_shift_tensor_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_bitwise_xor :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_bitwise_xor_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_bitwise_xor_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_bitwise_xor_scalar_tensor :: extern proc(out__: *Tensor, self_scalar: Scalar, other: Tensor)
atg_bitwise_xor_scalar_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self_scalar: Scalar, other: Tensor)
atg_bitwise_xor_tensor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_bitwise_xor_tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_bitwise_xor_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_blackman_window :: extern proc(out__: *Tensor, window_length: i64, options_kind: i32, options_device: i32)
atg_blackman_window_out :: extern proc(out__: *Tensor, out: Tensor, window_length: i64)
atg_blackman_window_periodic :: extern proc(out__: *Tensor, window_length: i64, periodic: bool, options_kind: i32, options_device: i32)
atg_blackman_window_periodic_out :: extern proc(out__: *Tensor, out: Tensor, window_length: i64, periodic: bool)
atg_block_diag :: extern proc(out__: *Tensor, tensors_data: *Tensor, tensors_len: i32)
atg_block_diag_out :: extern proc(out__: *Tensor, out: Tensor, tensors_data: *Tensor, tensors_len: i32)
atg_bmm :: extern proc(out__: *Tensor, self: Tensor, mat2: Tensor)
atg_bmm_dtype :: extern proc(out__: *Tensor, self: Tensor, mat2: Tensor, out_dtype: i32)
atg_bmm_dtype_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mat2: Tensor, out_dtype: i32)
atg_bmm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mat2: Tensor)
atg_broadcast_tensors :: extern fn(tensors_data: *Tensor, tensors_len: i32) *Tensor
atg_broadcast_to :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg_bucketize :: extern proc(out__: *Tensor, self: Tensor, boundaries: Tensor, out_int32: bool, right: bool)
atg_bucketize_scalar :: extern proc(out__: *Tensor, self_scalar: Scalar, boundaries: Tensor, out_int32: bool, right: bool)
atg_bucketize_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self_scalar: Scalar, boundaries: Tensor, out_int32: bool, right: bool)
atg_bucketize_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, boundaries: Tensor, out_int32: bool, right: bool)
atg_can_cast :: extern fn(from_: i32, to: i32) bool
atg_cartesian_prod :: extern proc(out__: *Tensor, tensors_data: *Tensor, tensors_len: i32)
atg_cat :: extern proc(out__: *Tensor, tensors_data: *Tensor, tensors_len: i32, dim: i64)
atg_cat_out :: extern proc(out__: *Tensor, out: Tensor, tensors_data: *Tensor, tensors_len: i32, dim: i64)
atg_cauchy :: extern proc(out__: *Tensor, self: Tensor, median: f64, sigma: f64)
atg_cauchy_ :: extern proc(out__: *Tensor, self: Tensor, median: f64, sigma: f64)
atg_cauchy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, median: f64, sigma: f64)
atg_ccol_indices :: extern proc(out__: *Tensor, self: Tensor)
atg_ccol_indices_copy :: extern proc(out__: *Tensor, self: Tensor)
atg_ccol_indices_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_cdist :: extern proc(out__: *Tensor, x1: Tensor, x2: Tensor, p: f64, compute_mode_v: i64, compute_mode_null: u8)
atg_ceil :: extern proc(out__: *Tensor, self: Tensor)
atg_ceil_ :: extern proc(out__: *Tensor, self: Tensor)
atg_ceil_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_celu :: extern proc(out__: *Tensor, self: Tensor)
atg_celu_ :: extern proc(out__: *Tensor, self: Tensor)
atg_celu_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_chain_matmul :: extern proc(out__: *Tensor, matrices_data: *Tensor, matrices_len: i32)
atg_chain_matmul_out :: extern proc(out__: *Tensor, out: Tensor, matrices_data: *Tensor, matrices_len: i32)
atg_chalf :: extern proc(out__: *Tensor, self: Tensor)
atg_channel_shuffle :: extern proc(out__: *Tensor, self: Tensor, groups: i64)
atg_channel_shuffle_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, groups: i64)
atg_cholesky :: extern proc(out__: *Tensor, self: Tensor, upper: bool)
atg_cholesky_inverse :: extern proc(out__: *Tensor, self: Tensor, upper: bool)
atg_cholesky_inverse_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, upper: bool)
atg_cholesky_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, upper: bool)
atg_cholesky_solve :: extern proc(out__: *Tensor, self: Tensor, input2: Tensor, upper: bool)
atg_cholesky_solve_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, input2: Tensor, upper: bool)
atg_choose_qparams_optimized :: extern proc(out__: *Tensor, input: Tensor, numel: i64, n_bins: i64, ratio: f64, bit_width: i64)
atg_chunk :: extern fn(self: Tensor, chunks: i64, dim: i64) *Tensor
atg_clamp :: extern proc(out__: *Tensor, self: Tensor, min: Scalar, max: Scalar)
atg_clamp_ :: extern proc(out__: *Tensor, self: Tensor, min: Scalar, max: Scalar)
atg_clamp_max :: extern proc(out__: *Tensor, self: Tensor, max: Scalar)
atg_clamp_max_ :: extern proc(out__: *Tensor, self: Tensor, max: Scalar)
atg_clamp_max_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, max: Scalar)
atg_clamp_max_tensor :: extern proc(out__: *Tensor, self: Tensor, max: Tensor)
atg_clamp_max_tensor_ :: extern proc(out__: *Tensor, self: Tensor, max: Tensor)
atg_clamp_max_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, max: Tensor)
atg_clamp_min :: extern proc(out__: *Tensor, self: Tensor, min: Scalar)
atg_clamp_min_ :: extern proc(out__: *Tensor, self: Tensor, min: Scalar)
atg_clamp_min_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, min: Scalar)
atg_clamp_min_tensor :: extern proc(out__: *Tensor, self: Tensor, min: Tensor)
atg_clamp_min_tensor_ :: extern proc(out__: *Tensor, self: Tensor, min: Tensor)
atg_clamp_min_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, min: Tensor)
atg_clamp_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, min: Scalar, max: Scalar)
atg_clamp_tensor :: extern proc(out__: *Tensor, self: Tensor, min: Tensor, max: Tensor)
atg_clamp_tensor_ :: extern proc(out__: *Tensor, self: Tensor, min: Tensor, max: Tensor)
atg_clamp_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, min: Tensor, max: Tensor)
atg_clip :: extern proc(out__: *Tensor, self: Tensor, min: Scalar, max: Scalar)
atg_clip_ :: extern proc(out__: *Tensor, self: Tensor, min: Scalar, max: Scalar)
atg_clip_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, min: Scalar, max: Scalar)
atg_clip_tensor :: extern proc(out__: *Tensor, self: Tensor, min: Tensor, max: Tensor)
atg_clip_tensor_ :: extern proc(out__: *Tensor, self: Tensor, min: Tensor, max: Tensor)
atg_clip_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, min: Tensor, max: Tensor)
atg_clone :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_coalesce :: extern proc(out__: *Tensor, self: Tensor)
atg_col2im :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, kernel_size_data: *i64, kernel_size_len: i32, dilation_data: *i64, dilation_len: i32, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32)
atg_col2im_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, kernel_size_data: *i64, kernel_size_len: i32, dilation_data: *i64, dilation_len: i32, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32)
atg_col_indices :: extern proc(out__: *Tensor, self: Tensor)
atg_col_indices_copy :: extern proc(out__: *Tensor, self: Tensor)
atg_col_indices_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_column_stack :: extern proc(out__: *Tensor, tensors_data: *Tensor, tensors_len: i32)
atg_column_stack_out :: extern proc(out__: *Tensor, out: Tensor, tensors_data: *Tensor, tensors_len: i32)
atg_combinations :: extern proc(out__: *Tensor, self: Tensor, r: i64, with_replacement: bool)
atg_complex :: extern proc(out__: *Tensor, real: Tensor, imag: Tensor)
atg_complex_out :: extern proc(out__: *Tensor, out: Tensor, real: Tensor, imag: Tensor)
atg_concat :: extern proc(out__: *Tensor, tensors_data: *Tensor, tensors_len: i32, dim: i64)
atg_concat_out :: extern proc(out__: *Tensor, out: Tensor, tensors_data: *Tensor, tensors_len: i32, dim: i64)
atg_concatenate :: extern proc(out__: *Tensor, tensors_data: *Tensor, tensors_len: i32, dim: i64)
atg_concatenate_out :: extern proc(out__: *Tensor, out: Tensor, tensors_data: *Tensor, tensors_len: i32, dim: i64)
atg_conj :: extern proc(out__: *Tensor, self: Tensor)
atg_conj_physical :: extern proc(out__: *Tensor, self: Tensor)
atg_conj_physical_ :: extern proc(out__: *Tensor, self: Tensor)
atg_conj_physical_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_constant_pad_nd :: extern proc(out__: *Tensor, self: Tensor, pad_data: *i64, pad_len: i32)
atg_constant_pad_nd_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, pad_data: *i64, pad_len: i32)
atg_contiguous :: extern proc(out__: *Tensor, self: Tensor)
atg_conv1d :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg_conv1d_padding :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_ptr: *u8, padding_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg_conv2d :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg_conv2d_padding :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_ptr: *u8, padding_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg_conv3d :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg_conv3d_padding :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_ptr: *u8, padding_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg_conv_depthwise3d :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, kernel_size_data: *i64, kernel_size_len: i32, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32)
atg_conv_depthwise3d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, kernel_size_data: *i64, kernel_size_len: i32, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32)
atg_conv_tbc :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, bias: Tensor, pad: i64)
atg_conv_tbc_backward :: extern proc(out__: *Tensor, self: Tensor, input: Tensor, weight: Tensor, bias: Tensor, pad: i64)
atg_conv_tbc_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, bias: Tensor, pad: i64)
atg_conv_transpose1d :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, output_padding_data: *i64, output_padding_len: i32, groups: i64, dilation_data: *i64, dilation_len: i32)
atg_conv_transpose2d :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, output_padding_data: *i64, output_padding_len: i32, groups: i64, dilation_data: *i64, dilation_len: i32)
atg_conv_transpose3d :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, output_padding_data: *i64, output_padding_len: i32, groups: i64, dilation_data: *i64, dilation_len: i32)
atg_convolution :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, transposed: bool, output_padding_data: *i64, output_padding_len: i32, groups: i64)
atg_convolution_out :: extern proc(out__: *Tensor, out: Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, transposed: bool, output_padding_data: *i64, output_padding_len: i32, groups: i64)
atg_convolution_overrideable :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, transposed: bool, output_padding_data: *i64, output_padding_len: i32, groups: i64)
atg_convolution_overrideable_out :: extern proc(out__: *Tensor, out: Tensor, input: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, transposed: bool, output_padding_data: *i64, output_padding_len: i32, groups: i64)
atg_copy_sparse_to_sparse :: extern proc(out__: *Tensor, self: Tensor, src: Tensor, non_blocking: bool)
atg_copy_sparse_to_sparse_ :: extern proc(out__: *Tensor, self: Tensor, src: Tensor, non_blocking: bool)
atg_copy_sparse_to_sparse_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, src: Tensor, non_blocking: bool)
atg_copysign :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_copysign_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_copysign_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_copysign_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_copysign_scalar_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_copysign_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_corrcoef :: extern proc(out__: *Tensor, self: Tensor)
atg_cos :: extern proc(out__: *Tensor, self: Tensor)
atg_cos_ :: extern proc(out__: *Tensor, self: Tensor)
atg_cos_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_cosh :: extern proc(out__: *Tensor, self: Tensor)
atg_cosh_ :: extern proc(out__: *Tensor, self: Tensor)
atg_cosh_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_cosine_embedding_loss :: extern proc(out__: *Tensor, input1: Tensor, input2: Tensor, target: Tensor, margin: f64, reduction: i64)
atg_cosine_similarity :: extern proc(out__: *Tensor, x1: Tensor, x2: Tensor, dim: i64, eps: f64)
atg_count_nonzero :: extern proc(out__: *Tensor, self: Tensor, dim_v: i64, dim_null: u8)
atg_count_nonzero_dim_intlist :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32)
atg_count_nonzero_dim_intlist_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32)
atg_count_nonzero_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_v: i64, dim_null: u8)
atg_cov :: extern proc(out__: *Tensor, self: Tensor, correction: i64, fweights: Tensor, aweights: Tensor)
atg_cross :: extern proc(out__: *Tensor, self: Tensor, other: Tensor, dim_v: i64, dim_null: u8)
atg_cross_entropy_loss :: extern proc(out__: *Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: i64, ignore_index: i64, label_smoothing: f64)
atg_cross_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor, dim_v: i64, dim_null: u8)
atg_crow_indices :: extern proc(out__: *Tensor, self: Tensor)
atg_crow_indices_copy :: extern proc(out__: *Tensor, self: Tensor)
atg_crow_indices_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_ctc_loss :: extern proc(out__: *Tensor, log_probs: Tensor, targets: Tensor, input_lengths_data: *i64, input_lengths_len: i32, target_lengths_data: *i64, target_lengths_len: i32, blank: i64, reduction: i64, zero_infinity: bool)
atg_ctc_loss_tensor :: extern proc(out__: *Tensor, log_probs: Tensor, targets: Tensor, input_lengths: Tensor, target_lengths: Tensor, blank: i64, reduction: i64, zero_infinity: bool)
atg_cudnn_affine_grid_generator :: extern proc(out__: *Tensor, theta: Tensor, n: i64, C: i64, H: i64, W: i64)
atg_cudnn_affine_grid_generator_backward :: extern proc(out__: *Tensor, grad: Tensor, n: i64, C: i64, H: i64, W: i64)
atg_cudnn_affine_grid_generator_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad: Tensor, n: i64, C: i64, H: i64, W: i64)
atg_cudnn_affine_grid_generator_out :: extern proc(out__: *Tensor, out: Tensor, theta: Tensor, n: i64, C: i64, H: i64, W: i64)
atg_cudnn_batch_norm :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, exponential_average_factor: f64, epsilon: f64)
atg_cudnn_batch_norm_backward :: extern proc(out__: *Tensor, input: Tensor, grad_output: Tensor, weight: Tensor, running_mean: Tensor, running_var: Tensor, save_mean: Tensor, save_var: Tensor, epsilon: f64, reserveSpace: Tensor)
atg_cudnn_batch_norm_backward_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, input: Tensor, grad_output: Tensor, weight: Tensor, running_mean: Tensor, running_var: Tensor, save_mean: Tensor, save_var: Tensor, epsilon: f64, reserveSpace: Tensor)
atg_cudnn_batch_norm_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, out3: Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, exponential_average_factor: f64, epsilon: f64)
atg_cudnn_convolution :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64, benchmark: bool, deterministic: bool, allow_tf32: bool)
atg_cudnn_convolution_add_relu :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, z: Tensor, alpha: Scalar, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg_cudnn_convolution_add_relu_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, z: Tensor, alpha: Scalar, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg_cudnn_convolution_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64, benchmark: bool, deterministic: bool, allow_tf32: bool)
atg_cudnn_convolution_relu :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg_cudnn_convolution_relu_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg_cudnn_convolution_transpose :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, padding_data: *i64, padding_len: i32, output_padding_data: *i64, output_padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64, benchmark: bool, deterministic: bool, allow_tf32: bool)
atg_cudnn_convolution_transpose_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, padding_data: *i64, padding_len: i32, output_padding_data: *i64, output_padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64, benchmark: bool, deterministic: bool, allow_tf32: bool)
atg_cudnn_grid_sampler :: extern proc(out__: *Tensor, self: Tensor, grid: Tensor)
atg_cudnn_grid_sampler_backward :: extern proc(out__: *Tensor, self: Tensor, grid: Tensor, grad_output: Tensor)
atg_cudnn_grid_sampler_backward_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, self: Tensor, grid: Tensor, grad_output: Tensor)
atg_cudnn_grid_sampler_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, grid: Tensor)
atg_cudnn_is_acceptable :: extern fn(self: Tensor) bool
atg_cummax :: extern proc(out__: *Tensor, self: Tensor, dim: i64)
atg_cummax_out :: extern proc(out__: *Tensor, values: Tensor, indices: Tensor, self: Tensor, dim: i64)
atg_cummaxmin_backward :: extern proc(out__: *Tensor, grad: Tensor, input: Tensor, indices: Tensor, dim: i64)
atg_cummin :: extern proc(out__: *Tensor, self: Tensor, dim: i64)
atg_cummin_out :: extern proc(out__: *Tensor, values: Tensor, indices: Tensor, self: Tensor, dim: i64)
atg_cumprod :: extern proc(out__: *Tensor, self: Tensor, dim: i64, dtype: i32)
atg_cumprod_ :: extern proc(out__: *Tensor, self: Tensor, dim: i64, dtype: i32)
atg_cumprod_backward :: extern proc(out__: *Tensor, grad: Tensor, input: Tensor, dim: i64, output: Tensor)
atg_cumprod_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, dtype: i32)
atg_cumsum :: extern proc(out__: *Tensor, self: Tensor, dim: i64, dtype: i32)
atg_cumsum_ :: extern proc(out__: *Tensor, self: Tensor, dim: i64, dtype: i32)
atg_cumsum_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, dtype: i32)
atg_cumulative_trapezoid :: extern proc(out__: *Tensor, y: Tensor, dim: i64)
atg_cumulative_trapezoid_x :: extern proc(out__: *Tensor, y: Tensor, x: Tensor, dim: i64)
atg_data :: extern proc(out__: *Tensor, self: Tensor)
atg_deg2rad :: extern proc(out__: *Tensor, self: Tensor)
atg_deg2rad_ :: extern proc(out__: *Tensor, self: Tensor)
atg_deg2rad_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_dense_dim :: extern fn(self: Tensor) i64
atg_dequantize :: extern proc(out__: *Tensor, self: Tensor)
atg_dequantize_self_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_dequantize_tensors :: extern fn(tensors_data: *Tensor, tensors_len: i32) *Tensor
atg_dequantize_tensors_out :: extern proc(out_data: *Tensor, out_len: i32, tensors_data: *Tensor, tensors_len: i32)
atg_det :: extern proc(out__: *Tensor, self: Tensor)
atg_detach :: extern proc(out__: *Tensor, self: Tensor)
atg_detach_ :: extern proc(out__: *Tensor, self: Tensor)
atg_detach_copy :: extern proc(out__: *Tensor, self: Tensor)
atg_detach_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_diag :: extern proc(out__: *Tensor, self: Tensor, diagonal: i64)
atg_diag_embed :: extern proc(out__: *Tensor, self: Tensor, offset: i64, dim1: i64, dim2: i64)
atg_diag_embed_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, offset: i64, dim1: i64, dim2: i64)
atg_diag_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, diagonal: i64)
atg_diagflat :: extern proc(out__: *Tensor, self: Tensor, offset: i64)
atg_diagonal :: extern proc(out__: *Tensor, self: Tensor, offset: i64, dim1: i64, dim2: i64)
atg_diagonal_backward :: extern proc(out__: *Tensor, grad_output: Tensor, input_sizes_data: *i64, input_sizes_len: i32, offset: i64, dim1: i64, dim2: i64)
atg_diagonal_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, input_sizes_data: *i64, input_sizes_len: i32, offset: i64, dim1: i64, dim2: i64)
atg_diagonal_copy :: extern proc(out__: *Tensor, self: Tensor, offset: i64, dim1: i64, dim2: i64)
atg_diagonal_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, offset: i64, dim1: i64, dim2: i64)
atg_diagonal_scatter :: extern proc(out__: *Tensor, self: Tensor, src: Tensor, offset: i64, dim1: i64, dim2: i64)
atg_diagonal_scatter_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, src: Tensor, offset: i64, dim1: i64, dim2: i64)
atg_diff :: extern proc(out__: *Tensor, self: Tensor, n: i64, dim: i64, prepend: Tensor, append: Tensor)
atg_diff_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, n: i64, dim: i64, prepend: Tensor, append: Tensor)
atg_digamma :: extern proc(out__: *Tensor, self: Tensor)
atg_digamma_ :: extern proc(out__: *Tensor, self: Tensor)
atg_digamma_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_dist :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_dist_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_div :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_div_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_div_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_div_out_mode :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor, rounding_mode_ptr: *u8, rounding_mode_len: i32)
atg_div_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_div_scalar_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_div_scalar_mode :: extern proc(out__: *Tensor, self: Tensor, other: Scalar, rounding_mode_ptr: *u8, rounding_mode_len: i32)
atg_div_scalar_mode_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar, rounding_mode_ptr: *u8, rounding_mode_len: i32)
atg_div_scalar_mode_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar, rounding_mode_ptr: *u8, rounding_mode_len: i32)
atg_div_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_div_tensor_mode :: extern proc(out__: *Tensor, self: Tensor, other: Tensor, rounding_mode_ptr: *u8, rounding_mode_len: i32)
atg_div_tensor_mode_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor, rounding_mode_ptr: *u8, rounding_mode_len: i32)
atg_divide :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_divide_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_divide_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_divide_out_mode :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor, rounding_mode_ptr: *u8, rounding_mode_len: i32)
atg_divide_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_divide_scalar_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_divide_scalar_mode :: extern proc(out__: *Tensor, self: Tensor, other: Scalar, rounding_mode_ptr: *u8, rounding_mode_len: i32)
atg_divide_scalar_mode_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar, rounding_mode_ptr: *u8, rounding_mode_len: i32)
atg_divide_tensor_mode :: extern proc(out__: *Tensor, self: Tensor, other: Tensor, rounding_mode_ptr: *u8, rounding_mode_len: i32)
atg_divide_tensor_mode_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor, rounding_mode_ptr: *u8, rounding_mode_len: i32)
atg_dot :: extern proc(out__: *Tensor, self: Tensor, tensor_: Tensor)
atg_dot_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, tensor_: Tensor)
atg_dropout :: extern proc(out__: *Tensor, input: Tensor, p: f64, train: bool)
atg_dropout_ :: extern proc(out__: *Tensor, self: Tensor, p: f64, train: bool)
atg_dsplit :: extern fn(self: Tensor, sections: i64) *Tensor
atg_dsplit_array :: extern fn(self: Tensor, indices_data: *i64, indices_len: i32) *Tensor
atg_dstack :: extern proc(out__: *Tensor, tensors_data: *Tensor, tensors_len: i32)
atg_dstack_out :: extern proc(out__: *Tensor, out: Tensor, tensors_data: *Tensor, tensors_len: i32)
atg_einsum :: extern proc(out__: *Tensor, equation_ptr: *u8, equation_len: i32, tensors_data: *Tensor, tensors_len: i32, path_data: *i64, path_len: i32)
atg_elu :: extern proc(out__: *Tensor, self: Tensor)
atg_elu_ :: extern proc(out__: *Tensor, self: Tensor)
atg_elu_backward :: extern proc(out__: *Tensor, grad_output: Tensor, alpha: Scalar, scale: Scalar, input_scale: Scalar, is_result: bool, self_or_result: Tensor)
atg_elu_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, alpha: Scalar, scale: Scalar, input_scale: Scalar, is_result: bool, self_or_result: Tensor)
atg_elu_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_embedding :: extern proc(out__: *Tensor, weight: Tensor, indices: Tensor, padding_idx: i64, scale_grad_by_freq: bool, sparse: bool)
atg_embedding_backward :: extern proc(out__: *Tensor, grad: Tensor, indices: Tensor, num_weights: i64, padding_idx: i64, scale_grad_by_freq: bool, sparse: bool)
atg_embedding_bag :: extern proc(out__: *Tensor, weight: Tensor, indices: Tensor, offsets: Tensor, scale_grad_by_freq: bool, mode: i64, sparse: bool, per_sample_weights: Tensor, include_last_offset: bool)
atg_embedding_bag_padding_idx :: extern proc(out__: *Tensor, weight: Tensor, indices: Tensor, offsets: Tensor, scale_grad_by_freq: bool, mode: i64, sparse: bool, per_sample_weights: Tensor, include_last_offset: bool, padding_idx_v: i64, padding_idx_null: u8)
atg_embedding_dense_backward :: extern proc(out__: *Tensor, grad_output: Tensor, indices: Tensor, num_weights: i64, padding_idx: i64, scale_grad_by_freq: bool)
atg_embedding_dense_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, indices: Tensor, num_weights: i64, padding_idx: i64, scale_grad_by_freq: bool)
atg_embedding_out :: extern proc(out__: *Tensor, out: Tensor, weight: Tensor, indices: Tensor, padding_idx: i64, scale_grad_by_freq: bool, sparse: bool)
atg_embedding_renorm :: extern proc(out__: *Tensor, self: Tensor, indices: Tensor, max_norm: f64, norm_type: f64)
atg_embedding_renorm_ :: extern proc(out__: *Tensor, self: Tensor, indices: Tensor, max_norm: f64, norm_type: f64)
atg_embedding_renorm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, indices: Tensor, max_norm: f64, norm_type: f64)
atg_embedding_sparse_backward :: extern proc(out__: *Tensor, grad: Tensor, indices: Tensor, num_weights: i64, padding_idx: i64, scale_grad_by_freq: bool)
atg_empty :: extern proc(out__: *Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg_empty_like :: extern proc(out__: *Tensor, self: Tensor)
atg_empty_like_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_empty_out :: extern proc(out__: *Tensor, out: Tensor, size_data: *i64, size_len: i32)
atg_empty_permuted :: extern proc(out__: *Tensor, size_data: *i64, size_len: i32, physical_layout_data: *i64, physical_layout_len: i32, options_kind: i32, options_device: i32)
atg_empty_permuted_out :: extern proc(out__: *Tensor, out: Tensor, size_data: *i64, size_len: i32, physical_layout_data: *i64, physical_layout_len: i32)
atg_empty_quantized :: extern proc(out__: *Tensor, size_data: *i64, size_len: i32, qtensor: Tensor, options_kind: i32, options_device: i32)
atg_empty_quantized_out :: extern proc(out__: *Tensor, out: Tensor, size_data: *i64, size_len: i32, qtensor: Tensor)
atg_empty_strided :: extern proc(out__: *Tensor, size_data: *i64, size_len: i32, stride_data: *i64, stride_len: i32, options_kind: i32, options_device: i32)
atg_empty_strided_out :: extern proc(out__: *Tensor, out: Tensor, size_data: *i64, size_len: i32, stride_data: *i64, stride_len: i32)
atg_eq :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_eq_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_eq_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_eq_tensor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_eq_tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_eq_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_equal :: extern fn(self: Tensor, other: Tensor) bool
atg_erf :: extern proc(out__: *Tensor, self: Tensor)
atg_erf_ :: extern proc(out__: *Tensor, self: Tensor)
atg_erf_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_erfc :: extern proc(out__: *Tensor, self: Tensor)
atg_erfc_ :: extern proc(out__: *Tensor, self: Tensor)
atg_erfc_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_erfinv :: extern proc(out__: *Tensor, self: Tensor)
atg_erfinv_ :: extern proc(out__: *Tensor, self: Tensor)
atg_erfinv_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_exp :: extern proc(out__: *Tensor, self: Tensor)
atg_exp2 :: extern proc(out__: *Tensor, self: Tensor)
atg_exp2_ :: extern proc(out__: *Tensor, self: Tensor)
atg_exp2_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_exp_ :: extern proc(out__: *Tensor, self: Tensor)
atg_exp_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_expand :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, implicit: bool)
atg_expand_as :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_expand_copy :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, implicit: bool)
atg_expand_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size_data: *i64, size_len: i32, implicit: bool)
atg_expm1 :: extern proc(out__: *Tensor, self: Tensor)
atg_expm1_ :: extern proc(out__: *Tensor, self: Tensor)
atg_expm1_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_exponential :: extern proc(out__: *Tensor, self: Tensor, lambd: f64)
atg_exponential_ :: extern proc(out__: *Tensor, self: Tensor, lambd: f64)
atg_exponential_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, lambd: f64)
atg_eye :: extern proc(out__: *Tensor, n: i64, options_kind: i32, options_device: i32)
atg_eye_m :: extern proc(out__: *Tensor, n: i64, m: i64, options_kind: i32, options_device: i32)
atg_eye_m_out :: extern proc(out__: *Tensor, out: Tensor, n: i64, m: i64)
atg_eye_out :: extern proc(out__: *Tensor, out: Tensor, n: i64)
atg_fake_quantize_per_channel_affine :: extern proc(out__: *Tensor, self: Tensor, scale: Tensor, zero_point: Tensor, axis: i64, quant_min: i64, quant_max: i64)
atg_fake_quantize_per_channel_affine_cachemask :: extern proc(out__: *Tensor, self: Tensor, scale: Tensor, zero_point: Tensor, axis: i64, quant_min: i64, quant_max: i64)
atg_fake_quantize_per_channel_affine_cachemask_backward :: extern proc(out__: *Tensor, grad: Tensor, mask: Tensor)
atg_fake_quantize_per_channel_affine_cachemask_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, self: Tensor, scale: Tensor, zero_point: Tensor, axis: i64, quant_min: i64, quant_max: i64)
atg_fake_quantize_per_tensor_affine :: extern proc(out__: *Tensor, self: Tensor, scale: f64, zero_point: i64, quant_min: i64, quant_max: i64)
atg_fake_quantize_per_tensor_affine_cachemask :: extern proc(out__: *Tensor, self: Tensor, scale: f64, zero_point: i64, quant_min: i64, quant_max: i64)
atg_fake_quantize_per_tensor_affine_cachemask_backward :: extern proc(out__: *Tensor, grad: Tensor, mask: Tensor)
atg_fake_quantize_per_tensor_affine_cachemask_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, self: Tensor, scale: f64, zero_point: i64, quant_min: i64, quant_max: i64)
atg_fake_quantize_per_tensor_affine_tensor_qparams :: extern proc(out__: *Tensor, self: Tensor, scale: Tensor, zero_point: Tensor, quant_min: i64, quant_max: i64)
atg_feature_alpha_dropout :: extern proc(out__: *Tensor, input: Tensor, p: f64, train: bool)
atg_feature_alpha_dropout_ :: extern proc(out__: *Tensor, self: Tensor, p: f64, train: bool)
atg_feature_dropout :: extern proc(out__: *Tensor, input: Tensor, p: f64, train: bool)
atg_feature_dropout_ :: extern proc(out__: *Tensor, self: Tensor, p: f64, train: bool)
atg_fft_fft :: extern proc(out__: *Tensor, self: Tensor, n_v: i64, n_null: u8, dim: i64, norm_ptr: *u8, norm_len: i32)
atg_fft_fft2 :: extern proc(out__: *Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_fft2_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_fft_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, n_v: i64, n_null: u8, dim: i64, norm_ptr: *u8, norm_len: i32)
atg_fft_fftfreq :: extern proc(out__: *Tensor, n: i64, d: f64, options_kind: i32, options_device: i32)
atg_fft_fftfreq_out :: extern proc(out__: *Tensor, out: Tensor, n: i64, d: f64)
atg_fft_fftn :: extern proc(out__: *Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_fftn_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_fftshift :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32)
atg_fft_hfft :: extern proc(out__: *Tensor, self: Tensor, n_v: i64, n_null: u8, dim: i64, norm_ptr: *u8, norm_len: i32)
atg_fft_hfft2 :: extern proc(out__: *Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_hfft2_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_hfft_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, n_v: i64, n_null: u8, dim: i64, norm_ptr: *u8, norm_len: i32)
atg_fft_hfftn :: extern proc(out__: *Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_hfftn_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_ifft :: extern proc(out__: *Tensor, self: Tensor, n_v: i64, n_null: u8, dim: i64, norm_ptr: *u8, norm_len: i32)
atg_fft_ifft2 :: extern proc(out__: *Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_ifft2_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_ifft_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, n_v: i64, n_null: u8, dim: i64, norm_ptr: *u8, norm_len: i32)
atg_fft_ifftn :: extern proc(out__: *Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_ifftn_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_ifftshift :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32)
atg_fft_ihfft :: extern proc(out__: *Tensor, self: Tensor, n_v: i64, n_null: u8, dim: i64, norm_ptr: *u8, norm_len: i32)
atg_fft_ihfft2 :: extern proc(out__: *Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_ihfft2_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_ihfft_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, n_v: i64, n_null: u8, dim: i64, norm_ptr: *u8, norm_len: i32)
atg_fft_ihfftn :: extern proc(out__: *Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_ihfftn_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_irfft :: extern proc(out__: *Tensor, self: Tensor, n_v: i64, n_null: u8, dim: i64, norm_ptr: *u8, norm_len: i32)
atg_fft_irfft2 :: extern proc(out__: *Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_irfft2_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_irfft_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, n_v: i64, n_null: u8, dim: i64, norm_ptr: *u8, norm_len: i32)
atg_fft_irfftn :: extern proc(out__: *Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_irfftn_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_rfft :: extern proc(out__: *Tensor, self: Tensor, n_v: i64, n_null: u8, dim: i64, norm_ptr: *u8, norm_len: i32)
atg_fft_rfft2 :: extern proc(out__: *Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_rfft2_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_rfft_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, n_v: i64, n_null: u8, dim: i64, norm_ptr: *u8, norm_len: i32)
atg_fft_rfftfreq :: extern proc(out__: *Tensor, n: i64, d: f64, options_kind: i32, options_device: i32)
atg_fft_rfftfreq_out :: extern proc(out__: *Tensor, out: Tensor, n: i64, d: f64)
atg_fft_rfftn :: extern proc(out__: *Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fft_rfftn_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, s_data: *i64, s_len: i32, dim_data: *i64, dim_len: i32, norm_ptr: *u8, norm_len: i32)
atg_fill :: extern proc(out__: *Tensor, self: Tensor, value: Scalar)
atg_fill_ :: extern proc(out__: *Tensor, self: Tensor, value: Scalar)
atg_fill_diagonal_ :: extern proc(out__: *Tensor, self: Tensor, fill_value: Scalar, wrap: bool)
atg_fill_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, value: Scalar)
atg_fill_tensor :: extern proc(out__: *Tensor, self: Tensor, value: Tensor)
atg_fill_tensor_ :: extern proc(out__: *Tensor, self: Tensor, value: Tensor)
atg_fill_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, value: Tensor)
atg_fix :: extern proc(out__: *Tensor, self: Tensor)
atg_fix_ :: extern proc(out__: *Tensor, self: Tensor)
atg_fix_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_flatten :: extern proc(out__: *Tensor, self: Tensor, start_dim: i64, end_dim: i64)
atg_flatten_dense_tensors :: extern proc(out__: *Tensor, tensors_data: *Tensor, tensors_len: i32)
atg_flip :: extern proc(out__: *Tensor, self: Tensor, dims_data: *i64, dims_len: i32)
atg_flip_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dims_data: *i64, dims_len: i32)
atg_fliplr :: extern proc(out__: *Tensor, self: Tensor)
atg_flipud :: extern proc(out__: *Tensor, self: Tensor)
atg_float_power :: extern proc(out__: *Tensor, self: Tensor, exponent: Tensor)
atg_float_power_ :: extern proc(out__: *Tensor, self: Tensor, exponent: Scalar)
atg_float_power_scalar :: extern proc(out__: *Tensor, self_scalar: Scalar, exponent: Tensor)
atg_float_power_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self_scalar: Scalar, exponent: Tensor)
atg_float_power_tensor_ :: extern proc(out__: *Tensor, self: Tensor, exponent: Tensor)
atg_float_power_tensor_scalar :: extern proc(out__: *Tensor, self: Tensor, exponent: Scalar)
atg_float_power_tensor_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, exponent: Scalar)
atg_float_power_tensor_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, exponent: Tensor)
atg_floor :: extern proc(out__: *Tensor, self: Tensor)
atg_floor_ :: extern proc(out__: *Tensor, self: Tensor)
atg_floor_divide :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_floor_divide_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_floor_divide_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_floor_divide_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_floor_divide_scalar_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_floor_divide_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_floor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_fmax :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_fmax_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_fmin :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_fmin_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_fmod :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_fmod_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_fmod_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_fmod_tensor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_fmod_tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_fmod_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_frac :: extern proc(out__: *Tensor, self: Tensor)
atg_frac_ :: extern proc(out__: *Tensor, self: Tensor)
atg_frac_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_fractional_max_pool2d :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, output_size_data: *i64, output_size_len: i32, random_samples: Tensor)
atg_fractional_max_pool2d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, output_size_data: *i64, output_size_len: i32, indices: Tensor)
atg_fractional_max_pool2d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, output_size_data: *i64, output_size_len: i32, indices: Tensor)
atg_fractional_max_pool2d_output :: extern proc(out__: *Tensor, output: Tensor, indices: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, output_size_data: *i64, output_size_len: i32, random_samples: Tensor)
atg_fractional_max_pool3d :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, output_size_data: *i64, output_size_len: i32, random_samples: Tensor)
atg_fractional_max_pool3d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, output_size_data: *i64, output_size_len: i32, indices: Tensor)
atg_fractional_max_pool3d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, output_size_data: *i64, output_size_len: i32, indices: Tensor)
atg_fractional_max_pool3d_output :: extern proc(out__: *Tensor, output: Tensor, indices: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, output_size_data: *i64, output_size_len: i32, random_samples: Tensor)
atg_frexp :: extern proc(out__: *Tensor, self: Tensor)
atg_frexp_tensor_out :: extern proc(out__: *Tensor, mantissa: Tensor, exponent: Tensor, self: Tensor)
atg_frobenius_norm :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_frobenius_norm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_from_file :: extern proc(out__: *Tensor, filename_ptr: *u8, filename_len: i32, shared: bool, size_v: i64, size_null: u8, options_kind: i32, options_device: i32)
atg_from_file_out :: extern proc(out__: *Tensor, out: Tensor, filename_ptr: *u8, filename_len: i32, shared: bool, size_v: i64, size_null: u8)
atg_full :: extern proc(out__: *Tensor, size_data: *i64, size_len: i32, fill_value: Scalar, options_kind: i32, options_device: i32)
atg_full_like :: extern proc(out__: *Tensor, self: Tensor, fill_value: Scalar)
atg_full_like_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, fill_value: Scalar)
atg_full_out :: extern proc(out__: *Tensor, out: Tensor, size_data: *i64, size_len: i32, fill_value: Scalar)
atg_fused_moving_avg_obs_fake_quant :: extern proc(out__: *Tensor, self: Tensor, observer_on: Tensor, fake_quant_on: Tensor, running_min: Tensor, running_max: Tensor, scale: Tensor, zero_point: Tensor, averaging_const: f64, quant_min: i64, quant_max: i64, ch_axis: i64, per_row_fake_quant: bool, symmetric_quant: bool)
atg_gather :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, sparse_grad: bool)
atg_gather_backward :: extern proc(out__: *Tensor, grad: Tensor, self: Tensor, dim: i64, index: Tensor, sparse_grad: bool)
atg_gather_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, index: Tensor, sparse_grad: bool)
atg_gcd :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_gcd_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_gcd_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_ge :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_ge_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_ge_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_ge_tensor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_ge_tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_ge_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_gelu :: extern proc(out__: *Tensor, self: Tensor, approximate_ptr: *u8, approximate_len: i32)
atg_gelu_ :: extern proc(out__: *Tensor, self: Tensor, approximate_ptr: *u8, approximate_len: i32)
atg_gelu_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, approximate_ptr: *u8, approximate_len: i32)
atg_gelu_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, approximate_ptr: *u8, approximate_len: i32)
atg_gelu_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, approximate_ptr: *u8, approximate_len: i32)
atg_geometric :: extern proc(out__: *Tensor, self: Tensor, p: f64)
atg_geometric_ :: extern proc(out__: *Tensor, self: Tensor, p: f64)
atg_geometric_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, p: f64)
atg_geqrf :: extern proc(out__: *Tensor, self: Tensor)
atg_geqrf_a :: extern proc(out__: *Tensor, a: Tensor, tau: Tensor, self: Tensor)
atg_ger :: extern proc(out__: *Tensor, self: Tensor, vec2: Tensor)
atg_ger_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, vec2: Tensor)
atg_glu :: extern proc(out__: *Tensor, self: Tensor, dim: i64)
atg_glu_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, dim: i64)
atg_glu_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, dim: i64)
atg_glu_backward_jvp :: extern proc(out__: *Tensor, grad_x: Tensor, grad_glu: Tensor, x: Tensor, dgrad_glu: Tensor, dx: Tensor, dim: i64)
atg_glu_backward_jvp_out :: extern proc(out__: *Tensor, out: Tensor, grad_x: Tensor, grad_glu: Tensor, x: Tensor, dgrad_glu: Tensor, dx: Tensor, dim: i64)
atg_glu_jvp :: extern proc(out__: *Tensor, glu: Tensor, x: Tensor, dx: Tensor, dim: i64)
atg_glu_jvp_out :: extern proc(out__: *Tensor, out: Tensor, glu: Tensor, x: Tensor, dx: Tensor, dim: i64)
atg_glu_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64)
atg_grad :: extern proc(out__: *Tensor, self: Tensor)
atg_greater :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_greater_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_greater_equal :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_greater_equal_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_greater_equal_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_greater_equal_tensor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_greater_equal_tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_greater_equal_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_greater_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_greater_tensor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_greater_tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_greater_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_grid_sampler :: extern proc(out__: *Tensor, input: Tensor, grid: Tensor, interpolation_mode: i64, padding_mode: i64, align_corners: bool)
atg_grid_sampler_2d :: extern proc(out__: *Tensor, input: Tensor, grid: Tensor, interpolation_mode: i64, padding_mode: i64, align_corners: bool)
atg_grid_sampler_2d_out :: extern proc(out__: *Tensor, out: Tensor, input: Tensor, grid: Tensor, interpolation_mode: i64, padding_mode: i64, align_corners: bool)
atg_grid_sampler_3d :: extern proc(out__: *Tensor, input: Tensor, grid: Tensor, interpolation_mode: i64, padding_mode: i64, align_corners: bool)
atg_grid_sampler_3d_out :: extern proc(out__: *Tensor, out: Tensor, input: Tensor, grid: Tensor, interpolation_mode: i64, padding_mode: i64, align_corners: bool)
atg_group_norm :: extern proc(out__: *Tensor, input: Tensor, num_groups: i64, weight: Tensor, bias: Tensor, eps: f64, cudnn_enabled: bool)
atg_gru :: extern proc(out__: *Tensor, input: Tensor, hx: Tensor, params_data: *Tensor, params_len: i32, has_biases: bool, num_layers: i64, dropout: f64, train: bool, bidirectional: bool, batch_first: bool)
atg_gru_cell :: extern proc(out__: *Tensor, input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor)
atg_gru_data :: extern proc(out__: *Tensor, data: Tensor, batch_sizes: Tensor, hx: Tensor, params_data: *Tensor, params_len: i32, has_biases: bool, num_layers: i64, dropout: f64, train: bool, bidirectional: bool)
atg_gt :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_gt_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_gt_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_gt_tensor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_gt_tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_gt_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_hamming_window :: extern proc(out__: *Tensor, window_length: i64, options_kind: i32, options_device: i32)
atg_hamming_window_out :: extern proc(out__: *Tensor, out: Tensor, window_length: i64)
atg_hamming_window_periodic :: extern proc(out__: *Tensor, window_length: i64, periodic: bool, options_kind: i32, options_device: i32)
atg_hamming_window_periodic_alpha :: extern proc(out__: *Tensor, window_length: i64, periodic: bool, alpha: f64, options_kind: i32, options_device: i32)
atg_hamming_window_periodic_alpha_beta :: extern proc(out__: *Tensor, window_length: i64, periodic: bool, alpha: f64, beta: f64, options_kind: i32, options_device: i32)
atg_hamming_window_periodic_alpha_beta_out :: extern proc(out__: *Tensor, out: Tensor, window_length: i64, periodic: bool, alpha: f64, beta: f64)
atg_hamming_window_periodic_alpha_out :: extern proc(out__: *Tensor, out: Tensor, window_length: i64, periodic: bool, alpha: f64)
atg_hamming_window_periodic_out :: extern proc(out__: *Tensor, out: Tensor, window_length: i64, periodic: bool)
atg_hann_window :: extern proc(out__: *Tensor, window_length: i64, options_kind: i32, options_device: i32)
atg_hann_window_out :: extern proc(out__: *Tensor, out: Tensor, window_length: i64)
atg_hann_window_periodic :: extern proc(out__: *Tensor, window_length: i64, periodic: bool, options_kind: i32, options_device: i32)
atg_hann_window_periodic_out :: extern proc(out__: *Tensor, out: Tensor, window_length: i64, periodic: bool)
atg_hardshrink :: extern proc(out__: *Tensor, self: Tensor)
atg_hardshrink_backward :: extern proc(out__: *Tensor, grad_out: Tensor, self: Tensor, lambd: Scalar)
atg_hardshrink_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_out: Tensor, self: Tensor, lambd: Scalar)
atg_hardshrink_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_hardsigmoid :: extern proc(out__: *Tensor, self: Tensor)
atg_hardsigmoid_ :: extern proc(out__: *Tensor, self: Tensor)
atg_hardsigmoid_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor)
atg_hardsigmoid_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor)
atg_hardsigmoid_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_hardswish :: extern proc(out__: *Tensor, self: Tensor)
atg_hardswish_ :: extern proc(out__: *Tensor, self: Tensor)
atg_hardswish_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor)
atg_hardswish_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, self: Tensor)
atg_hardswish_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_hardtanh :: extern proc(out__: *Tensor, self: Tensor)
atg_hardtanh_ :: extern proc(out__: *Tensor, self: Tensor)
atg_hardtanh_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, min_val: Scalar, max_val: Scalar)
atg_hardtanh_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, min_val: Scalar, max_val: Scalar)
atg_hardtanh_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_hash_tensor :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool, mode: i64)
atg_hash_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool, mode: i64)
atg_heaviside :: extern proc(out__: *Tensor, self: Tensor, values: Tensor)
atg_heaviside_ :: extern proc(out__: *Tensor, self: Tensor, values: Tensor)
atg_heaviside_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, values: Tensor)
atg_hinge_embedding_loss :: extern proc(out__: *Tensor, self: Tensor, target: Tensor, margin: f64, reduction: i64)
atg_histc :: extern proc(out__: *Tensor, self: Tensor, bins: i64)
atg_histc_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, bins: i64)
atg_histogram :: extern proc(out__: *Tensor, self: Tensor, bins: Tensor, weight: Tensor, density: bool)
atg_histogram_bin_ct :: extern proc(out__: *Tensor, self: Tensor, bins: i64, range_data: *f64, range_len: i32, weight: Tensor, density: bool)
atg_histogram_bin_ct_out :: extern proc(out__: *Tensor, hist: Tensor, bin_edges: Tensor, self: Tensor, bins: i64, range_data: *f64, range_len: i32, weight: Tensor, density: bool)
atg_histogram_bins_tensor_out :: extern proc(out__: *Tensor, hist: Tensor, bin_edges: Tensor, self: Tensor, bins: Tensor, weight: Tensor, density: bool)
atg_hsplit :: extern fn(self: Tensor, sections: i64) *Tensor
atg_hsplit_array :: extern fn(self: Tensor, indices_data: *i64, indices_len: i32) *Tensor
atg_hspmm :: extern proc(out__: *Tensor, mat1: Tensor, mat2: Tensor)
atg_hspmm_out :: extern proc(out__: *Tensor, out: Tensor, mat1: Tensor, mat2: Tensor)
atg_hstack :: extern proc(out__: *Tensor, tensors_data: *Tensor, tensors_len: i32)
atg_hstack_out :: extern proc(out__: *Tensor, out: Tensor, tensors_data: *Tensor, tensors_len: i32)
atg_huber_loss :: extern proc(out__: *Tensor, self: Tensor, target: Tensor, reduction: i64, delta: f64)
atg_huber_loss_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, target: Tensor, reduction: i64, delta: f64)
atg_huber_loss_backward_out :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, target: Tensor, reduction: i64, delta: f64)
atg_huber_loss_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, target: Tensor, reduction: i64, delta: f64)
atg_hypot :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_hypot_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_hypot_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_i0 :: extern proc(out__: *Tensor, self: Tensor)
atg_i0_ :: extern proc(out__: *Tensor, self: Tensor)
atg_i0_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_igamma :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_igamma_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_igamma_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_igammac :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_igammac_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_igammac_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_im2col :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, dilation_data: *i64, dilation_len: i32, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32)
atg_im2col_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, dilation_data: *i64, dilation_len: i32, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32)
atg_imag :: extern proc(out__: *Tensor, self: Tensor)
atg_index :: extern proc(out__: *Tensor, self: Tensor, indices_data: *Tensor, indices_len: i32)
atg_index_add :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, source: Tensor)
atg_index_add_ :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, source: Tensor)
atg_index_add_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, index: Tensor, source: Tensor)
atg_index_copy :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, source: Tensor)
atg_index_copy_ :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, source: Tensor)
atg_index_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, index: Tensor, source: Tensor)
atg_index_fill :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, value: Scalar)
atg_index_fill_ :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, value: Scalar)
atg_index_fill_int_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, index: Tensor, value: Scalar)
atg_index_fill_int_tensor :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, value: Tensor)
atg_index_fill_int_tensor_ :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, value: Tensor)
atg_index_fill_int_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, index: Tensor, value: Tensor)
atg_index_put :: extern proc(out__: *Tensor, self: Tensor, indices_data: *Tensor, indices_len: i32, values: Tensor, accumulate: bool)
atg_index_put_ :: extern proc(out__: *Tensor, self: Tensor, indices_data: *Tensor, indices_len: i32, values: Tensor, accumulate: bool)
atg_index_put_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, indices_data: *Tensor, indices_len: i32, values: Tensor, accumulate: bool)
atg_index_reduce :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, source: Tensor, reduce_ptr: *u8, reduce_len: i32, include_self: bool)
atg_index_reduce_ :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, source: Tensor, reduce_ptr: *u8, reduce_len: i32, include_self: bool)
atg_index_reduce_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, index: Tensor, source: Tensor, reduce_ptr: *u8, reduce_len: i32, include_self: bool)
atg_index_select :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor)
atg_index_select_backward :: extern proc(out__: *Tensor, grad: Tensor, self_sizes_data: *i64, self_sizes_len: i32, dim: i64, index: Tensor)
atg_index_select_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, index: Tensor)
atg_index_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, indices_data: *Tensor, indices_len: i32)
atg_indices :: extern proc(out__: *Tensor, self: Tensor)
atg_indices_copy :: extern proc(out__: *Tensor, self: Tensor)
atg_indices_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_infinitely_differentiable_gelu_backward :: extern proc(out__: *Tensor, grad: Tensor, self: Tensor)
atg_inner :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_inner_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_instance_norm :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, use_input_stats: bool, momentum: f64, eps: f64, cudnn_enabled: bool)
atg_int_repr :: extern proc(out__: *Tensor, self: Tensor)
atg_int_repr_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_inverse :: extern proc(out__: *Tensor, self: Tensor)
atg_inverse_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_is_coalesced :: extern fn(self: Tensor) bool
atg_is_complex :: extern fn(self: Tensor) bool
atg_is_conj :: extern fn(self: Tensor) bool
atg_is_distributed :: extern fn(self: Tensor) bool
atg_is_floating_point :: extern fn(self: Tensor) bool
atg_is_inference :: extern fn(self: Tensor) bool
atg_is_leaf :: extern fn(self: Tensor) bool
atg_is_neg :: extern fn(self: Tensor) bool
atg_is_nonzero :: extern fn(self: Tensor) bool
atg_is_pinned :: extern fn(self: Tensor, device: i32) bool
atg_is_same_size :: extern fn(self: Tensor, other: Tensor) bool
atg_is_set_to :: extern fn(self: Tensor, tensor_: Tensor) bool
atg_is_signed :: extern fn(self: Tensor) bool
atg_is_vulkan_available :: extern fn() bool
atg_isclose :: extern proc(out__: *Tensor, self: Tensor, other: Tensor, rtol: f64, atol: f64, equal_nan: bool)
atg_isfinite :: extern proc(out__: *Tensor, self: Tensor)
atg_isin :: extern proc(out__: *Tensor, elements: Tensor, test_elements: Tensor, assume_unique: bool, invert: bool)
atg_isin_scalar_tensor :: extern proc(out__: *Tensor, element: Scalar, test_elements: Tensor, assume_unique: bool, invert: bool)
atg_isin_scalar_tensor_out :: extern proc(out__: *Tensor, out: Tensor, element: Scalar, test_elements: Tensor, assume_unique: bool, invert: bool)
atg_isin_tensor_scalar :: extern proc(out__: *Tensor, elements: Tensor, test_element: Scalar, assume_unique: bool, invert: bool)
atg_isin_tensor_scalar_out :: extern proc(out__: *Tensor, out: Tensor, elements: Tensor, test_element: Scalar, assume_unique: bool, invert: bool)
atg_isin_tensor_tensor_out :: extern proc(out__: *Tensor, out: Tensor, elements: Tensor, test_elements: Tensor, assume_unique: bool, invert: bool)
atg_isinf :: extern proc(out__: *Tensor, self: Tensor)
atg_isinf_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_isnan :: extern proc(out__: *Tensor, self: Tensor)
atg_isnan_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_isneginf :: extern proc(out__: *Tensor, self: Tensor)
atg_isneginf_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_isposinf :: extern proc(out__: *Tensor, self: Tensor)
atg_isposinf_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_isreal :: extern proc(out__: *Tensor, self: Tensor)
atg_istft :: extern proc(out__: *Tensor, self: Tensor, n_fft: i64, hop_length_v: i64, hop_length_null: u8, win_length_v: i64, win_length_null: u8, window: Tensor, center: bool, normalized: bool, onesided: bool, length_v: i64, length_null: u8, return_complex: bool)
atg_kaiser_window :: extern proc(out__: *Tensor, window_length: i64, options_kind: i32, options_device: i32)
atg_kaiser_window_beta :: extern proc(out__: *Tensor, window_length: i64, periodic: bool, beta: f64, options_kind: i32, options_device: i32)
atg_kaiser_window_beta_out :: extern proc(out__: *Tensor, out: Tensor, window_length: i64, periodic: bool, beta: f64)
atg_kaiser_window_out :: extern proc(out__: *Tensor, out: Tensor, window_length: i64)
atg_kaiser_window_periodic :: extern proc(out__: *Tensor, window_length: i64, periodic: bool, options_kind: i32, options_device: i32)
atg_kaiser_window_periodic_out :: extern proc(out__: *Tensor, out: Tensor, window_length: i64, periodic: bool)
atg_kl_div :: extern proc(out__: *Tensor, self: Tensor, target: Tensor, reduction: i64, log_target: bool)
atg_kron :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_kron_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_kthvalue :: extern proc(out__: *Tensor, self: Tensor, k: i64, dim: i64, keepdim: bool)
atg_kthvalue_values :: extern proc(out__: *Tensor, values: Tensor, indices: Tensor, self: Tensor, k: i64, dim: i64, keepdim: bool)
atg_l1_loss :: extern proc(out__: *Tensor, self: Tensor, target: Tensor, reduction: i64)
atg_layer_norm :: extern proc(out__: *Tensor, input: Tensor, normalized_shape_data: *i64, normalized_shape_len: i32, weight: Tensor, bias: Tensor, eps: f64, cudnn_enable: bool)
atg_lcm :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_lcm_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_lcm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_ldexp :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_ldexp_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_ldexp_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_le :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_le_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_le_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_le_tensor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_le_tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_le_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_leaky_relu :: extern proc(out__: *Tensor, self: Tensor)
atg_leaky_relu_ :: extern proc(out__: *Tensor, self: Tensor)
atg_leaky_relu_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, negative_slope: Scalar, self_is_result: bool)
atg_leaky_relu_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, negative_slope: Scalar, self_is_result: bool)
atg_leaky_relu_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_lerp :: extern proc(out__: *Tensor, self: Tensor, end: Tensor, weight: Scalar)
atg_lerp_ :: extern proc(out__: *Tensor, self: Tensor, end: Tensor, weight: Scalar)
atg_lerp_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, end: Tensor, weight: Scalar)
atg_lerp_tensor :: extern proc(out__: *Tensor, self: Tensor, end: Tensor, weight: Tensor)
atg_lerp_tensor_ :: extern proc(out__: *Tensor, self: Tensor, end: Tensor, weight: Tensor)
atg_lerp_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, end: Tensor, weight: Tensor)
atg_less :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_less_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_less_equal :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_less_equal_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_less_equal_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_less_equal_tensor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_less_equal_tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_less_equal_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_less_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_less_tensor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_less_tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_less_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_lgamma :: extern proc(out__: *Tensor, self: Tensor)
atg_lgamma_ :: extern proc(out__: *Tensor, self: Tensor)
atg_lgamma_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_lift :: extern proc(out__: *Tensor, self: Tensor)
atg_lift_fresh :: extern proc(out__: *Tensor, self: Tensor)
atg_lift_fresh_copy :: extern proc(out__: *Tensor, self: Tensor)
atg_lift_fresh_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_lift_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_linalg_cholesky :: extern proc(out__: *Tensor, self: Tensor, upper: bool)
atg_linalg_cholesky_ex :: extern proc(out__: *Tensor, self: Tensor, upper: bool, check_errors: bool)
atg_linalg_cholesky_ex_l :: extern proc(out__: *Tensor, L: Tensor, info: Tensor, self: Tensor, upper: bool, check_errors: bool)
atg_linalg_cholesky_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, upper: bool)
atg_linalg_cond :: extern proc(out__: *Tensor, self: Tensor, p: Scalar)
atg_linalg_cond_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, p: Scalar)
atg_linalg_cond_p_str :: extern proc(out__: *Tensor, self: Tensor, p_ptr: *u8, p_len: i32)
atg_linalg_cond_p_str_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, p_ptr: *u8, p_len: i32)
atg_linalg_cross :: extern proc(out__: *Tensor, self: Tensor, other: Tensor, dim: i64)
atg_linalg_cross_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor, dim: i64)
atg_linalg_det :: extern proc(out__: *Tensor, A: Tensor)
atg_linalg_det_out :: extern proc(out__: *Tensor, out: Tensor, A: Tensor)
atg_linalg_diagonal :: extern proc(out__: *Tensor, A: Tensor, offset: i64, dim1: i64, dim2: i64)
atg_linalg_eig :: extern proc(out__: *Tensor, self: Tensor)
atg_linalg_eig_out :: extern proc(out__: *Tensor, eigenvalues: Tensor, eigenvectors: Tensor, self: Tensor)
atg_linalg_eigh :: extern proc(out__: *Tensor, self: Tensor, UPLO_ptr: *u8, UPLO_len: i32)
atg_linalg_eigh_eigvals :: extern proc(out__: *Tensor, eigvals: Tensor, eigvecs: Tensor, self: Tensor, UPLO_ptr: *u8, UPLO_len: i32)
atg_linalg_eigvals :: extern proc(out__: *Tensor, self: Tensor)
atg_linalg_eigvals_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_linalg_eigvalsh :: extern proc(out__: *Tensor, self: Tensor, UPLO_ptr: *u8, UPLO_len: i32)
atg_linalg_eigvalsh_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, UPLO_ptr: *u8, UPLO_len: i32)
atg_linalg_householder_product :: extern proc(out__: *Tensor, input: Tensor, tau: Tensor)
atg_linalg_householder_product_out :: extern proc(out__: *Tensor, out: Tensor, input: Tensor, tau: Tensor)
atg_linalg_inv :: extern proc(out__: *Tensor, A: Tensor)
atg_linalg_inv_ex :: extern proc(out__: *Tensor, A: Tensor, check_errors: bool)
atg_linalg_inv_ex_inverse :: extern proc(out__: *Tensor, inverse: Tensor, info: Tensor, A: Tensor, check_errors: bool)
atg_linalg_inv_out :: extern proc(out__: *Tensor, out: Tensor, A: Tensor)
atg_linalg_ldl_factor :: extern proc(out__: *Tensor, self: Tensor, hermitian: bool)
atg_linalg_ldl_factor_ex :: extern proc(out__: *Tensor, self: Tensor, hermitian: bool, check_errors: bool)
atg_linalg_ldl_factor_ex_out :: extern proc(out__: *Tensor, LD: Tensor, pivots: Tensor, info: Tensor, self: Tensor, hermitian: bool, check_errors: bool)
atg_linalg_ldl_factor_out :: extern proc(out__: *Tensor, LD: Tensor, pivots: Tensor, self: Tensor, hermitian: bool)
atg_linalg_ldl_solve :: extern proc(out__: *Tensor, LD: Tensor, pivots: Tensor, B: Tensor, hermitian: bool)
atg_linalg_ldl_solve_out :: extern proc(out__: *Tensor, out: Tensor, LD: Tensor, pivots: Tensor, B: Tensor, hermitian: bool)
atg_linalg_lstsq :: extern proc(out__: *Tensor, self: Tensor, b: Tensor, rcond_v: f64, rcond_null: u8, driver_ptr: *u8, driver_len: i32)
atg_linalg_lstsq_out :: extern proc(out__: *Tensor, solution: Tensor, residuals: Tensor, rank: Tensor, singular_values: Tensor, self: Tensor, b: Tensor, rcond_v: f64, rcond_null: u8, driver_ptr: *u8, driver_len: i32)
atg_linalg_lu :: extern proc(out__: *Tensor, A: Tensor, pivot: bool)
atg_linalg_lu_factor :: extern proc(out__: *Tensor, A: Tensor, pivot: bool)
atg_linalg_lu_factor_ex :: extern proc(out__: *Tensor, A: Tensor, pivot: bool, check_errors: bool)
atg_linalg_lu_factor_ex_out :: extern proc(out__: *Tensor, LU: Tensor, pivots: Tensor, info: Tensor, A: Tensor, pivot: bool, check_errors: bool)
atg_linalg_lu_factor_out :: extern proc(out__: *Tensor, LU: Tensor, pivots: Tensor, A: Tensor, pivot: bool)
atg_linalg_lu_out :: extern proc(out__: *Tensor, P: Tensor, L: Tensor, U: Tensor, A: Tensor, pivot: bool)
atg_linalg_lu_solve :: extern proc(out__: *Tensor, LU: Tensor, pivots: Tensor, B: Tensor, left: bool, adjoint: bool)
atg_linalg_lu_solve_out :: extern proc(out__: *Tensor, out: Tensor, LU: Tensor, pivots: Tensor, B: Tensor, left: bool, adjoint: bool)
atg_linalg_matmul :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_linalg_matmul_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_linalg_matrix_exp :: extern proc(out__: *Tensor, self: Tensor)
atg_linalg_matrix_exp_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_linalg_matrix_power :: extern proc(out__: *Tensor, self: Tensor, n: i64)
atg_linalg_matrix_power_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, n: i64)
atg_linalg_matrix_rank :: extern proc(out__: *Tensor, self: Tensor, tol: f64, hermitian: bool)
atg_linalg_matrix_rank_atol_rtol_float :: extern proc(out__: *Tensor, self: Tensor, atol_v: f64, atol_null: u8, rtol_v: f64, rtol_null: u8, hermitian: bool)
atg_linalg_matrix_rank_atol_rtol_float_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, atol_v: f64, atol_null: u8, rtol_v: f64, rtol_null: u8, hermitian: bool)
atg_linalg_matrix_rank_atol_rtol_tensor :: extern proc(out__: *Tensor, input: Tensor, atol: Tensor, rtol: Tensor, hermitian: bool)
atg_linalg_matrix_rank_atol_rtol_tensor_out :: extern proc(out__: *Tensor, out: Tensor, input: Tensor, atol: Tensor, rtol: Tensor, hermitian: bool)
atg_linalg_matrix_rank_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, tol: f64, hermitian: bool)
atg_linalg_matrix_rank_out_tol_tensor :: extern proc(out__: *Tensor, out: Tensor, input: Tensor, tol: Tensor, hermitian: bool)
atg_linalg_matrix_rank_tol_tensor :: extern proc(out__: *Tensor, input: Tensor, tol: Tensor, hermitian: bool)
atg_linalg_multi_dot :: extern proc(out__: *Tensor, tensors_data: *Tensor, tensors_len: i32)
atg_linalg_multi_dot_out :: extern proc(out__: *Tensor, out: Tensor, tensors_data: *Tensor, tensors_len: i32)
atg_linalg_norm :: extern proc(out__: *Tensor, self: Tensor, ord: Scalar, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg_linalg_norm_ord_str :: extern proc(out__: *Tensor, self: Tensor, ord_ptr: *u8, ord_len: i32, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg_linalg_norm_ord_str_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, ord_ptr: *u8, ord_len: i32, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg_linalg_norm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, ord: Scalar, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg_linalg_pinv :: extern proc(out__: *Tensor, self: Tensor, rcond: f64, hermitian: bool)
atg_linalg_pinv_atol_rtol_float :: extern proc(out__: *Tensor, self: Tensor, atol_v: f64, atol_null: u8, rtol_v: f64, rtol_null: u8, hermitian: bool)
atg_linalg_pinv_atol_rtol_float_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, atol_v: f64, atol_null: u8, rtol_v: f64, rtol_null: u8, hermitian: bool)
atg_linalg_pinv_atol_rtol_tensor :: extern proc(out__: *Tensor, self: Tensor, atol: Tensor, rtol: Tensor, hermitian: bool)
atg_linalg_pinv_atol_rtol_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, atol: Tensor, rtol: Tensor, hermitian: bool)
atg_linalg_pinv_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, rcond: f64, hermitian: bool)
atg_linalg_pinv_out_rcond_tensor :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, rcond: Tensor, hermitian: bool)
atg_linalg_pinv_rcond_tensor :: extern proc(out__: *Tensor, self: Tensor, rcond: Tensor, hermitian: bool)
atg_linalg_qr :: extern proc(out__: *Tensor, A: Tensor, mode_ptr: *u8, mode_len: i32)
atg_linalg_qr_out :: extern proc(out__: *Tensor, Q: Tensor, R: Tensor, A: Tensor, mode_ptr: *u8, mode_len: i32)
atg_linalg_slogdet :: extern proc(out__: *Tensor, A: Tensor)
atg_linalg_slogdet_out :: extern proc(out__: *Tensor, sign: Tensor, logabsdet: Tensor, A: Tensor)
atg_linalg_solve :: extern proc(out__: *Tensor, A: Tensor, B: Tensor, left: bool)
atg_linalg_solve_ex :: extern proc(out__: *Tensor, A: Tensor, B: Tensor, left: bool, check_errors: bool)
atg_linalg_solve_ex_out :: extern proc(out__: *Tensor, result: Tensor, info: Tensor, A: Tensor, B: Tensor, left: bool, check_errors: bool)
atg_linalg_solve_out :: extern proc(out__: *Tensor, out: Tensor, A: Tensor, B: Tensor, left: bool)
atg_linalg_solve_triangular :: extern proc(out__: *Tensor, self: Tensor, B: Tensor, upper: bool, left: bool, unitriangular: bool)
atg_linalg_solve_triangular_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, B: Tensor, upper: bool, left: bool, unitriangular: bool)
atg_linalg_svd :: extern proc(out__: *Tensor, A: Tensor, full_matrices: bool, driver_ptr: *u8, driver_len: i32)
atg_linalg_svd_u :: extern proc(out__: *Tensor, U: Tensor, S: Tensor, Vh: Tensor, A: Tensor, full_matrices: bool, driver_ptr: *u8, driver_len: i32)
atg_linalg_svdvals :: extern proc(out__: *Tensor, A: Tensor, driver_ptr: *u8, driver_len: i32)
atg_linalg_svdvals_out :: extern proc(out__: *Tensor, out: Tensor, A: Tensor, driver_ptr: *u8, driver_len: i32)
atg_linalg_tensorinv :: extern proc(out__: *Tensor, self: Tensor, ind: i64)
atg_linalg_tensorinv_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, ind: i64)
atg_linalg_tensorsolve :: extern proc(out__: *Tensor, self: Tensor, other: Tensor, dims_data: *i64, dims_len: i32)
atg_linalg_tensorsolve_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor, dims_data: *i64, dims_len: i32)
atg_linalg_vander :: extern proc(out__: *Tensor, x: Tensor, n_v: i64, n_null: u8)
atg_linalg_vecdot :: extern proc(out__: *Tensor, x: Tensor, y: Tensor, dim: i64)
atg_linalg_vecdot_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, y: Tensor, dim: i64)
atg_linear :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor)
atg_linear_out :: extern proc(out__: *Tensor, out: Tensor, input: Tensor, weight: Tensor, bias: Tensor)
atg_linspace :: extern proc(out__: *Tensor, start: Scalar, end: Scalar, steps: i64, options_kind: i32, options_device: i32)
atg_linspace_out :: extern proc(out__: *Tensor, out: Tensor, start: Scalar, end: Scalar, steps: i64)
atg_linspace_scalar_tensor :: extern proc(out__: *Tensor, start: Scalar, end: Tensor, steps: i64, options_kind: i32, options_device: i32)
atg_linspace_scalar_tensor_out :: extern proc(out__: *Tensor, out: Tensor, start: Scalar, end: Tensor, steps: i64)
atg_linspace_tensor_scalar :: extern proc(out__: *Tensor, start: Tensor, end: Scalar, steps: i64, options_kind: i32, options_device: i32)
atg_linspace_tensor_scalar_out :: extern proc(out__: *Tensor, out: Tensor, start: Tensor, end: Scalar, steps: i64)
atg_linspace_tensor_tensor :: extern proc(out__: *Tensor, start: Tensor, end: Tensor, steps: i64, options_kind: i32, options_device: i32)
atg_linspace_tensor_tensor_out :: extern proc(out__: *Tensor, out: Tensor, start: Tensor, end: Tensor, steps: i64)
atg_log :: extern proc(out__: *Tensor, self: Tensor)
atg_log10 :: extern proc(out__: *Tensor, self: Tensor)
atg_log10_ :: extern proc(out__: *Tensor, self: Tensor)
atg_log10_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_log1p :: extern proc(out__: *Tensor, self: Tensor)
atg_log1p_ :: extern proc(out__: *Tensor, self: Tensor)
atg_log1p_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_log2 :: extern proc(out__: *Tensor, self: Tensor)
atg_log2_ :: extern proc(out__: *Tensor, self: Tensor)
atg_log2_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_log_ :: extern proc(out__: *Tensor, self: Tensor)
atg_log_normal :: extern proc(out__: *Tensor, self: Tensor, mean: f64, std: f64)
atg_log_normal_ :: extern proc(out__: *Tensor, self: Tensor, mean: f64, std: f64)
atg_log_normal_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mean: f64, std: f64)
atg_log_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_log_sigmoid :: extern proc(out__: *Tensor, self: Tensor)
atg_log_sigmoid_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, buffer: Tensor)
atg_log_sigmoid_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, buffer: Tensor)
atg_log_sigmoid_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_log_softmax :: extern proc(out__: *Tensor, self: Tensor, dim: i64, dtype: i32)
atg_log_softmax_int_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, dtype: i32)
atg_logaddexp :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_logaddexp2 :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_logaddexp2_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_logaddexp_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_logcumsumexp :: extern proc(out__: *Tensor, self: Tensor, dim: i64)
atg_logcumsumexp_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64)
atg_logdet :: extern proc(out__: *Tensor, self: Tensor)
atg_logical_and :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_logical_and_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_logical_and_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_logical_not :: extern proc(out__: *Tensor, self: Tensor)
atg_logical_not_ :: extern proc(out__: *Tensor, self: Tensor)
atg_logical_not_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_logical_or :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_logical_or_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_logical_or_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_logical_xor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_logical_xor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_logical_xor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_logit :: extern proc(out__: *Tensor, self: Tensor, eps_v: f64, eps_null: u8)
atg_logit_ :: extern proc(out__: *Tensor, self: Tensor, eps_v: f64, eps_null: u8)
atg_logit_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, eps_v: f64, eps_null: u8)
atg_logit_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, eps_v: f64, eps_null: u8)
atg_logit_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, eps_v: f64, eps_null: u8)
atg_logspace :: extern proc(out__: *Tensor, start: Scalar, end: Scalar, steps: i64, base: f64, options_kind: i32, options_device: i32)
atg_logspace_out :: extern proc(out__: *Tensor, out: Tensor, start: Scalar, end: Scalar, steps: i64, base: f64)
atg_logspace_scalar_tensor :: extern proc(out__: *Tensor, start: Scalar, end: Tensor, steps: i64, base: f64, options_kind: i32, options_device: i32)
atg_logspace_scalar_tensor_out :: extern proc(out__: *Tensor, out: Tensor, start: Scalar, end: Tensor, steps: i64, base: f64)
atg_logspace_tensor_scalar :: extern proc(out__: *Tensor, start: Tensor, end: Scalar, steps: i64, base: f64, options_kind: i32, options_device: i32)
atg_logspace_tensor_scalar_out :: extern proc(out__: *Tensor, out: Tensor, start: Tensor, end: Scalar, steps: i64, base: f64)
atg_logspace_tensor_tensor :: extern proc(out__: *Tensor, start: Tensor, end: Tensor, steps: i64, base: f64, options_kind: i32, options_device: i32)
atg_logspace_tensor_tensor_out :: extern proc(out__: *Tensor, out: Tensor, start: Tensor, end: Tensor, steps: i64, base: f64)
atg_logsumexp :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_logsumexp_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_lstm :: extern proc(out__: *Tensor, input: Tensor, hx_data: *Tensor, hx_len: i32, params_data: *Tensor, params_len: i32, has_biases: bool, num_layers: i64, dropout: f64, train: bool, bidirectional: bool, batch_first: bool)
atg_lstm_cell :: extern proc(out__: *Tensor, input: Tensor, hx_data: *Tensor, hx_len: i32, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor)
atg_lstm_data :: extern proc(out__: *Tensor, data: Tensor, batch_sizes: Tensor, hx_data: *Tensor, hx_len: i32, params_data: *Tensor, params_len: i32, has_biases: bool, num_layers: i64, dropout: f64, train: bool, bidirectional: bool)
atg_lstm_mps_backward :: extern proc(out0: Tensor, out1_data: *Tensor, out1_len: i32, out2_data: *Tensor, out2_len: i32, grad_y: Tensor, grad_hy: Tensor, grad_cy: Tensor, z_state: Tensor, cell_state_fwd: Tensor, input: Tensor, layersOutputs: Tensor, hx_data: *Tensor, hx_len: i32, params_data: *Tensor, params_len: i32, has_biases: bool, num_layers: i64, dropout: f64, train: bool, bidirectional: bool, batch_first: bool)
atg_lt :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_lt_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_lt_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_lt_tensor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_lt_tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_lt_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_lu_solve :: extern proc(out__: *Tensor, self: Tensor, LU_data: Tensor, LU_pivots: Tensor)
atg_lu_solve_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, LU_data: Tensor, LU_pivots: Tensor)
atg_lu_unpack :: extern proc(out__: *Tensor, LU_data: Tensor, LU_pivots: Tensor, unpack_data: bool, unpack_pivots: bool)
atg_lu_unpack_out :: extern proc(out__: *Tensor, P: Tensor, L: Tensor, U: Tensor, LU_data: Tensor, LU_pivots: Tensor, unpack_data: bool, unpack_pivots: bool)
atg_margin_ranking_loss :: extern proc(out__: *Tensor, input1: Tensor, input2: Tensor, target: Tensor, margin: f64, reduction: i64)
atg_masked_fill :: extern proc(out__: *Tensor, self: Tensor, mask: Tensor, value: Scalar)
atg_masked_fill_ :: extern proc(out__: *Tensor, self: Tensor, mask: Tensor, value: Scalar)
atg_masked_fill_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mask: Tensor, value: Scalar)
atg_masked_fill_tensor :: extern proc(out__: *Tensor, self: Tensor, mask: Tensor, value: Tensor)
atg_masked_fill_tensor_ :: extern proc(out__: *Tensor, self: Tensor, mask: Tensor, value: Tensor)
atg_masked_fill_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mask: Tensor, value: Tensor)
atg_masked_scatter :: extern proc(out__: *Tensor, self: Tensor, mask: Tensor, source: Tensor)
atg_masked_scatter_ :: extern proc(out__: *Tensor, self: Tensor, mask: Tensor, source: Tensor)
atg_masked_scatter_backward :: extern proc(out__: *Tensor, grad_output: Tensor, mask: Tensor, sizes_data: *i64, sizes_len: i32)
atg_masked_scatter_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mask: Tensor, source: Tensor)
atg_masked_select :: extern proc(out__: *Tensor, self: Tensor, mask: Tensor)
atg_masked_select_backward :: extern proc(out__: *Tensor, grad: Tensor, input: Tensor, mask: Tensor)
atg_masked_select_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mask: Tensor)
atg_matmul :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_matmul_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_matrix_exp :: extern proc(out__: *Tensor, self: Tensor)
atg_matrix_exp_backward :: extern proc(out__: *Tensor, self: Tensor, grad: Tensor)
atg_matrix_h :: extern proc(out__: *Tensor, self: Tensor)
atg_matrix_power :: extern proc(out__: *Tensor, self: Tensor, n: i64)
atg_matrix_power_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, n: i64)
atg_max :: extern proc(out__: *Tensor, self: Tensor)
atg_max_dim :: extern proc(out__: *Tensor, self: Tensor, dim: i64, keepdim: bool)
atg_max_dim_max :: extern proc(out__: *Tensor, max: Tensor, max_values: Tensor, self: Tensor, dim: i64, keepdim: bool)
atg_max_other :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_max_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_max_pool1d :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_max_pool1d_with_indices :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_max_pool2d :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_max_pool2d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_max_pool2d_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_max_pool2d_with_indices :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_max_pool2d_with_indices_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool, indices: Tensor)
atg_max_pool2d_with_indices_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool, indices: Tensor)
atg_max_pool2d_with_indices_out :: extern proc(out__: *Tensor, out: Tensor, indices: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_max_pool3d :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_max_pool3d_with_indices :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_max_pool3d_with_indices_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool, indices: Tensor)
atg_max_pool3d_with_indices_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool, indices: Tensor)
atg_max_pool3d_with_indices_out :: extern proc(out__: *Tensor, out: Tensor, indices: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_max_unary_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_max_unpool2d :: extern proc(out__: *Tensor, self: Tensor, indices: Tensor, output_size_data: *i64, output_size_len: i32)
atg_max_unpool2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, indices: Tensor, output_size_data: *i64, output_size_len: i32)
atg_max_unpool3d :: extern proc(out__: *Tensor, self: Tensor, indices: Tensor, output_size_data: *i64, output_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32)
atg_max_unpool3d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, indices: Tensor, output_size_data: *i64, output_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32)
atg_maximum :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_maximum_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_mean :: extern proc(out__: *Tensor, self: Tensor, dtype: i32)
atg_mean_dim :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg_mean_dtype_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dtype: i32)
atg_mean_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg_median :: extern proc(out__: *Tensor, self: Tensor)
atg_median_dim :: extern proc(out__: *Tensor, self: Tensor, dim: i64, keepdim: bool)
atg_median_dim_values :: extern proc(out__: *Tensor, values: Tensor, indices: Tensor, self: Tensor, dim: i64, keepdim: bool)
atg_median_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_meshgrid :: extern fn(tensors_data: *Tensor, tensors_len: i32) *Tensor
atg_meshgrid_indexing :: extern fn(tensors_data: *Tensor, tensors_len: i32, indexing_ptr: *u8, indexing_len: i32) *Tensor
atg_mh :: extern proc(out__: *Tensor, self: Tensor)
atg_min :: extern proc(out__: *Tensor, self: Tensor)
atg_min_dim :: extern proc(out__: *Tensor, self: Tensor, dim: i64, keepdim: bool)
atg_min_dim_min :: extern proc(out__: *Tensor, min: Tensor, min_indices: Tensor, self: Tensor, dim: i64, keepdim: bool)
atg_min_other :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_min_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_min_unary_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_minimum :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_minimum_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_miopen_batch_norm :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, exponential_average_factor: f64, epsilon: f64)
atg_miopen_batch_norm_backward :: extern proc(out__: *Tensor, input: Tensor, grad_output: Tensor, weight: Tensor, running_mean: Tensor, running_var: Tensor, save_mean: Tensor, save_var: Tensor, epsilon: f64)
atg_miopen_batch_norm_backward_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, input: Tensor, grad_output: Tensor, weight: Tensor, running_mean: Tensor, running_var: Tensor, save_mean: Tensor, save_var: Tensor, epsilon: f64)
atg_miopen_batch_norm_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, exponential_average_factor: f64, epsilon: f64)
atg_miopen_convolution :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, bias: Tensor, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64, benchmark: bool, deterministic: bool)
atg_miopen_convolution_add_relu :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, z: Tensor, alpha: Scalar, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg_miopen_convolution_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, bias: Tensor, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64, benchmark: bool, deterministic: bool)
atg_miopen_convolution_relu :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg_miopen_convolution_transpose :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, bias: Tensor, padding_data: *i64, padding_len: i32, output_padding_data: *i64, output_padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64, benchmark: bool, deterministic: bool)
atg_miopen_convolution_transpose_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, bias: Tensor, padding_data: *i64, padding_len: i32, output_padding_data: *i64, output_padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64, benchmark: bool, deterministic: bool)
atg_miopen_depthwise_convolution :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, bias: Tensor, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64, benchmark: bool, deterministic: bool)
atg_miopen_depthwise_convolution_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, bias: Tensor, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64, benchmark: bool, deterministic: bool)
atg_miopen_rnn :: extern proc(out__: *Tensor, input: Tensor, weight_data: *Tensor, weight_len: i32, weight_stride0: i64, hx: Tensor, cx: Tensor, mode: i64, hidden_size: i64, num_layers: i64, batch_first: bool, dropout: f64, train: bool, bidirectional: bool, batch_sizes_data: *i64, batch_sizes_len: i32, dropout_state: Tensor)
atg_miopen_rnn_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, out3: Tensor, out4: Tensor, input: Tensor, weight_data: *Tensor, weight_len: i32, weight_stride0: i64, hx: Tensor, cx: Tensor, mode: i64, hidden_size: i64, num_layers: i64, batch_first: bool, dropout: f64, train: bool, bidirectional: bool, batch_sizes_data: *i64, batch_sizes_len: i32, dropout_state: Tensor)
atg_mish :: extern proc(out__: *Tensor, self: Tensor)
atg_mish_ :: extern proc(out__: *Tensor, self: Tensor)
atg_mish_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor)
atg_mish_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_mkldnn_adaptive_avg_pool2d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg_mkldnn_adaptive_avg_pool2d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor)
atg_mkldnn_adaptive_avg_pool2d_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, self: Tensor)
atg_mkldnn_adaptive_avg_pool2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32)
atg_mkldnn_convolution :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, bias: Tensor, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg_mkldnn_convolution_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, bias: Tensor, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64)
atg_mkldnn_linear :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, bias: Tensor)
atg_mkldnn_linear_backward_input :: extern proc(out__: *Tensor, input_size_data: *i64, input_size_len: i32, grad_output: Tensor, weight: Tensor)
atg_mkldnn_linear_backward_input_out :: extern proc(out__: *Tensor, out: Tensor, input_size_data: *i64, input_size_len: i32, grad_output: Tensor, weight: Tensor)
atg_mkldnn_linear_backward_weights :: extern proc(out__: *Tensor, grad_output: Tensor, input: Tensor, weight: Tensor, bias_defined: bool)
atg_mkldnn_linear_backward_weights_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, grad_output: Tensor, input: Tensor, weight: Tensor, bias_defined: bool)
atg_mkldnn_linear_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, bias: Tensor)
atg_mkldnn_max_pool2d :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_mkldnn_max_pool2d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output: Tensor, input: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_mkldnn_max_pool2d_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, output: Tensor, input: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_mkldnn_max_pool2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_mkldnn_max_pool3d :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_mkldnn_max_pool3d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output: Tensor, input: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_mkldnn_max_pool3d_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, output: Tensor, input: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_mkldnn_max_pool3d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_mkldnn_reorder_conv2d_weight :: extern proc(out__: *Tensor, self: Tensor, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64, input_size_data: *i64, input_size_len: i32)
atg_mkldnn_reorder_conv2d_weight_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64, input_size_data: *i64, input_size_len: i32)
atg_mkldnn_reorder_conv3d_weight :: extern proc(out__: *Tensor, self: Tensor, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64, input_size_data: *i64, input_size_len: i32)
atg_mkldnn_reorder_conv3d_weight_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, padding_data: *i64, padding_len: i32, stride_data: *i64, stride_len: i32, dilation_data: *i64, dilation_len: i32, groups: i64, input_size_data: *i64, input_size_len: i32)
atg_mkldnn_rnn_layer :: extern proc(out__: *Tensor, input: Tensor, weight0: Tensor, weight1: Tensor, weight2: Tensor, weight3: Tensor, hx_: Tensor, cx_: Tensor, reverse: bool, batch_sizes_data: *i64, batch_sizes_len: i32, mode: i64, hidden_size: i64, num_layers: i64, has_biases: bool, bidirectional: bool, batch_first: bool, train: bool)
atg_mkldnn_rnn_layer_backward :: extern proc(out__: *Tensor, input: Tensor, weight1: Tensor, weight2: Tensor, weight3: Tensor, weight4: Tensor, hx_: Tensor, cx_tmp: Tensor, output: Tensor, hy_: Tensor, cy_: Tensor, grad_output: Tensor, grad_hy: Tensor, grad_cy: Tensor, reverse: bool, mode: i64, hidden_size: i64, num_layers: i64, has_biases: bool, train: bool, bidirectional: bool, batch_sizes_data: *i64, batch_sizes_len: i32, batch_first: bool, workspace: Tensor)
atg_mkldnn_rnn_layer_backward_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, out3: Tensor, out4: Tensor, out5: Tensor, out6: Tensor, input: Tensor, weight1: Tensor, weight2: Tensor, weight3: Tensor, weight4: Tensor, hx_: Tensor, cx_tmp: Tensor, output: Tensor, hy_: Tensor, cy_: Tensor, grad_output: Tensor, grad_hy: Tensor, grad_cy: Tensor, reverse: bool, mode: i64, hidden_size: i64, num_layers: i64, has_biases: bool, train: bool, bidirectional: bool, batch_sizes_data: *i64, batch_sizes_len: i32, batch_first: bool, workspace: Tensor)
atg_mkldnn_rnn_layer_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, out3: Tensor, input: Tensor, weight0: Tensor, weight1: Tensor, weight2: Tensor, weight3: Tensor, hx_: Tensor, cx_: Tensor, reverse: bool, batch_sizes_data: *i64, batch_sizes_len: i32, mode: i64, hidden_size: i64, num_layers: i64, has_biases: bool, bidirectional: bool, batch_first: bool, train: bool)
atg_mm :: extern proc(out__: *Tensor, self: Tensor, mat2: Tensor)
atg_mm_dtype :: extern proc(out__: *Tensor, self: Tensor, mat2: Tensor, out_dtype: i32)
atg_mm_dtype_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mat2: Tensor, out_dtype: i32)
atg_mm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mat2: Tensor)
atg_mode :: extern proc(out__: *Tensor, self: Tensor, dim: i64, keepdim: bool)
atg_mode_values :: extern proc(out__: *Tensor, values: Tensor, indices: Tensor, self: Tensor, dim: i64, keepdim: bool)
atg_moveaxis :: extern proc(out__: *Tensor, self: Tensor, source_data: *i64, source_len: i32, destination_data: *i64, destination_len: i32)
atg_moveaxis_int :: extern proc(out__: *Tensor, self: Tensor, source: i64, destination: i64)
atg_movedim :: extern proc(out__: *Tensor, self: Tensor, source_data: *i64, source_len: i32, destination_data: *i64, destination_len: i32)
atg_movedim_int :: extern proc(out__: *Tensor, self: Tensor, source: i64, destination: i64)
atg_mse_loss :: extern proc(out__: *Tensor, self: Tensor, target: Tensor, reduction: i64)
atg_mse_loss_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, target: Tensor, reduction: i64)
atg_mse_loss_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, target: Tensor, reduction: i64)
atg_mse_loss_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, target: Tensor, reduction: i64)
atg_msort :: extern proc(out__: *Tensor, self: Tensor)
atg_msort_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_mt :: extern proc(out__: *Tensor, self: Tensor)
atg_mul :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_mul_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_mul_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_mul_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_mul_scalar_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_mul_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_multi_margin_loss_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, target: Tensor, p: Scalar, margin: Scalar, weight: Tensor, reduction: i64)
atg_multi_margin_loss_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, target: Tensor, p: Scalar, margin: Scalar, weight: Tensor, reduction: i64)
atg_multilabel_margin_loss :: extern proc(out__: *Tensor, self: Tensor, target: Tensor, reduction: i64)
atg_multilabel_margin_loss_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, target: Tensor, reduction: i64, is_target: Tensor)
atg_multilabel_margin_loss_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, target: Tensor, reduction: i64, is_target: Tensor)
atg_multilabel_margin_loss_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, target: Tensor, reduction: i64)
atg_multinomial :: extern proc(out__: *Tensor, self: Tensor, num_samples: i64, replacement: bool)
atg_multinomial_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, num_samples: i64, replacement: bool)
atg_multiply :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_multiply_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_multiply_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_multiply_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_multiply_scalar_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_mv :: extern proc(out__: *Tensor, self: Tensor, vec: Tensor)
atg_mv_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, vec: Tensor)
atg_mvlgamma :: extern proc(out__: *Tensor, self: Tensor, p: i64)
atg_mvlgamma_ :: extern proc(out__: *Tensor, self: Tensor, p: i64)
atg_mvlgamma_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, p: i64)
atg_nan_to_num :: extern proc(out__: *Tensor, self: Tensor, nan_v: f64, nan_null: u8, posinf_v: f64, posinf_null: u8, neginf_v: f64, neginf_null: u8)
atg_nan_to_num_ :: extern proc(out__: *Tensor, self: Tensor, nan_v: f64, nan_null: u8, posinf_v: f64, posinf_null: u8, neginf_v: f64, neginf_null: u8)
atg_nan_to_num_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, nan_v: f64, nan_null: u8, posinf_v: f64, posinf_null: u8, neginf_v: f64, neginf_null: u8)
atg_nanmean :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg_nanmean_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg_nanmedian :: extern proc(out__: *Tensor, self: Tensor)
atg_nanmedian_dim :: extern proc(out__: *Tensor, self: Tensor, dim: i64, keepdim: bool)
atg_nanmedian_dim_values :: extern proc(out__: *Tensor, values: Tensor, indices: Tensor, self: Tensor, dim: i64, keepdim: bool)
atg_nanmedian_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_nanquantile :: extern proc(out__: *Tensor, self: Tensor, q: Tensor, dim_v: i64, dim_null: u8, keepdim: bool, interpolation_ptr: *u8, interpolation_len: i32)
atg_nanquantile_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, q: Tensor, dim_v: i64, dim_null: u8, keepdim: bool, interpolation_ptr: *u8, interpolation_len: i32)
atg_nanquantile_scalar :: extern proc(out__: *Tensor, self: Tensor, q: f64, dim_v: i64, dim_null: u8, keepdim: bool, interpolation_ptr: *u8, interpolation_len: i32)
atg_nanquantile_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, q: f64, dim_v: i64, dim_null: u8, keepdim: bool, interpolation_ptr: *u8, interpolation_len: i32)
atg_nansum :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg_nansum_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg_narrow :: extern proc(out__: *Tensor, self: Tensor, dim: i64, start: i64, length: i64)
atg_narrow_copy :: extern proc(out__: *Tensor, self: Tensor, dim: i64, start: i64, length: i64)
atg_narrow_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, start: i64, length: i64)
atg_narrow_tensor :: extern proc(out__: *Tensor, self: Tensor, dim: i64, start: Tensor, length: i64)
atg_native_batch_norm :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, momentum: f64, eps: f64)
atg_native_batch_norm_out :: extern proc(out__: *Tensor, out: Tensor, save_mean: Tensor, save_invstd: Tensor, input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, momentum: f64, eps: f64)
atg_native_channel_shuffle :: extern proc(out__: *Tensor, self: Tensor, groups: i64)
atg_native_dropout :: extern proc(out__: *Tensor, input: Tensor, p: f64, train: bool)
atg_native_dropout_backward :: extern proc(out__: *Tensor, grad_output: Tensor, mask: Tensor, scale: f64)
atg_native_dropout_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, mask: Tensor, scale: f64)
atg_native_dropout_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, input: Tensor, p: f64, train: bool)
atg_native_group_norm :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, n: i64, C: i64, HxW: i64, group: i64, eps: f64)
atg_native_group_norm_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, input: Tensor, weight: Tensor, bias: Tensor, n: i64, C: i64, HxW: i64, group: i64, eps: f64)
atg_native_layer_norm :: extern proc(out__: *Tensor, input: Tensor, normalized_shape_data: *i64, normalized_shape_len: i32, weight: Tensor, bias: Tensor, eps: f64)
atg_native_layer_norm_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, input: Tensor, normalized_shape_data: *i64, normalized_shape_len: i32, weight: Tensor, bias: Tensor, eps: f64)
atg_native_norm :: extern proc(out__: *Tensor, self: Tensor)
atg_native_norm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_native_norm_scalaropt_dim_dtype :: extern proc(out__: *Tensor, self: Tensor, p: Scalar, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg_native_norm_scalaropt_dim_dtype_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, p: Scalar, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg_ne :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_ne_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_ne_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_ne_tensor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_ne_tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_ne_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_neg :: extern proc(out__: *Tensor, self: Tensor)
atg_neg_ :: extern proc(out__: *Tensor, self: Tensor)
atg_neg_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_negative :: extern proc(out__: *Tensor, self: Tensor)
atg_negative_ :: extern proc(out__: *Tensor, self: Tensor)
atg_negative_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_nested_to_padded_tensor :: extern proc(out__: *Tensor, self: Tensor, padding: f64, output_size_data: *i64, output_size_len: i32)
atg_new_empty :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg_new_empty_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg_new_empty_strided :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, stride_data: *i64, stride_len: i32, options_kind: i32, options_device: i32)
atg_new_empty_strided_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size_data: *i64, size_len: i32, stride_data: *i64, stride_len: i32)
atg_new_full :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, fill_value: Scalar, options_kind: i32, options_device: i32)
atg_new_full_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size_data: *i64, size_len: i32, fill_value: Scalar)
atg_new_ones :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg_new_ones_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg_new_zeros :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg_new_zeros_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg_nextafter :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_nextafter_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_nextafter_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_nll_loss :: extern proc(out__: *Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: i64, ignore_index: i64)
atg_nll_loss2d :: extern proc(out__: *Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: i64, ignore_index: i64)
atg_nll_loss2d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: i64, ignore_index: i64, total_weight: Tensor)
atg_nll_loss2d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: i64, ignore_index: i64, total_weight: Tensor)
atg_nll_loss2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: i64, ignore_index: i64)
atg_nll_loss_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: i64, ignore_index: i64, total_weight: Tensor)
atg_nll_loss_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: i64, ignore_index: i64, total_weight: Tensor)
atg_nll_loss_nd :: extern proc(out__: *Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: i64, ignore_index: i64)
atg_nll_loss_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: i64, ignore_index: i64)
atg_nonzero :: extern proc(out__: *Tensor, self: Tensor)
atg_nonzero_numpy :: extern fn(self: Tensor) *Tensor
atg_nonzero_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_nonzero_static :: extern proc(out__: *Tensor, self: Tensor, size: i64, fill_value: i64)
atg_nonzero_static_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size: i64, fill_value: i64)
atg_norm :: extern proc(out__: *Tensor, self: Tensor)
atg_norm_dtype_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, p: Scalar, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg_norm_except_dim :: extern proc(out__: *Tensor, v: Tensor, pow: i64, dim: i64)
atg_norm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, p: Scalar, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_norm_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_norm_scalaropt_dim :: extern proc(out__: *Tensor, self: Tensor, p: Scalar, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_norm_scalaropt_dim_dtype :: extern proc(out__: *Tensor, self: Tensor, p: Scalar, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg_norm_scalaropt_dtype :: extern proc(out__: *Tensor, self: Tensor, p: Scalar, dtype: i32)
atg_norm_scalaropt_dtype_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, p: Scalar, dtype: i32)
atg_normal_ :: extern proc(out__: *Tensor, self: Tensor, mean: f64, std: f64)
atg_normal_functional :: extern proc(out__: *Tensor, self: Tensor, mean: f64, std: f64)
atg_not_equal :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_not_equal_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_not_equal_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_not_equal_tensor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_not_equal_tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_not_equal_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_nuclear_norm :: extern proc(out__: *Tensor, self: Tensor, keepdim: bool)
atg_nuclear_norm_dim :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_nuclear_norm_dim_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_nuclear_norm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, keepdim: bool)
atg_numpy_t :: extern proc(out__: *Tensor, self: Tensor)
atg_one_hot :: extern proc(out__: *Tensor, self: Tensor, num_classes: i64)
atg_ones :: extern proc(out__: *Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg_ones_like :: extern proc(out__: *Tensor, self: Tensor)
atg_ones_like_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_ones_out :: extern proc(out__: *Tensor, out: Tensor, size_data: *i64, size_len: i32)
atg_orgqr :: extern proc(out__: *Tensor, self: Tensor, input2: Tensor)
atg_orgqr_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, input2: Tensor)
atg_ormqr :: extern proc(out__: *Tensor, self: Tensor, input2: Tensor, input3: Tensor, left: bool, transpose: bool)
atg_ormqr_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, input2: Tensor, input3: Tensor, left: bool, transpose: bool)
atg_outer :: extern proc(out__: *Tensor, self: Tensor, vec2: Tensor)
atg_outer_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, vec2: Tensor)
atg_output_nr :: extern fn(self: Tensor) i64
atg_pad :: extern proc(out__: *Tensor, self: Tensor, pad_data: *i64, pad_len: i32, mode_ptr: *u8, mode_len: i32, value_v: f64, value_null: u8)
atg_pad_sequence :: extern proc(out__: *Tensor, sequences_data: *Tensor, sequences_len: i32, batch_first: bool, padding_value: f64, padding_side_ptr: *u8, padding_side_len: i32)
atg_pairwise_distance :: extern proc(out__: *Tensor, x1: Tensor, x2: Tensor, p: f64, eps: f64, keepdim: bool)
atg_pdist :: extern proc(out__: *Tensor, self: Tensor, p: f64)
atg_permute :: extern proc(out__: *Tensor, self: Tensor, dims_data: *i64, dims_len: i32)
atg_permute_copy :: extern proc(out__: *Tensor, self: Tensor, dims_data: *i64, dims_len: i32)
atg_permute_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dims_data: *i64, dims_len: i32)
atg_pin_memory :: extern proc(out__: *Tensor, self: Tensor, device: i32)
atg_pinverse :: extern proc(out__: *Tensor, self: Tensor, rcond: f64)
atg_pixel_shuffle :: extern proc(out__: *Tensor, self: Tensor, upscale_factor: i64)
atg_pixel_shuffle_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, upscale_factor: i64)
atg_pixel_unshuffle :: extern proc(out__: *Tensor, self: Tensor, downscale_factor: i64)
atg_pixel_unshuffle_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, downscale_factor: i64)
atg_poisson :: extern proc(out__: *Tensor, self: Tensor)
atg_poisson_nll_loss :: extern proc(out__: *Tensor, input: Tensor, target: Tensor, log_input: bool, full: bool, eps: f64, reduction: i64)
atg_poisson_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_polar :: extern proc(out__: *Tensor, abs: Tensor, angle: Tensor)
atg_polar_out :: extern proc(out__: *Tensor, out: Tensor, abs: Tensor, angle: Tensor)
atg_polygamma :: extern proc(out__: *Tensor, n: i64, self: Tensor)
atg_polygamma_ :: extern proc(out__: *Tensor, self: Tensor, n: i64)
atg_polygamma_out :: extern proc(out__: *Tensor, out: Tensor, n: i64, self: Tensor)
atg_positive :: extern proc(out__: *Tensor, self: Tensor)
atg_pow :: extern proc(out__: *Tensor, self: Tensor, exponent: Tensor)
atg_pow_ :: extern proc(out__: *Tensor, self: Tensor, exponent: Scalar)
atg_pow_scalar :: extern proc(out__: *Tensor, self_scalar: Scalar, exponent: Tensor)
atg_pow_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self_scalar: Scalar, exponent: Tensor)
atg_pow_tensor_ :: extern proc(out__: *Tensor, self: Tensor, exponent: Tensor)
atg_pow_tensor_scalar :: extern proc(out__: *Tensor, self: Tensor, exponent: Scalar)
atg_pow_tensor_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, exponent: Scalar)
atg_pow_tensor_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, exponent: Tensor)
atg_prelu :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor)
atg_prod :: extern proc(out__: *Tensor, self: Tensor, dtype: i32)
atg_prod_dim_int :: extern proc(out__: *Tensor, self: Tensor, dim: i64, keepdim: bool, dtype: i32)
atg_prod_int_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, keepdim: bool, dtype: i32)
atg_prod_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dtype: i32)
atg_put :: extern proc(out__: *Tensor, self: Tensor, index: Tensor, source: Tensor, accumulate: bool)
atg_put_ :: extern proc(out__: *Tensor, self: Tensor, index: Tensor, source: Tensor, accumulate: bool)
atg_put_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, index: Tensor, source: Tensor, accumulate: bool)
atg_q_per_channel_axis :: extern fn(self: Tensor) i64
atg_q_per_channel_scales :: extern proc(out__: *Tensor, self: Tensor)
atg_q_per_channel_scales_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_q_per_channel_zero_points :: extern proc(out__: *Tensor, self: Tensor)
atg_q_per_channel_zero_points_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_q_scale :: extern fn(self: Tensor) f64
atg_q_zero_point :: extern fn(self: Tensor) i64
atg_qr :: extern proc(out__: *Tensor, self: Tensor, some: bool)
atg_qr_q :: extern proc(out__: *Tensor, Q: Tensor, R: Tensor, self: Tensor, some: bool)
atg_quantile :: extern proc(out__: *Tensor, self: Tensor, q: Tensor, dim_v: i64, dim_null: u8, keepdim: bool, interpolation_ptr: *u8, interpolation_len: i32)
atg_quantile_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, q: Tensor, dim_v: i64, dim_null: u8, keepdim: bool, interpolation_ptr: *u8, interpolation_len: i32)
atg_quantile_scalar :: extern proc(out__: *Tensor, self: Tensor, q: f64, dim_v: i64, dim_null: u8, keepdim: bool, interpolation_ptr: *u8, interpolation_len: i32)
atg_quantile_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, q: f64, dim_v: i64, dim_null: u8, keepdim: bool, interpolation_ptr: *u8, interpolation_len: i32)
atg_quantize_per_channel :: extern proc(out__: *Tensor, self: Tensor, scales: Tensor, zero_points: Tensor, axis: i64, dtype: i32)
atg_quantize_per_channel_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, scales: Tensor, zero_points: Tensor, axis: i64, dtype: i32)
atg_quantize_per_tensor :: extern proc(out__: *Tensor, self: Tensor, scale: f64, zero_point: i64, dtype: i32)
atg_quantize_per_tensor_dynamic :: extern proc(out__: *Tensor, self: Tensor, dtype: i32, reduce_range: bool)
atg_quantize_per_tensor_dynamic_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dtype: i32, reduce_range: bool)
atg_quantize_per_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, scale: f64, zero_point: i64, dtype: i32)
atg_quantize_per_tensor_tensor_qparams :: extern proc(out__: *Tensor, self: Tensor, scale: Tensor, zero_point: Tensor, dtype: i32)
atg_quantize_per_tensor_tensor_qparams_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, scale: Tensor, zero_point: Tensor, dtype: i32)
atg_quantize_per_tensor_tensors :: extern fn(tensors_data: *Tensor, tensors_len: i32, scales: Tensor, zero_points: Tensor, dtype: i32) *Tensor
atg_quantize_per_tensor_tensors_out :: extern proc(out_data: *Tensor, out_len: i32, tensors_data: *Tensor, tensors_len: i32, scales: Tensor, zero_points: Tensor, dtype: i32)
atg_quantized_batch_norm :: extern proc(out__: *Tensor, input: Tensor, weight: Tensor, bias: Tensor, mean: Tensor, var: Tensor, eps: f64, output_scale: f64, output_zero_point: i64)
atg_quantized_batch_norm_out :: extern proc(out__: *Tensor, out: Tensor, input: Tensor, weight: Tensor, bias: Tensor, mean: Tensor, var: Tensor, eps: f64, output_scale: f64, output_zero_point: i64)
atg_quantized_gru_cell :: extern proc(out__: *Tensor, input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor, packed_ih: Tensor, packed_hh: Tensor, col_offsets_ih: Tensor, col_offsets_hh: Tensor, scale_ih: Scalar, scale_hh: Scalar, zero_point_ih: Scalar, zero_point_hh: Scalar)
atg_quantized_lstm_cell :: extern proc(out__: *Tensor, input: Tensor, hx_data: *Tensor, hx_len: i32, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor, packed_ih: Tensor, packed_hh: Tensor, col_offsets_ih: Tensor, col_offsets_hh: Tensor, scale_ih: Scalar, scale_hh: Scalar, zero_point_ih: Scalar, zero_point_hh: Scalar)
atg_quantized_max_pool1d :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_quantized_max_pool1d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_quantized_max_pool2d :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_quantized_max_pool2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_quantized_max_pool3d :: extern proc(out__: *Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_quantized_max_pool3d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, kernel_size_data: *i64, kernel_size_len: i32, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32, ceil_mode: bool)
atg_quantized_rnn_relu_cell :: extern proc(out__: *Tensor, input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor, packed_ih: Tensor, packed_hh: Tensor, col_offsets_ih: Tensor, col_offsets_hh: Tensor, scale_ih: Scalar, scale_hh: Scalar, zero_point_ih: Scalar, zero_point_hh: Scalar)
atg_quantized_rnn_tanh_cell :: extern proc(out__: *Tensor, input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor, packed_ih: Tensor, packed_hh: Tensor, col_offsets_ih: Tensor, col_offsets_hh: Tensor, scale_ih: Scalar, scale_hh: Scalar, zero_point_ih: Scalar, zero_point_hh: Scalar)
atg_rad2deg :: extern proc(out__: *Tensor, self: Tensor)
atg_rad2deg_ :: extern proc(out__: *Tensor, self: Tensor)
atg_rad2deg_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_rand :: extern proc(out__: *Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg_rand_like :: extern proc(out__: *Tensor, self: Tensor)
atg_rand_like_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_rand_out :: extern proc(out__: *Tensor, out: Tensor, size_data: *i64, size_len: i32)
atg_randint :: extern proc(out__: *Tensor, high: i64, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg_randint_like :: extern proc(out__: *Tensor, self: Tensor, high: i64)
atg_randint_like_low_dtype :: extern proc(out__: *Tensor, self: Tensor, low: i64, high: i64)
atg_randint_like_low_dtype_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, low: i64, high: i64)
atg_randint_like_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, high: i64)
atg_randint_like_tensor :: extern proc(out__: *Tensor, self: Tensor, high: Tensor)
atg_randint_like_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, high: Tensor)
atg_randint_low :: extern proc(out__: *Tensor, low: i64, high: i64, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg_randint_low_out :: extern proc(out__: *Tensor, out: Tensor, low: i64, high: i64, size_data: *i64, size_len: i32)
atg_randint_out :: extern proc(out__: *Tensor, out: Tensor, high: i64, size_data: *i64, size_len: i32)
atg_randn :: extern proc(out__: *Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg_randn_like :: extern proc(out__: *Tensor, self: Tensor)
atg_randn_like_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_randn_out :: extern proc(out__: *Tensor, out: Tensor, size_data: *i64, size_len: i32)
atg_random :: extern proc(out__: *Tensor, self: Tensor)
atg_random_ :: extern proc(out__: *Tensor, self: Tensor)
atg_random_from :: extern proc(out__: *Tensor, self: Tensor, from: i64, to_v: i64, to_null: u8)
atg_random_from_ :: extern proc(out__: *Tensor, self: Tensor, from: i64, to_v: i64, to_null: u8)
atg_random_from_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, from: i64, to_v: i64, to_null: u8)
atg_random_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_random_to :: extern proc(out__: *Tensor, self: Tensor, to: i64)
atg_random_to_ :: extern proc(out__: *Tensor, self: Tensor, to: i64)
atg_random_to_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, to: i64)
atg_randperm :: extern proc(out__: *Tensor, n: i64, options_kind: i32, options_device: i32)
atg_randperm_out :: extern proc(out__: *Tensor, out: Tensor, n: i64)
atg_range :: extern proc(out__: *Tensor, start: Scalar, end: Scalar, options_kind: i32, options_device: i32)
atg_range_out :: extern proc(out__: *Tensor, out: Tensor, start: Scalar, end: Scalar)
atg_range_out_ :: extern proc(out__: *Tensor, out: Tensor, start: Scalar, end: Scalar)
atg_range_step :: extern proc(out__: *Tensor, start: Scalar, end: Scalar, options_kind: i32, options_device: i32)
atg_ravel :: extern proc(out__: *Tensor, self: Tensor)
atg_real :: extern proc(out__: *Tensor, self: Tensor)
atg_reciprocal :: extern proc(out__: *Tensor, self: Tensor)
atg_reciprocal_ :: extern proc(out__: *Tensor, self: Tensor)
atg_reciprocal_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_reflection_pad1d :: extern proc(out__: *Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_reflection_pad1d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_reflection_pad1d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_reflection_pad1d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_reflection_pad2d :: extern proc(out__: *Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_reflection_pad2d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_reflection_pad2d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_reflection_pad2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_reflection_pad3d :: extern proc(out__: *Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_reflection_pad3d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_reflection_pad3d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_reflection_pad3d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_relu :: extern proc(out__: *Tensor, self: Tensor)
atg_relu6 :: extern proc(out__: *Tensor, self: Tensor)
atg_relu6_ :: extern proc(out__: *Tensor, self: Tensor)
atg_relu_ :: extern proc(out__: *Tensor, self: Tensor)
atg_relu_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_remainder :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_remainder_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_remainder_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_remainder_scalar_tensor :: extern proc(out__: *Tensor, self_scalar: Scalar, other: Tensor)
atg_remainder_scalar_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self_scalar: Scalar, other: Tensor)
atg_remainder_tensor :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_remainder_tensor_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_remainder_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_renorm :: extern proc(out__: *Tensor, self: Tensor, p: Scalar, dim: i64, maxnorm: Scalar)
atg_renorm_ :: extern proc(out__: *Tensor, self: Tensor, p: Scalar, dim: i64, maxnorm: Scalar)
atg_renorm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, p: Scalar, dim: i64, maxnorm: Scalar)
atg_repeat :: extern proc(out__: *Tensor, self: Tensor, repeats_data: *i64, repeats_len: i32)
atg_repeat_interleave :: extern proc(out__: *Tensor, repeats: Tensor, output_size_v: i64, output_size_null: u8)
atg_repeat_interleave_self_int :: extern proc(out__: *Tensor, self: Tensor, repeats: i64, dim_v: i64, dim_null: u8, output_size_v: i64, output_size_null: u8)
atg_repeat_interleave_self_tensor :: extern proc(out__: *Tensor, self: Tensor, repeats: Tensor, dim_v: i64, dim_null: u8, output_size_v: i64, output_size_null: u8)
atg_repeat_interleave_tensor_out :: extern proc(out__: *Tensor, out: Tensor, repeats: Tensor, output_size_v: i64, output_size_null: u8)
atg_repeat_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, repeats_data: *i64, repeats_len: i32)
atg_replication_pad1d :: extern proc(out__: *Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_replication_pad1d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_replication_pad1d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_replication_pad1d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_replication_pad2d :: extern proc(out__: *Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_replication_pad2d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_replication_pad2d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_replication_pad2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_replication_pad3d :: extern proc(out__: *Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_replication_pad3d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_replication_pad3d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_replication_pad3d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, padding_data: *i64, padding_len: i32)
atg_requires_grad_ :: extern proc(out__: *Tensor, self: Tensor, requires_grad: i32)
atg_reshape :: extern proc(out__: *Tensor, self: Tensor, shape_data: *i64, shape_len: i32)
atg_reshape_as :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_resize :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg_resize_ :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg_resize_as :: extern proc(out__: *Tensor, self: Tensor, the_template: Tensor)
atg_resize_as_ :: extern proc(out__: *Tensor, self: Tensor, the_template: Tensor)
atg_resize_as_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, the_template: Tensor)
atg_resize_as_sparse :: extern proc(out__: *Tensor, self: Tensor, the_template: Tensor)
atg_resize_as_sparse_ :: extern proc(out__: *Tensor, self: Tensor, the_template: Tensor)
atg_resize_as_sparse_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, the_template: Tensor)
atg_resize_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg_resolve_conj :: extern proc(out__: *Tensor, self: Tensor)
atg_resolve_neg :: extern proc(out__: *Tensor, self: Tensor)
atg_retains_grad :: extern fn(self: Tensor) bool
atg_rms_norm :: extern proc(out__: *Tensor, input: Tensor, normalized_shape_data: *i64, normalized_shape_len: i32, weight: Tensor, eps_v: f64, eps_null: u8)
atg_rnn_relu :: extern proc(out__: *Tensor, input: Tensor, hx: Tensor, params_data: *Tensor, params_len: i32, has_biases: bool, num_layers: i64, dropout: f64, train: bool, bidirectional: bool, batch_first: bool)
atg_rnn_relu_cell :: extern proc(out__: *Tensor, input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor)
atg_rnn_relu_data :: extern proc(out__: *Tensor, data: Tensor, batch_sizes: Tensor, hx: Tensor, params_data: *Tensor, params_len: i32, has_biases: bool, num_layers: i64, dropout: f64, train: bool, bidirectional: bool)
atg_rnn_tanh :: extern proc(out__: *Tensor, input: Tensor, hx: Tensor, params_data: *Tensor, params_len: i32, has_biases: bool, num_layers: i64, dropout: f64, train: bool, bidirectional: bool, batch_first: bool)
atg_rnn_tanh_cell :: extern proc(out__: *Tensor, input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor)
atg_rnn_tanh_data :: extern proc(out__: *Tensor, data: Tensor, batch_sizes: Tensor, hx: Tensor, params_data: *Tensor, params_len: i32, has_biases: bool, num_layers: i64, dropout: f64, train: bool, bidirectional: bool)
atg_roll :: extern proc(out__: *Tensor, self: Tensor, shifts_data: *i64, shifts_len: i32, dims_data: *i64, dims_len: i32)
atg_roll_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, shifts_data: *i64, shifts_len: i32, dims_data: *i64, dims_len: i32)
atg_rot90 :: extern proc(out__: *Tensor, self: Tensor, k: i64, dims_data: *i64, dims_len: i32)
atg_rot90_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, k: i64, dims_data: *i64, dims_len: i32)
atg_round :: extern proc(out__: *Tensor, self: Tensor)
atg_round_ :: extern proc(out__: *Tensor, self: Tensor)
atg_round_decimals :: extern proc(out__: *Tensor, self: Tensor, decimals: i64)
atg_round_decimals_ :: extern proc(out__: *Tensor, self: Tensor, decimals: i64)
atg_round_decimals_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, decimals: i64)
atg_round_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_row_indices :: extern proc(out__: *Tensor, self: Tensor)
atg_row_indices_copy :: extern proc(out__: *Tensor, self: Tensor)
atg_row_indices_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_row_stack :: extern proc(out__: *Tensor, tensors_data: *Tensor, tensors_len: i32)
atg_row_stack_out :: extern proc(out__: *Tensor, out: Tensor, tensors_data: *Tensor, tensors_len: i32)
atg_rrelu :: extern proc(out__: *Tensor, self: Tensor, training: bool)
atg_rrelu_ :: extern proc(out__: *Tensor, self: Tensor, training: bool)
atg_rrelu_with_noise :: extern proc(out__: *Tensor, self: Tensor, noise: Tensor, training: bool)
atg_rrelu_with_noise_ :: extern proc(out__: *Tensor, self: Tensor, noise: Tensor, training: bool)
atg_rrelu_with_noise_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, noise: Tensor, lower: Scalar, upper: Scalar, training: bool, self_is_result: bool)
atg_rrelu_with_noise_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, self: Tensor, noise: Tensor, lower: Scalar, upper: Scalar, training: bool, self_is_result: bool)
atg_rrelu_with_noise_functional :: extern proc(out__: *Tensor, self: Tensor, noise: Tensor, training: bool)
atg_rrelu_with_noise_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, noise: Tensor, training: bool)
atg_rsqrt :: extern proc(out__: *Tensor, self: Tensor)
atg_rsqrt_ :: extern proc(out__: *Tensor, self: Tensor)
atg_rsqrt_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_rsub :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_rsub_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_rsub_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_rsub_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_scalar_tensor :: extern proc(out__: *Tensor, s: Scalar, options_kind: i32, options_device: i32)
atg_scalar_tensor_out :: extern proc(out__: *Tensor, out: Tensor, s: Scalar)
atg_scaled_dot_product_attention :: extern proc(out__: *Tensor, query: Tensor, key: Tensor, value: Tensor, attn_mask: Tensor, dropout_p: f64, is_causal: bool, scale_v: f64, scale_null: u8, enable_gqa: bool)
atg_scatter :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, src: Tensor)
atg_scatter_ :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, src: Tensor)
atg_scatter_add :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, src: Tensor)
atg_scatter_add_ :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, src: Tensor)
atg_scatter_add_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, index: Tensor, src: Tensor)
atg_scatter_reduce :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, src: Tensor, reduce_ptr: *u8, reduce_len: i32)
atg_scatter_reduce_ :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, src: Tensor, reduce_ptr: *u8, reduce_len: i32)
atg_scatter_reduce_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, index: Tensor, src: Tensor, reduce_ptr: *u8, reduce_len: i32)
atg_scatter_src_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, index: Tensor, src: Tensor)
atg_scatter_value :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, value: Scalar)
atg_scatter_value_ :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, value: Scalar)
atg_scatter_value_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, index: Tensor, value: Scalar)
atg_scatter_value_reduce :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, value: Scalar, reduce_ptr: *u8, reduce_len: i32)
atg_scatter_value_reduce_ :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: Tensor, value: Scalar, reduce_ptr: *u8, reduce_len: i32)
atg_scatter_value_reduce_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, index: Tensor, value: Scalar, reduce_ptr: *u8, reduce_len: i32)
atg_searchsorted :: extern proc(out__: *Tensor, sorted_sequence: Tensor, self: Tensor, out_int32: bool, right: bool, side_ptr: *u8, side_len: i32, sorter: Tensor)
atg_searchsorted_scalar :: extern proc(out__: *Tensor, sorted_sequence: Tensor, self_scalar: Scalar, out_int32: bool, right: bool, side_ptr: *u8, side_len: i32, sorter: Tensor)
atg_searchsorted_scalar_out :: extern proc(out__: *Tensor, out: Tensor, sorted_sequence: Tensor, self_scalar: Scalar, out_int32: bool, right: bool, side_ptr: *u8, side_len: i32, sorter: Tensor)
atg_searchsorted_tensor_out :: extern proc(out__: *Tensor, out: Tensor, sorted_sequence: Tensor, self: Tensor, out_int32: bool, right: bool, side_ptr: *u8, side_len: i32, sorter: Tensor)
atg_segment_reduce :: extern proc(out__: *Tensor, data: Tensor, reduce_ptr: *u8, reduce_len: i32, lengths: Tensor, indices: Tensor, offsets: Tensor, axis: i64, unsafe: bool, initial: Scalar)
atg_segment_reduce_out :: extern proc(out__: *Tensor, out: Tensor, data: Tensor, reduce_ptr: *u8, reduce_len: i32, lengths: Tensor, indices: Tensor, offsets: Tensor, axis: i64, unsafe: bool, initial: Scalar)
atg_select :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: i64)
atg_select_backward :: extern proc(out__: *Tensor, grad_output: Tensor, input_sizes_data: *i64, input_sizes_len: i32, dim: i64, index: i64)
atg_select_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, input_sizes_data: *i64, input_sizes_len: i32, dim: i64, index: i64)
atg_select_copy :: extern proc(out__: *Tensor, self: Tensor, dim: i64, index: i64)
atg_select_copy_int_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, index: i64)
atg_select_scatter :: extern proc(out__: *Tensor, self: Tensor, src: Tensor, dim: i64, index: i64)
atg_select_scatter_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, src: Tensor, dim: i64, index: i64)
atg_selu :: extern proc(out__: *Tensor, self: Tensor)
atg_selu_ :: extern proc(out__: *Tensor, self: Tensor)
atg_set :: extern proc(out__: *Tensor, self: Tensor)
atg_set_ :: extern proc(out__: *Tensor, self: Tensor)
atg_set_data :: extern proc(self: Tensor, new_data: Tensor)
atg_set_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_set_requires_grad :: extern proc(out__: *Tensor, self: Tensor, r: bool)
atg_set_source_tensor :: extern proc(out__: *Tensor, self: Tensor, source: Tensor)
atg_set_source_tensor_ :: extern proc(out__: *Tensor, self: Tensor, source: Tensor)
atg_set_source_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, source: Tensor)
atg_set_source_tensor_storage_offset_ :: extern proc(out__: *Tensor, self: Tensor, source: Tensor, storage_offset: i64, size_data: *i64, size_len: i32, stride_data: *i64, stride_len: i32)
atg_sgn :: extern proc(out__: *Tensor, self: Tensor)
atg_sgn_ :: extern proc(out__: *Tensor, self: Tensor)
atg_sgn_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_sigmoid :: extern proc(out__: *Tensor, self: Tensor)
atg_sigmoid_ :: extern proc(out__: *Tensor, self: Tensor)
atg_sigmoid_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output: Tensor)
atg_sigmoid_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, output: Tensor)
atg_sigmoid_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_sign :: extern proc(out__: *Tensor, self: Tensor)
atg_sign_ :: extern proc(out__: *Tensor, self: Tensor)
atg_sign_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_signbit :: extern proc(out__: *Tensor, self: Tensor)
atg_signbit_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_silu :: extern proc(out__: *Tensor, self: Tensor)
atg_silu_ :: extern proc(out__: *Tensor, self: Tensor)
atg_silu_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor)
atg_silu_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor)
atg_silu_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_sin :: extern proc(out__: *Tensor, self: Tensor)
atg_sin_ :: extern proc(out__: *Tensor, self: Tensor)
atg_sin_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_sinc :: extern proc(out__: *Tensor, self: Tensor)
atg_sinc_ :: extern proc(out__: *Tensor, self: Tensor)
atg_sinc_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_sinh :: extern proc(out__: *Tensor, self: Tensor)
atg_sinh_ :: extern proc(out__: *Tensor, self: Tensor)
atg_sinh_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_slice :: extern proc(out__: *Tensor, self: Tensor, dim: i64, start_v: i64, start_null: u8, end_v: i64, end_null: u8, step: i64)
atg_slice_backward :: extern proc(out__: *Tensor, grad_output: Tensor, input_sizes_data: *i64, input_sizes_len: i32, dim: i64, start: i64, end: i64, step: i64)
atg_slice_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad_output: Tensor, input_sizes_data: *i64, input_sizes_len: i32, dim: i64, start: i64, end: i64, step: i64)
atg_slice_copy :: extern proc(out__: *Tensor, self: Tensor, dim: i64, start_v: i64, start_null: u8, end_v: i64, end_null: u8, step: i64)
atg_slice_copy_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, start_v: i64, start_null: u8, end_v: i64, end_null: u8, step: i64)
atg_slice_inverse :: extern proc(out__: *Tensor, self: Tensor, src: Tensor, dim: i64, start_v: i64, start_null: u8, end_v: i64, end_null: u8, step: i64)
atg_slice_scatter :: extern proc(out__: *Tensor, self: Tensor, src: Tensor, dim: i64, start_v: i64, start_null: u8, end_v: i64, end_null: u8, step: i64)
atg_slice_scatter_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, src: Tensor, dim: i64, start_v: i64, start_null: u8, end_v: i64, end_null: u8, step: i64)
atg_slogdet :: extern proc(out__: *Tensor, self: Tensor)
atg_slogdet_out :: extern proc(out__: *Tensor, sign: Tensor, logabsdet: Tensor, self: Tensor)
atg_slow_conv3d :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, kernel_size_data: *i64, kernel_size_len: i32, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32)
atg_slow_conv3d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, kernel_size_data: *i64, kernel_size_len: i32, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32)
atg_slow_conv_dilated2d :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, kernel_size_data: *i64, kernel_size_len: i32, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32)
atg_slow_conv_dilated2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, kernel_size_data: *i64, kernel_size_len: i32, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32)
atg_slow_conv_dilated3d :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, kernel_size_data: *i64, kernel_size_len: i32, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32)
atg_slow_conv_dilated3d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, kernel_size_data: *i64, kernel_size_len: i32, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, dilation_data: *i64, dilation_len: i32)
atg_slow_conv_transpose2d :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, kernel_size_data: *i64, kernel_size_len: i32, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, output_padding_data: *i64, output_padding_len: i32, dilation_data: *i64, dilation_len: i32)
atg_slow_conv_transpose2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, kernel_size_data: *i64, kernel_size_len: i32, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, output_padding_data: *i64, output_padding_len: i32, dilation_data: *i64, dilation_len: i32)
atg_slow_conv_transpose3d :: extern proc(out__: *Tensor, self: Tensor, weight: Tensor, kernel_size_data: *i64, kernel_size_len: i32, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, output_padding_data: *i64, output_padding_len: i32, dilation_data: *i64, dilation_len: i32)
atg_slow_conv_transpose3d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, weight: Tensor, kernel_size_data: *i64, kernel_size_len: i32, bias: Tensor, stride_data: *i64, stride_len: i32, padding_data: *i64, padding_len: i32, output_padding_data: *i64, output_padding_len: i32, dilation_data: *i64, dilation_len: i32)
atg_smm :: extern proc(out__: *Tensor, self: Tensor, mat2: Tensor)
atg_smooth_l1_loss :: extern proc(out__: *Tensor, self: Tensor, target: Tensor, reduction: i64, beta: f64)
atg_smooth_l1_loss_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, target: Tensor, reduction: i64, beta: f64)
atg_smooth_l1_loss_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, target: Tensor, reduction: i64, beta: f64)
atg_smooth_l1_loss_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, target: Tensor, reduction: i64, beta: f64)
atg_soft_margin_loss :: extern proc(out__: *Tensor, self: Tensor, target: Tensor, reduction: i64)
atg_soft_margin_loss_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, target: Tensor, reduction: i64)
atg_soft_margin_loss_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, target: Tensor, reduction: i64)
atg_soft_margin_loss_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, target: Tensor, reduction: i64)
atg_softmax :: extern proc(out__: *Tensor, self: Tensor, dim: i64, dtype: i32)
atg_softmax_int_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64, dtype: i32)
atg_softplus :: extern proc(out__: *Tensor, self: Tensor)
atg_softplus_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, beta: Scalar, threshold: Scalar)
atg_softplus_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, beta: Scalar, threshold: Scalar)
atg_softplus_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_softshrink :: extern proc(out__: *Tensor, self: Tensor)
atg_softshrink_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, lambd: Scalar)
atg_softshrink_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, lambd: Scalar)
atg_softshrink_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_sort :: extern proc(out__: *Tensor, self: Tensor, dim: i64, descending: bool)
atg_sort_stable :: extern proc(out__: *Tensor, self: Tensor, stable: bool, dim: i64, descending: bool)
atg_sort_values :: extern proc(out__: *Tensor, values: Tensor, indices: Tensor, self: Tensor, dim: i64, descending: bool)
atg_sort_values_stable :: extern proc(out__: *Tensor, values: Tensor, indices: Tensor, self: Tensor, stable: bool, dim: i64, descending: bool)
atg_sparse_bsc_tensor :: extern proc(out__: *Tensor, ccol_indices: Tensor, row_indices: Tensor, values: Tensor, options_kind: i32, options_device: i32)
atg_sparse_bsc_tensor_ccol_row_value_size :: extern proc(out__: *Tensor, ccol_indices: Tensor, row_indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg_sparse_bsr_tensor :: extern proc(out__: *Tensor, crow_indices: Tensor, col_indices: Tensor, values: Tensor, options_kind: i32, options_device: i32)
atg_sparse_bsr_tensor_crow_col_value_size :: extern proc(out__: *Tensor, crow_indices: Tensor, col_indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg_sparse_compressed_tensor :: extern proc(out__: *Tensor, compressed_indices: Tensor, plain_indices: Tensor, values: Tensor, options_kind: i32, options_device: i32)
atg_sparse_compressed_tensor_comp_plain_value_size :: extern proc(out__: *Tensor, compressed_indices: Tensor, plain_indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg_sparse_coo_tensor :: extern proc(out__: *Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg_sparse_coo_tensor_indices :: extern proc(out__: *Tensor, indices: Tensor, values: Tensor, options_kind: i32, options_device: i32, is_coalesced: bool)
atg_sparse_coo_tensor_indices_size :: extern proc(out__: *Tensor, indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32, is_coalesced: bool)
atg_sparse_coo_tensor_size_out :: extern proc(out__: *Tensor, out: Tensor, size_data: *i64, size_len: i32)
atg_sparse_csc_tensor :: extern proc(out__: *Tensor, ccol_indices: Tensor, row_indices: Tensor, values: Tensor, options_kind: i32, options_device: i32)
atg_sparse_csc_tensor_ccol_row_value_size :: extern proc(out__: *Tensor, ccol_indices: Tensor, row_indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg_sparse_csr_tensor :: extern proc(out__: *Tensor, crow_indices: Tensor, col_indices: Tensor, values: Tensor, options_kind: i32, options_device: i32)
atg_sparse_csr_tensor_crow_col_value_size :: extern proc(out__: *Tensor, crow_indices: Tensor, col_indices: Tensor, values: Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg_sparse_dim :: extern fn(self: Tensor) i64
atg_sparse_mask :: extern proc(out__: *Tensor, self: Tensor, mask: Tensor)
atg_sparse_mask_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mask: Tensor)
atg_sparse_resize :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, sparse_dim: i64, dense_dim: i64)
atg_sparse_resize_ :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, sparse_dim: i64, dense_dim: i64)
atg_sparse_resize_and_clear :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, sparse_dim: i64, dense_dim: i64)
atg_sparse_resize_and_clear_ :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32, sparse_dim: i64, dense_dim: i64)
atg_sparse_resize_and_clear_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size_data: *i64, size_len: i32, sparse_dim: i64, dense_dim: i64)
atg_sparse_resize_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size_data: *i64, size_len: i32, sparse_dim: i64, dense_dim: i64)
atg_sparse_sampled_addmm :: extern proc(out__: *Tensor, self: Tensor, mat1: Tensor, mat2: Tensor)
atg_sparse_sampled_addmm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mat1: Tensor, mat2: Tensor)
atg_special_airy_ai :: extern proc(out__: *Tensor, x: Tensor)
atg_special_airy_ai_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor)
atg_special_bessel_j0 :: extern proc(out__: *Tensor, self: Tensor)
atg_special_bessel_j0_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_bessel_j1 :: extern proc(out__: *Tensor, self: Tensor)
atg_special_bessel_j1_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_bessel_y0 :: extern proc(out__: *Tensor, self: Tensor)
atg_special_bessel_y0_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_bessel_y1 :: extern proc(out__: *Tensor, self: Tensor)
atg_special_bessel_y1_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_chebyshev_polynomial_t :: extern proc(out__: *Tensor, x: Tensor, n: Tensor)
atg_special_chebyshev_polynomial_t_n_scalar :: extern proc(out__: *Tensor, x: Tensor, n: Scalar)
atg_special_chebyshev_polynomial_t_n_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Scalar)
atg_special_chebyshev_polynomial_t_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Tensor)
atg_special_chebyshev_polynomial_t_x_scalar :: extern proc(out__: *Tensor, x: Scalar, n: Tensor)
atg_special_chebyshev_polynomial_t_x_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Scalar, n: Tensor)
atg_special_chebyshev_polynomial_u :: extern proc(out__: *Tensor, x: Tensor, n: Tensor)
atg_special_chebyshev_polynomial_u_n_scalar :: extern proc(out__: *Tensor, x: Tensor, n: Scalar)
atg_special_chebyshev_polynomial_u_n_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Scalar)
atg_special_chebyshev_polynomial_u_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Tensor)
atg_special_chebyshev_polynomial_u_x_scalar :: extern proc(out__: *Tensor, x: Scalar, n: Tensor)
atg_special_chebyshev_polynomial_u_x_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Scalar, n: Tensor)
atg_special_chebyshev_polynomial_v :: extern proc(out__: *Tensor, x: Tensor, n: Tensor)
atg_special_chebyshev_polynomial_v_n_scalar :: extern proc(out__: *Tensor, x: Tensor, n: Scalar)
atg_special_chebyshev_polynomial_v_n_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Scalar)
atg_special_chebyshev_polynomial_v_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Tensor)
atg_special_chebyshev_polynomial_v_x_scalar :: extern proc(out__: *Tensor, x: Scalar, n: Tensor)
atg_special_chebyshev_polynomial_v_x_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Scalar, n: Tensor)
atg_special_chebyshev_polynomial_w :: extern proc(out__: *Tensor, x: Tensor, n: Tensor)
atg_special_chebyshev_polynomial_w_n_scalar :: extern proc(out__: *Tensor, x: Tensor, n: Scalar)
atg_special_chebyshev_polynomial_w_n_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Scalar)
atg_special_chebyshev_polynomial_w_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Tensor)
atg_special_chebyshev_polynomial_w_x_scalar :: extern proc(out__: *Tensor, x: Scalar, n: Tensor)
atg_special_chebyshev_polynomial_w_x_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Scalar, n: Tensor)
atg_special_digamma :: extern proc(out__: *Tensor, self: Tensor)
atg_special_digamma_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_entr :: extern proc(out__: *Tensor, self: Tensor)
atg_special_entr_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_erf :: extern proc(out__: *Tensor, self: Tensor)
atg_special_erf_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_erfc :: extern proc(out__: *Tensor, self: Tensor)
atg_special_erfc_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_erfcx :: extern proc(out__: *Tensor, self: Tensor)
atg_special_erfcx_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_erfinv :: extern proc(out__: *Tensor, self: Tensor)
atg_special_erfinv_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_exp2 :: extern proc(out__: *Tensor, self: Tensor)
atg_special_exp2_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_expit :: extern proc(out__: *Tensor, self: Tensor)
atg_special_expit_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_expm1 :: extern proc(out__: *Tensor, self: Tensor)
atg_special_expm1_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_gammainc :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_special_gammainc_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_special_gammaincc :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_special_gammaincc_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_special_gammaln :: extern proc(out__: *Tensor, self: Tensor)
atg_special_gammaln_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_hermite_polynomial_h :: extern proc(out__: *Tensor, x: Tensor, n: Tensor)
atg_special_hermite_polynomial_h_n_scalar :: extern proc(out__: *Tensor, x: Tensor, n: Scalar)
atg_special_hermite_polynomial_h_n_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Scalar)
atg_special_hermite_polynomial_h_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Tensor)
atg_special_hermite_polynomial_h_x_scalar :: extern proc(out__: *Tensor, x: Scalar, n: Tensor)
atg_special_hermite_polynomial_h_x_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Scalar, n: Tensor)
atg_special_hermite_polynomial_he :: extern proc(out__: *Tensor, x: Tensor, n: Tensor)
atg_special_hermite_polynomial_he_n_scalar :: extern proc(out__: *Tensor, x: Tensor, n: Scalar)
atg_special_hermite_polynomial_he_n_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Scalar)
atg_special_hermite_polynomial_he_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Tensor)
atg_special_hermite_polynomial_he_x_scalar :: extern proc(out__: *Tensor, x: Scalar, n: Tensor)
atg_special_hermite_polynomial_he_x_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Scalar, n: Tensor)
atg_special_i0 :: extern proc(out__: *Tensor, self: Tensor)
atg_special_i0_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_i0e :: extern proc(out__: *Tensor, self: Tensor)
atg_special_i0e_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_i1 :: extern proc(out__: *Tensor, self: Tensor)
atg_special_i1_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_i1e :: extern proc(out__: *Tensor, self: Tensor)
atg_special_i1e_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_laguerre_polynomial_l :: extern proc(out__: *Tensor, x: Tensor, n: Tensor)
atg_special_laguerre_polynomial_l_n_scalar :: extern proc(out__: *Tensor, x: Tensor, n: Scalar)
atg_special_laguerre_polynomial_l_n_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Scalar)
atg_special_laguerre_polynomial_l_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Tensor)
atg_special_laguerre_polynomial_l_x_scalar :: extern proc(out__: *Tensor, x: Scalar, n: Tensor)
atg_special_laguerre_polynomial_l_x_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Scalar, n: Tensor)
atg_special_legendre_polynomial_p :: extern proc(out__: *Tensor, x: Tensor, n: Tensor)
atg_special_legendre_polynomial_p_n_scalar :: extern proc(out__: *Tensor, x: Tensor, n: Scalar)
atg_special_legendre_polynomial_p_n_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Scalar)
atg_special_legendre_polynomial_p_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Tensor)
atg_special_legendre_polynomial_p_x_scalar :: extern proc(out__: *Tensor, x: Scalar, n: Tensor)
atg_special_legendre_polynomial_p_x_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Scalar, n: Tensor)
atg_special_log1p :: extern proc(out__: *Tensor, self: Tensor)
atg_special_log1p_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_log_ndtr :: extern proc(out__: *Tensor, self: Tensor)
atg_special_log_ndtr_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_log_softmax :: extern proc(out__: *Tensor, self: Tensor, dim: i64, dtype: i32)
atg_special_logit :: extern proc(out__: *Tensor, self: Tensor, eps_v: f64, eps_null: u8)
atg_special_logit_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, eps_v: f64, eps_null: u8)
atg_special_logsumexp :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_special_logsumexp_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool)
atg_special_modified_bessel_i0 :: extern proc(out__: *Tensor, self: Tensor)
atg_special_modified_bessel_i0_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_modified_bessel_i1 :: extern proc(out__: *Tensor, self: Tensor)
atg_special_modified_bessel_i1_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_modified_bessel_k0 :: extern proc(out__: *Tensor, self: Tensor)
atg_special_modified_bessel_k0_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_modified_bessel_k1 :: extern proc(out__: *Tensor, self: Tensor)
atg_special_modified_bessel_k1_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_multigammaln :: extern proc(out__: *Tensor, self: Tensor, p: i64)
atg_special_multigammaln_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, p: i64)
atg_special_ndtr :: extern proc(out__: *Tensor, self: Tensor)
atg_special_ndtr_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_ndtri :: extern proc(out__: *Tensor, self: Tensor)
atg_special_ndtri_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_polygamma :: extern proc(out__: *Tensor, n: i64, self: Tensor)
atg_special_polygamma_out :: extern proc(out__: *Tensor, out: Tensor, n: i64, self: Tensor)
atg_special_psi :: extern proc(out__: *Tensor, self: Tensor)
atg_special_psi_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_round :: extern proc(out__: *Tensor, self: Tensor, decimals: i64)
atg_special_round_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, decimals: i64)
atg_special_scaled_modified_bessel_k0 :: extern proc(out__: *Tensor, x: Tensor)
atg_special_scaled_modified_bessel_k0_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor)
atg_special_scaled_modified_bessel_k1 :: extern proc(out__: *Tensor, x: Tensor)
atg_special_scaled_modified_bessel_k1_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor)
atg_special_shifted_chebyshev_polynomial_t :: extern proc(out__: *Tensor, x: Tensor, n: Tensor)
atg_special_shifted_chebyshev_polynomial_t_n_scalar :: extern proc(out__: *Tensor, x: Tensor, n: Scalar)
atg_special_shifted_chebyshev_polynomial_t_n_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Scalar)
atg_special_shifted_chebyshev_polynomial_t_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Tensor)
atg_special_shifted_chebyshev_polynomial_t_x_scalar :: extern proc(out__: *Tensor, x: Scalar, n: Tensor)
atg_special_shifted_chebyshev_polynomial_t_x_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Scalar, n: Tensor)
atg_special_shifted_chebyshev_polynomial_u :: extern proc(out__: *Tensor, x: Tensor, n: Tensor)
atg_special_shifted_chebyshev_polynomial_u_n_scalar :: extern proc(out__: *Tensor, x: Tensor, n: Scalar)
atg_special_shifted_chebyshev_polynomial_u_n_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Scalar)
atg_special_shifted_chebyshev_polynomial_u_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Tensor)
atg_special_shifted_chebyshev_polynomial_u_x_scalar :: extern proc(out__: *Tensor, x: Scalar, n: Tensor)
atg_special_shifted_chebyshev_polynomial_u_x_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Scalar, n: Tensor)
atg_special_shifted_chebyshev_polynomial_v :: extern proc(out__: *Tensor, x: Tensor, n: Tensor)
atg_special_shifted_chebyshev_polynomial_v_n_scalar :: extern proc(out__: *Tensor, x: Tensor, n: Scalar)
atg_special_shifted_chebyshev_polynomial_v_n_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Scalar)
atg_special_shifted_chebyshev_polynomial_v_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Tensor)
atg_special_shifted_chebyshev_polynomial_v_x_scalar :: extern proc(out__: *Tensor, x: Scalar, n: Tensor)
atg_special_shifted_chebyshev_polynomial_v_x_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Scalar, n: Tensor)
atg_special_shifted_chebyshev_polynomial_w :: extern proc(out__: *Tensor, x: Tensor, n: Tensor)
atg_special_shifted_chebyshev_polynomial_w_n_scalar :: extern proc(out__: *Tensor, x: Tensor, n: Scalar)
atg_special_shifted_chebyshev_polynomial_w_n_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Scalar)
atg_special_shifted_chebyshev_polynomial_w_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor, n: Tensor)
atg_special_shifted_chebyshev_polynomial_w_x_scalar :: extern proc(out__: *Tensor, x: Scalar, n: Tensor)
atg_special_shifted_chebyshev_polynomial_w_x_scalar_out :: extern proc(out__: *Tensor, out: Tensor, x: Scalar, n: Tensor)
atg_special_sinc :: extern proc(out__: *Tensor, self: Tensor)
atg_special_sinc_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_special_softmax :: extern proc(out__: *Tensor, self: Tensor, dim: i64, dtype: i32)
atg_special_spherical_bessel_j0 :: extern proc(out__: *Tensor, x: Tensor)
atg_special_spherical_bessel_j0_out :: extern proc(out__: *Tensor, out: Tensor, x: Tensor)
atg_special_xlog1py :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_special_xlog1py_other_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_special_xlog1py_other_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_special_xlog1py_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_special_xlog1py_self_scalar :: extern proc(out__: *Tensor, self_scalar: Scalar, other: Tensor)
atg_special_xlog1py_self_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self_scalar: Scalar, other: Tensor)
atg_special_xlogy :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_special_xlogy_other_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_special_xlogy_other_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_special_xlogy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_special_xlogy_self_scalar :: extern proc(out__: *Tensor, self_scalar: Scalar, other: Tensor)
atg_special_xlogy_self_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self_scalar: Scalar, other: Tensor)
atg_special_zeta :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_special_zeta_other_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_special_zeta_other_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_special_zeta_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_special_zeta_self_scalar :: extern proc(out__: *Tensor, self_scalar: Scalar, other: Tensor)
atg_special_zeta_self_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self_scalar: Scalar, other: Tensor)
atg_split :: extern fn(self: Tensor, split_size: i64, dim: i64) *Tensor
atg_split_copy :: extern fn(self: Tensor, split_size: i64, dim: i64) *Tensor
atg_split_copy_tensor_out :: extern proc(out_data: *Tensor, out_len: i32, self: Tensor, split_size: i64, dim: i64)
atg_split_sizes :: extern fn(self: Tensor, split_size_data: *i64, split_size_len: i32, dim: i64) *Tensor
atg_split_with_sizes :: extern fn(self: Tensor, split_sizes_data: *i64, split_sizes_len: i32, dim: i64) *Tensor
atg_split_with_sizes_copy :: extern fn(self: Tensor, split_sizes_data: *i64, split_sizes_len: i32, dim: i64) *Tensor
atg_split_with_sizes_copy_out :: extern proc(out_data: *Tensor, out_len: i32, self: Tensor, split_sizes_data: *i64, split_sizes_len: i32, dim: i64)
atg_sqrt :: extern proc(out__: *Tensor, self: Tensor)
atg_sqrt_ :: extern proc(out__: *Tensor, self: Tensor)
atg_sqrt_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_square :: extern proc(out__: *Tensor, self: Tensor)
atg_square_ :: extern proc(out__: *Tensor, self: Tensor)
atg_square_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_squeeze :: extern proc(out__: *Tensor, self: Tensor)
atg_squeeze_ :: extern proc(out__: *Tensor, self: Tensor)
atg_squeeze_copy :: extern proc(out__: *Tensor, self: Tensor)
atg_squeeze_copy_dim :: extern proc(out__: *Tensor, self: Tensor, dim: i64)
atg_squeeze_copy_dim_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64)
atg_squeeze_copy_dims :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32)
atg_squeeze_copy_dims_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32)
atg_squeeze_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_squeeze_dim :: extern proc(out__: *Tensor, self: Tensor, dim: i64)
atg_squeeze_dim_ :: extern proc(out__: *Tensor, self: Tensor, dim: i64)
atg_squeeze_dims :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32)
atg_squeeze_dims_ :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32)
atg_sspaddmm :: extern proc(out__: *Tensor, self: Tensor, mat1: Tensor, mat2: Tensor)
atg_sspaddmm_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, mat1: Tensor, mat2: Tensor)
atg_stack :: extern proc(out__: *Tensor, tensors_data: *Tensor, tensors_len: i32, dim: i64)
atg_stack_out :: extern proc(out__: *Tensor, out: Tensor, tensors_data: *Tensor, tensors_len: i32, dim: i64)
atg_std :: extern proc(out__: *Tensor, self: Tensor, unbiased: bool)
atg_std_correction :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, correction: Scalar, keepdim: bool)
atg_std_correction_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, correction: Scalar, keepdim: bool)
atg_std_dim :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, unbiased: bool, keepdim: bool)
atg_std_mean :: extern proc(out__: *Tensor, self: Tensor, unbiased: bool)
atg_std_mean_correction :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, correction: Scalar, keepdim: bool)
atg_std_mean_correction_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, correction: Scalar, keepdim: bool)
atg_std_mean_dim :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, unbiased: bool, keepdim: bool)
atg_std_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, unbiased: bool, keepdim: bool)
atg_stft :: extern proc(out__: *Tensor, self: Tensor, n_fft: i64, hop_length_v: i64, hop_length_null: u8, win_length_v: i64, win_length_null: u8, window: Tensor, normalized: bool, onesided: bool, return_complex: bool, align_to_window: bool)
atg_stft_center :: extern proc(out__: *Tensor, self: Tensor, n_fft: i64, hop_length_v: i64, hop_length_null: u8, win_length_v: i64, win_length_null: u8, window: Tensor, center: bool, pad_mode_ptr: *u8, pad_mode_len: i32, normalized: bool, onesided: bool, return_complex: bool, align_to_window: bool)
atg_sub :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_sub_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_sub_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_sub_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_sub_scalar_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_sub_scalar_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_subtract :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_subtract_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_subtract_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_subtract_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_subtract_scalar_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_sum :: extern proc(out__: *Tensor, self: Tensor, dtype: i32)
atg_sum_dim_intlist :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg_sum_intlist_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, keepdim: bool, dtype: i32)
atg_sum_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dtype: i32)
atg_sum_to_size :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg_svd :: extern proc(out__: *Tensor, self: Tensor, some: bool, compute_uv: bool)
atg_svd_u :: extern proc(out__: *Tensor, U: Tensor, S: Tensor, V: Tensor, self: Tensor, some: bool, compute_uv: bool)
atg_swapaxes :: extern proc(out__: *Tensor, self: Tensor, axis0: i64, axis1: i64)
atg_swapaxes_ :: extern proc(out__: *Tensor, self: Tensor, axis0: i64, axis1: i64)
atg_swapdims :: extern proc(out__: *Tensor, self: Tensor, dim0: i64, dim1: i64)
atg_swapdims_ :: extern proc(out__: *Tensor, self: Tensor, dim0: i64, dim1: i64)
atg_t :: extern proc(out__: *Tensor, self: Tensor)
atg_t_ :: extern proc(out__: *Tensor, self: Tensor)
atg_t_copy :: extern proc(out__: *Tensor, self: Tensor)
atg_t_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_take :: extern proc(out__: *Tensor, self: Tensor, index: Tensor)
atg_take_along_dim :: extern proc(out__: *Tensor, self: Tensor, indices: Tensor, dim_v: i64, dim_null: u8)
atg_take_along_dim_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, indices: Tensor, dim_v: i64, dim_null: u8)
atg_take_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, index: Tensor)
atg_tan :: extern proc(out__: *Tensor, self: Tensor)
atg_tan_ :: extern proc(out__: *Tensor, self: Tensor)
atg_tan_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_tanh :: extern proc(out__: *Tensor, self: Tensor)
atg_tanh_ :: extern proc(out__: *Tensor, self: Tensor)
atg_tanh_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output: Tensor)
atg_tanh_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, output: Tensor)
atg_tanh_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_tensor_split :: extern fn(self: Tensor, sections: i64, dim: i64) *Tensor
atg_tensor_split_indices :: extern fn(self: Tensor, indices_data: *i64, indices_len: i32, dim: i64) *Tensor
atg_tensor_split_tensor_indices_or_sections :: extern fn(self: Tensor, tensor_indices_or_sections: Tensor, dim: i64) *Tensor
atg_tensordot :: extern proc(out__: *Tensor, self: Tensor, other: Tensor, dims_self_data: *i64, dims_self_len: i32, dims_other_data: *i64, dims_other_len: i32)
atg_tensordot_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor, dims_self_data: *i64, dims_self_len: i32, dims_other_data: *i64, dims_other_len: i32)
atg_threshold :: extern proc(out__: *Tensor, self: Tensor, threshold: Scalar, value: Scalar)
atg_threshold_ :: extern proc(out__: *Tensor, self: Tensor, threshold: Scalar, value: Scalar)
atg_threshold_backward :: extern proc(out__: *Tensor, grad_output: Tensor, self: Tensor, threshold: Scalar)
atg_threshold_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, self: Tensor, threshold: Scalar)
atg_threshold_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, threshold: Scalar, value: Scalar)
atg_tile :: extern proc(out__: *Tensor, self: Tensor, dims_data: *i64, dims_len: i32)
atg_to :: extern proc(out__: *Tensor, self: Tensor, device: i32)
atg_to_dense :: extern proc(out__: *Tensor, self: Tensor, dtype: i32, masked_grad: bool)
atg_to_dense_backward :: extern proc(out__: *Tensor, grad: Tensor, input: Tensor, masked_grad: bool)
atg_to_device :: extern proc(out__: *Tensor, self: Tensor, device: i32, dtype: i32, non_blocking: bool, copy: bool)
atg_to_dtype :: extern proc(out__: *Tensor, self: Tensor, dtype: i32, non_blocking: bool, copy: bool)
atg_to_dtype_layout :: extern proc(out__: *Tensor, self: Tensor, options_kind: i32, options_device: i32, non_blocking: bool, copy: bool)
atg_to_mkldnn :: extern proc(out__: *Tensor, self: Tensor, dtype: i32)
atg_to_mkldnn_backward :: extern proc(out__: *Tensor, grad: Tensor, input: Tensor)
atg_to_mkldnn_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dtype: i32)
atg_to_other :: extern proc(out__: *Tensor, self: Tensor, other: Tensor, non_blocking: bool, copy: bool)
atg_to_padded_tensor :: extern proc(out__: *Tensor, self: Tensor, padding: f64, output_size_data: *i64, output_size_len: i32)
atg_to_padded_tensor_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, padding: f64, output_size_data: *i64, output_size_len: i32)
atg_to_sparse :: extern proc(out__: *Tensor, self: Tensor, layout: i8, blocksize_data: *i64, blocksize_len: i32, dense_dim_v: i64, dense_dim_null: u8)
atg_to_sparse_bsc :: extern proc(out__: *Tensor, self: Tensor, blocksize_data: *i64, blocksize_len: i32, dense_dim_v: i64, dense_dim_null: u8)
atg_to_sparse_bsr :: extern proc(out__: *Tensor, self: Tensor, blocksize_data: *i64, blocksize_len: i32, dense_dim_v: i64, dense_dim_null: u8)
atg_to_sparse_csc :: extern proc(out__: *Tensor, self: Tensor, dense_dim_v: i64, dense_dim_null: u8)
atg_to_sparse_csr :: extern proc(out__: *Tensor, self: Tensor, dense_dim_v: i64, dense_dim_null: u8)
atg_to_sparse_sparse_dim :: extern proc(out__: *Tensor, self: Tensor, sparse_dim: i64)
atg_topk :: extern proc(out__: *Tensor, self: Tensor, k: i64, dim: i64, largest: bool, sorted: bool)
atg_topk_values :: extern proc(out__: *Tensor, values: Tensor, indices: Tensor, self: Tensor, k: i64, dim: i64, largest: bool, sorted: bool)
atg_totype :: extern proc(out__: *Tensor, self: Tensor, scalar_type: i32)
atg_trace :: extern proc(out__: *Tensor, self: Tensor)
atg_trace_backward :: extern proc(out__: *Tensor, grad: Tensor, sizes_data: *i64, sizes_len: i32)
atg_trace_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_transpose :: extern proc(out__: *Tensor, self: Tensor, dim0: i64, dim1: i64)
atg_transpose_ :: extern proc(out__: *Tensor, self: Tensor, dim0: i64, dim1: i64)
atg_transpose_copy :: extern proc(out__: *Tensor, self: Tensor, dim0: i64, dim1: i64)
atg_transpose_copy_int_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim0: i64, dim1: i64)
atg_trapezoid :: extern proc(out__: *Tensor, y: Tensor, dim: i64)
atg_trapezoid_x :: extern proc(out__: *Tensor, y: Tensor, x: Tensor, dim: i64)
atg_trapz :: extern proc(out__: *Tensor, y: Tensor, x: Tensor, dim: i64)
atg_trapz_dx :: extern proc(out__: *Tensor, y: Tensor, dx: f64, dim: i64)
atg_triangular_solve :: extern proc(out__: *Tensor, self: Tensor, A: Tensor, upper: bool, transpose: bool, unitriangular: bool)
atg_triangular_solve_x :: extern proc(out__: *Tensor, X: Tensor, M: Tensor, self: Tensor, A: Tensor, upper: bool, transpose: bool, unitriangular: bool)
atg_tril :: extern proc(out__: *Tensor, self: Tensor, diagonal: i64)
atg_tril_ :: extern proc(out__: *Tensor, self: Tensor, diagonal: i64)
atg_tril_indices :: extern proc(out__: *Tensor, row: i64, col: i64, offset: i64, options_kind: i32, options_device: i32)
atg_tril_indices_out :: extern proc(out__: *Tensor, out: Tensor, row: i64, col: i64, offset: i64)
atg_tril_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, diagonal: i64)
atg_triplet_margin_loss :: extern proc(out__: *Tensor, anchor: Tensor, positive: Tensor, negative: Tensor, margin: f64, p: f64, eps: f64, swap: bool, reduction: i64)
atg_triu :: extern proc(out__: *Tensor, self: Tensor, diagonal: i64)
atg_triu_ :: extern proc(out__: *Tensor, self: Tensor, diagonal: i64)
atg_triu_indices :: extern proc(out__: *Tensor, row: i64, col: i64, offset: i64, options_kind: i32, options_device: i32)
atg_triu_indices_out :: extern proc(out__: *Tensor, out: Tensor, row: i64, col: i64, offset: i64)
atg_triu_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, diagonal: i64)
atg_true_divide :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_true_divide_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_true_divide_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_true_divide_scalar :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_true_divide_scalar_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_trunc :: extern proc(out__: *Tensor, self: Tensor)
atg_trunc_ :: extern proc(out__: *Tensor, self: Tensor)
atg_trunc_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_type_as :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_unbind :: extern fn(self: Tensor, dim: i64) *Tensor
atg_unbind_copy :: extern fn(self: Tensor, dim: i64) *Tensor
atg_unbind_copy_int_out :: extern proc(out_data: *Tensor, out_len: i32, self: Tensor, dim: i64)
atg_unflatten :: extern proc(out__: *Tensor, self: Tensor, dim: i64, sizes_data: *i64, sizes_len: i32)
atg_unflatten_dense_tensors :: extern fn(flat: Tensor, tensors_data: *Tensor, tensors_len: i32) *Tensor
atg_unfold :: extern proc(out__: *Tensor, self: Tensor, dimension: i64, size: i64, step: i64)
atg_unfold_backward :: extern proc(out__: *Tensor, grad_in: Tensor, input_sizes_data: *i64, input_sizes_len: i32, dim: i64, size: i64, step: i64)
atg_unfold_backward_out :: extern proc(out__: *Tensor, out: Tensor, grad_in: Tensor, input_sizes_data: *i64, input_sizes_len: i32, dim: i64, size: i64, step: i64)
atg_unfold_copy :: extern proc(out__: *Tensor, self: Tensor, dimension: i64, size: i64, step: i64)
atg_unfold_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dimension: i64, size: i64, step: i64)
atg_uniform :: extern proc(out__: *Tensor, self: Tensor, from: f64, to: f64)
atg_uniform_ :: extern proc(out__: *Tensor, self: Tensor, from: f64, to: f64)
atg_uniform_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, from: f64, to: f64)
atg_unique_consecutive :: extern proc(out__: *Tensor, self: Tensor, return_inverse: bool, return_counts: bool, dim_v: i64, dim_null: u8)
atg_unique_consecutive_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, self: Tensor, return_inverse: bool, return_counts: bool, dim_v: i64, dim_null: u8)
atg_unique_dim :: extern proc(out__: *Tensor, self: Tensor, dim: i64, sorted: bool, return_inverse: bool, return_counts: bool)
atg_unique_dim_consecutive :: extern proc(out__: *Tensor, self: Tensor, dim: i64, return_inverse: bool, return_counts: bool)
atg_unique_dim_consecutive_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, self: Tensor, dim: i64, return_inverse: bool, return_counts: bool)
atg_unique_dim_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, out2: Tensor, self: Tensor, dim: i64, sorted: bool, return_inverse: bool, return_counts: bool)
atg_unsafe_chunk :: extern fn(self: Tensor, chunks: i64, dim: i64) *Tensor
atg_unsafe_split :: extern fn(self: Tensor, split_size: i64, dim: i64) *Tensor
atg_unsafe_split_tensor_out :: extern proc(out_data: *Tensor, out_len: i32, self: Tensor, split_size: i64, dim: i64)
atg_unsafe_split_with_sizes :: extern fn(self: Tensor, split_sizes_data: *i64, split_sizes_len: i32, dim: i64) *Tensor
atg_unsafe_split_with_sizes_out :: extern proc(out_data: *Tensor, out_len: i32, self: Tensor, split_sizes_data: *i64, split_sizes_len: i32, dim: i64)
atg_unsqueeze :: extern proc(out__: *Tensor, self: Tensor, dim: i64)
atg_unsqueeze_ :: extern proc(out__: *Tensor, self: Tensor, dim: i64)
atg_unsqueeze_copy :: extern proc(out__: *Tensor, self: Tensor, dim: i64)
atg_unsqueeze_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim: i64)
atg_upsample_bicubic2d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_bicubic2d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, align_corners: bool, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_bicubic2d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, align_corners: bool, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_bicubic2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_bicubic2d_vec :: extern proc(out__: *Tensor, input: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scale_factors_data: *f64, scale_factors_len: i32)
atg_upsample_bilinear2d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_bilinear2d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, align_corners: bool, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_bilinear2d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, align_corners: bool, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_bilinear2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_bilinear2d_vec :: extern proc(out__: *Tensor, input: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scale_factors_data: *f64, scale_factors_len: i32)
atg_upsample_bilinear2d_vec_out :: extern proc(out__: *Tensor, out: Tensor, input: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scale_factors_data: *f64, scale_factors_len: i32)
atg_upsample_linear1d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scales_v: f64, scales_null: u8)
atg_upsample_linear1d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, align_corners: bool, scales_v: f64, scales_null: u8)
atg_upsample_linear1d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, align_corners: bool, scales_v: f64, scales_null: u8)
atg_upsample_linear1d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scales_v: f64, scales_null: u8)
atg_upsample_linear1d_vec :: extern proc(out__: *Tensor, input: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scale_factors_data: *f64, scale_factors_len: i32)
atg_upsample_nearest1d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, scales_v: f64, scales_null: u8)
atg_upsample_nearest1d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, scales_v: f64, scales_null: u8)
atg_upsample_nearest1d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, scales_v: f64, scales_null: u8)
atg_upsample_nearest1d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, scales_v: f64, scales_null: u8)
atg_upsample_nearest1d_vec :: extern proc(out__: *Tensor, input: Tensor, output_size_data: *i64, output_size_len: i32, scale_factors_data: *f64, scale_factors_len: i32)
atg_upsample_nearest2d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_nearest2d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_nearest2d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_nearest2d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_nearest2d_vec :: extern proc(out__: *Tensor, input: Tensor, output_size_data: *i64, output_size_len: i32, scale_factors_data: *f64, scale_factors_len: i32)
atg_upsample_nearest2d_vec_out :: extern proc(out__: *Tensor, out: Tensor, input: Tensor, output_size_data: *i64, output_size_len: i32, scale_factors_data: *f64, scale_factors_len: i32)
atg_upsample_nearest3d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, scales_d_v: f64, scales_d_null: u8, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_nearest3d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, scales_d_v: f64, scales_d_null: u8, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_nearest3d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, scales_d_v: f64, scales_d_null: u8, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_nearest3d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, scales_d_v: f64, scales_d_null: u8, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_nearest3d_vec :: extern proc(out__: *Tensor, input: Tensor, output_size_data: *i64, output_size_len: i32, scale_factors_data: *f64, scale_factors_len: i32)
atg_upsample_trilinear3d :: extern proc(out__: *Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scales_d_v: f64, scales_d_null: u8, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_trilinear3d_backward :: extern proc(out__: *Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, align_corners: bool, scales_d_v: f64, scales_d_null: u8, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_trilinear3d_backward_grad_input :: extern proc(out__: *Tensor, grad_input: Tensor, grad_output: Tensor, output_size_data: *i64, output_size_len: i32, input_size_data: *i64, input_size_len: i32, align_corners: bool, scales_d_v: f64, scales_d_null: u8, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_trilinear3d_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scales_d_v: f64, scales_d_null: u8, scales_h_v: f64, scales_h_null: u8, scales_w_v: f64, scales_w_null: u8)
atg_upsample_trilinear3d_vec :: extern proc(out__: *Tensor, input: Tensor, output_size_data: *i64, output_size_len: i32, align_corners: bool, scale_factors_data: *f64, scale_factors_len: i32)
atg_value_selecting_reduction_backward :: extern proc(out__: *Tensor, grad: Tensor, dim: i64, indices: Tensor, sizes_data: *i64, sizes_len: i32, keepdim: bool)
atg_values :: extern proc(out__: *Tensor, self: Tensor)
atg_values_copy :: extern proc(out__: *Tensor, self: Tensor)
atg_values_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_vander :: extern proc(out__: *Tensor, x: Tensor, n_v: i64, n_null: u8, increasing: bool)
atg_var :: extern proc(out__: *Tensor, self: Tensor, unbiased: bool)
atg_var_correction :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, correction: Scalar, keepdim: bool)
atg_var_correction_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, correction: Scalar, keepdim: bool)
atg_var_dim :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, unbiased: bool, keepdim: bool)
atg_var_mean :: extern proc(out__: *Tensor, self: Tensor, unbiased: bool)
atg_var_mean_correction :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, correction: Scalar, keepdim: bool)
atg_var_mean_correction_out :: extern proc(out__: *Tensor, out0: Tensor, out1: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, correction: Scalar, keepdim: bool)
atg_var_mean_dim :: extern proc(out__: *Tensor, self: Tensor, dim_data: *i64, dim_len: i32, unbiased: bool, keepdim: bool)
atg_var_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dim_data: *i64, dim_len: i32, unbiased: bool, keepdim: bool)
atg_vdot :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_vdot_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_view :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg_view_as :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_view_as_complex :: extern proc(out__: *Tensor, self: Tensor)
atg_view_as_complex_copy :: extern proc(out__: *Tensor, self: Tensor)
atg_view_as_complex_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_view_as_real :: extern proc(out__: *Tensor, self: Tensor)
atg_view_as_real_copy :: extern proc(out__: *Tensor, self: Tensor)
atg_view_as_real_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_view_copy :: extern proc(out__: *Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg_view_copy_dtype :: extern proc(out__: *Tensor, self: Tensor, dtype: i32)
atg_view_copy_dtype_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, dtype: i32)
atg_view_copy_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, size_data: *i64, size_len: i32)
atg_view_dtype :: extern proc(out__: *Tensor, self: Tensor, dtype: i32)
atg_vsplit :: extern fn(self: Tensor, sections: i64) *Tensor
atg_vsplit_array :: extern fn(self: Tensor, indices_data: *i64, indices_len: i32) *Tensor
atg_vstack :: extern proc(out__: *Tensor, tensors_data: *Tensor, tensors_len: i32)
atg_vstack_out :: extern proc(out__: *Tensor, out: Tensor, tensors_data: *Tensor, tensors_len: i32)
atg_where :: extern fn(condition: Tensor) *Tensor
atg_where_scalar :: extern proc(out__: *Tensor, condition: Tensor, self_scalar: Scalar, other: Scalar)
atg_where_scalarother :: extern proc(out__: *Tensor, condition: Tensor, self: Tensor, other: Scalar)
atg_where_scalarself :: extern proc(out__: *Tensor, condition: Tensor, self_scalar: Scalar, other: Tensor)
atg_where_self :: extern proc(out__: *Tensor, condition: Tensor, self: Tensor, other: Tensor)
atg_where_self_out :: extern proc(out__: *Tensor, out: Tensor, condition: Tensor, self: Tensor, other: Tensor)
atg_xlogy :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_xlogy_ :: extern proc(out__: *Tensor, self: Tensor, other: Tensor)
atg_xlogy_outscalar_other :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Scalar)
atg_xlogy_outscalar_self :: extern proc(out__: *Tensor, out: Tensor, self_scalar: Scalar, other: Tensor)
atg_xlogy_outtensor :: extern proc(out__: *Tensor, out: Tensor, self: Tensor, other: Tensor)
atg_xlogy_scalar_other :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_xlogy_scalar_other_ :: extern proc(out__: *Tensor, self: Tensor, other: Scalar)
atg_xlogy_scalar_self :: extern proc(out__: *Tensor, self_scalar: Scalar, other: Tensor)
atg_zero :: extern proc(out__: *Tensor, self: Tensor)
atg_zero_ :: extern proc(out__: *Tensor, self: Tensor)
atg_zero_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_zeros :: extern proc(out__: *Tensor, size_data: *i64, size_len: i32, options_kind: i32, options_device: i32)
atg_zeros_like :: extern proc(out__: *Tensor, self: Tensor)
atg_zeros_like_out :: extern proc(out__: *Tensor, out: Tensor, self: Tensor)
atg_zeros_out :: extern proc(out__: *Tensor, out: Tensor, size_data: *i64, size_len: i32)
