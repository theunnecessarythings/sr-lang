package raylib

// ------------------------------------------------------------
// Basic Types
// ------------------------------------------------------------

Color :: struct { r: u8, g: u8, b: u8, a: u8 }

// ------------------------------------------------------------
// Constants
// ------------------------------------------------------------

PI :: 3.14159265358979323846
DEG2RAD :: (PI / 180.0)
RAD2DEG :: (180.0 / PI)

// ------------------------------------------------------------
// Colors (subset)
// ------------------------------------------------------------
LIGHTGRAY :: Color{r: 200, g: 200, b: 200, a: 255} // Light Gray
GRAY :: Color{r: 130, g: 130, b: 130, a: 255}      // Gray
DARKGRAY :: Color{r: 80, g: 80, b: 80, a: 255}     // Dark Gray
YELLOW :: Color{r: 253, g: 249, b: 0, a: 255}      // Yellow
GOLD :: Color{r: 255, g: 203, b: 0, a: 255}        // Gold
ORANGE :: Color{r: 255, g: 161, b: 0, a: 255}      // Orange
PINK :: Color{r: 255, g: 109, b: 194, a: 255}      // Pink
RED :: Color{r: 230, g: 41, b: 55, a: 255}         // Red
MAROON :: Color{r: 190, g: 33, b: 55, a: 255}      // Maroon
GREEN :: Color{r: 0, g: 228, b: 48, a: 255}        // Green
LIME :: Color{r: 0, g: 158, b: 47, a: 255}         // Lime
DARKGREEN :: Color{r: 0, g: 117, b: 44, a: 255}    // Dark Green
SKYBLUE :: Color{r: 102, g: 191, b: 255, a: 255}   // Sky Blue
BLUE :: Color{r: 0, g: 121, b: 241, a: 255}        // Blue
DARKBLUE :: Color{r: 0, g: 82, b: 172, a: 255}     // Dark Blue
PURPLE :: Color{r: 200, g: 122, b: 255, a: 255}    // Purple
VIOLET :: Color{r: 135, g: 60, b: 190, a: 255}     // Violet
DARKPURPLE :: Color{r: 112, g: 31, b: 126, a: 255} // Dark Purple
BEIGE :: Color{r: 211, g: 176, b: 131, a: 255}     // Beige
BROWN :: Color{r: 127, g: 106, b: 79, a: 255}      // Brown
DARKBROWN :: Color{r: 76, g: 63, b: 47, a: 255}    // Dark Brown

WHITE :: Color{r: 255, g: 255, b: 255, a: 255} // White
BLACK :: Color{r: 0, g: 0, b: 0, a: 255}       // Black
BLANK :: Color{r: 0, g: 0, b: 0, a: 0}         // Blank (Transparent)
MAGENTA :: Color{r: 255, g: 0, b: 255, a: 255} // Magenta
RAYWHITE :: Color{r: 245, g: 245, b: 245, a: 255} // My own White (raylib logo)

//----------------------------------------------------------------------------------
// Structures Definition
//----------------------------------------------------------------------------------
Vector2 :: struct { x: f32, y: f32 }
Vector3 :: struct { x: f32, y: f32, z: f32 }
Vector4 :: struct { x: f32, y: f32, z: f32, w: f32 }
Quaternion :: Vector4
Matrix :: struct {
    m0: f32,  m4: f32,  m8: f32,  m12: f32,
    m1: f32,  m5: f32,  m9: f32,  m13: f32,
    m2: f32,  m6: f32,  m10: f32, m14: f32,
    m3: f32,  m7: f32,  m11: f32, m15: f32,
}
Rectangle :: struct { x: f32, y: f32, width: f32, height: f32 }
Image :: struct { data: *void, width: i32, height: i32, mipmaps: i32, format: i32 }
Texture :: struct { id: u32, width: i32, height: i32, mipmaps: i32, format: i32 }
Texture2D :: Texture
TextureCubemap :: Texture
RenderTexture :: struct { id: u32, texture: Texture, depth: Texture }
RenderTexture2D :: RenderTexture
NPatchInfo :: struct { source: Rectangle, left: i32, top: i32, right: i32, bottom: i32, layout: i32 }
GlyphInfo :: struct { value: i32, offsetX: i32, offsetY: i32, advanceX: i32, image: Image }
Font :: struct { baseSize: i32, glyphCount: i32, glyphPadding: i32, texture: Texture2D, recs: *Rectangle, glyphs: *GlyphInfo }
Camera3D :: struct { position: Vector3, target: Vector3, up: Vector3, fovy: f32, projection: i32 }
Camera :: Camera3D
Camera2D :: struct { offset: Vector2, target: Vector2, rotation: f32, zoom: f32 }
Mesh :: struct {
    vertexCount: i32, triangleCount: i32,
    vertices: *f32, texcoords: *f32, texcoords2: *f32, normals: *f32, tangents: *f32,
    colors: *u8, indices: *u16,
    animVertices: *f32, animNormals: *f32, boneIds: *u8, boneWeights: *f32,
    boneMatrices: *Matrix, boneCount: i32,
    vaoId: u32, vboId: *u32,
}
Shader :: struct { id: u32, locs: *i32 }
MaterialMap :: struct { texture: Texture2D, color: Color, value: f32 }
Material :: struct { shader: Shader, maps: *MaterialMap, params: [4]f32 }
Transform :: struct { translation: Vector3, rotation: Quaternion, scale: Vector3 }
BoneInfo :: struct { name: [32]i8, parent: i32 }
Model :: struct {
    transform: Matrix,
    meshCount: i32, materialCount: i32, meshes: *Mesh, materials: *Material, meshMaterial: *i32,
    boneCount: i32, bones: *BoneInfo, bindPose: *Transform,
}
ModelAnimation :: struct { boneCount: i32, frameCount: i32, bones: *BoneInfo, framePoses: **Transform, name: [32]i8 }
Ray :: struct { position: Vector3, direction: Vector3 }
RayCollision :: struct { hit: bool, distance: f32, point: Vector3, normal: Vector3 }
BoundingBox :: struct { min: Vector3, max: Vector3 }
Wave :: struct { frameCount: u32, sampleRate: u32, sampleSize: u32, channels: u32, data: *void }
rAudioBuffer :: *void
rAudioProcessor :: *void
AudioStream :: struct { buffer: *rAudioBuffer, processor: *rAudioProcessor, sampleRate: u32, sampleSize: u32, channels: u32 }
Sound :: struct { stream: AudioStream, frameCount: u32 }
Music :: struct { stream: AudioStream, frameCount: u32, looping: bool, ctxType: i32, ctxData: *void }
VrDeviceInfo :: struct {
    hResolution: i32, vResolution: i32, hScreenSize: f32, vScreenSize: f32,
    eyeToScreenDistance: f32, lensSeparationDistance: f32, interpupillaryDistance: f32,
    lensDistortionValues: [4]f32, chromaAbCorrection: [4]f32,
}
VrStereoConfig :: struct {
    projection: [2]Matrix, viewOffset: [2]Matrix,
    leftLensCenter: [2]f32, rightLensCenter: [2]f32,
    leftScreenCenter: [2]f32, rightScreenCenter: [2]f32,
    scale: [2]f32, scaleIn: [2]f32,
}
FilePathList :: struct { capacity: u32, count: u32, paths: **i8 }
// AutomationEvent :: struct { frame: u32, type: u32, params: [4]i32 }
// AutomationEventList :: struct { capacity: u32, count: u32, events: *AutomationEvent }

//----------------------------------------------------------------------------------
// Enumerators Definition
//----------------------------------------------------------------------------------
ConfigFlags :: enum (u32) {
  FLAG_VSYNC_HINT = 0x40,
  FLAG_FULLSCREEN_MODE = 0x2,
  FLAG_WINDOW_RESIZABLE = 0x4,
  FLAG_WINDOW_UNDECORATED = 0x8,
  FLAG_WINDOW_HIDDEN = 0x80,
  FLAG_WINDOW_MINIMIZED = 0x200,
  FLAG_WINDOW_MAXIMIZED = 0x400,
  FLAG_WINDOW_UNFOCUSED = 0x800,
  FLAG_WINDOW_TOPMOST = 0x1000,
  FLAG_WINDOW_ALWAYS_RUN = 0x100,
  FLAG_WINDOW_TRANSPARENT = 0x10,
  FLAG_WINDOW_HIGHDPI = 0x2000,
  FLAG_WINDOW_MOUSE_PASSTHROUGH = 0x4000,
  FLAG_BORDERLESS_WINDOWED_MODE = 0x8000,
  FLAG_MSAA_4X_HINT = 0x20,
  FLAG_INTERLACED_HINT = 0x10000,
}

TraceLogLevel :: enum {
  LOG_ALL = 0,
  LOG_TRACE,
  LOG_DEBUG,
  LOG_INFO,
  LOG_WARNING,
  LOG_ERROR,
  LOG_FATAL,
  LOG_NONE,
}

KeyboardKey :: enum {
  KEY_NULL = 0,
  KEY_APOSTROPHE = 39,
  KEY_COMMA = 44,
  KEY_MINUS = 45,
  KEY_PERIOD = 46,
  KEY_SLASH = 47,
  KEY_ZERO = 48,
  KEY_ONE = 49,
  KEY_TWO = 50,
  KEY_THREE = 51,
  KEY_FOUR = 52,
  KEY_FIVE = 53,
  KEY_SIX = 54,
  KEY_SEVEN = 55,
  KEY_EIGHT = 56,
  KEY_NINE = 57,
  KEY_SEMICOLON = 59,
  KEY_EQUAL = 61,
  KEY_A = 65, KEY_B = 66, KEY_C = 67, KEY_D = 68, KEY_E = 69, KEY_F = 70,
  KEY_G = 71, KEY_H = 72, KEY_I = 73, KEY_J = 74, KEY_K = 75, KEY_L = 76,
  KEY_M = 77, KEY_N = 78, KEY_O = 79, KEY_P = 80, KEY_Q = 81, KEY_R = 82,
  KEY_S = 83, KEY_T = 84, KEY_U = 85, KEY_V = 86, KEY_W = 87, KEY_X = 88, KEY_Y = 89, KEY_Z = 90,
  KEY_LEFT_BRACKET = 91,
  KEY_BACKSLASH = 92,
  KEY_RIGHT_BRACKET = 93,
  KEY_GRAVE = 96,
  KEY_SPACE = 32,
  KEY_ESCAPE = 256,
  KEY_ENTER = 257,
  KEY_TAB = 258,
  KEY_BACKSPACE = 259,
  KEY_INSERT = 260,
  KEY_DELETE = 261,
  KEY_RIGHT = 262, KEY_LEFT = 263, KEY_DOWN = 264, KEY_UP = 265,
  KEY_PAGE_UP = 266, KEY_PAGE_DOWN = 267,
  KEY_HOME = 268, KEY_END = 269,
  KEY_CAPS_LOCK = 280, KEY_SCROLL_LOCK = 281, KEY_NUM_LOCK = 282, KEY_PRINT_SCREEN = 283, KEY_PAUSE = 284,
  KEY_F1 = 290, KEY_F2 = 291, KEY_F3 = 292, KEY_F4 = 293, KEY_F5 = 294, KEY_F6 = 295, KEY_F7 = 296, KEY_F8 = 297, KEY_F9 = 298, KEY_F10 = 299, KEY_F11 = 300, KEY_F12 = 301,
  KEY_LEFT_SHIFT = 340, KEY_LEFT_CONTROL = 341, KEY_LEFT_ALT = 342, KEY_LEFT_SUPER = 343,
  KEY_RIGHT_SHIFT = 344, KEY_RIGHT_CONTROL = 345, KEY_RIGHT_ALT = 346, KEY_RIGHT_SUPER = 347,
  KEY_KB_MENU = 348,
  KEY_KP_0 = 320, KEY_KP_1 = 321, KEY_KP_2 = 322, KEY_KP_3 = 323, KEY_KP_4 = 324, KEY_KP_5 = 325, KEY_KP_6 = 326, KEY_KP_7 = 327, KEY_KP_8 = 328, KEY_KP_9 = 329,
  KEY_KP_DECIMAL = 330, KEY_KP_DIVIDE = 331, KEY_KP_MULTIPLY = 332, KEY_KP_SUBTRACT = 333, KEY_KP_ADD = 334, KEY_KP_ENTER = 335, KEY_KP_EQUAL = 336,
  KEY_BACK = 4, KEY_MENU = 5, KEY_VOLUME_UP = 24, KEY_VOLUME_DOWN = 25,
}

MouseButton :: enum {
  MOUSE_BUTTON_LEFT = 0,
  MOUSE_BUTTON_RIGHT = 1,
  MOUSE_BUTTON_MIDDLE = 2,
  MOUSE_BUTTON_SIDE = 3,
  MOUSE_BUTTON_EXTRA = 4,
  MOUSE_BUTTON_FORWARD = 5,
  MOUSE_BUTTON_BACK = 6,
}
MOUSE_LEFT_BUTTON :: MouseButton.MOUSE_BUTTON_LEFT
MOUSE_RIGHT_BUTTON :: MouseButton.MOUSE_BUTTON_RIGHT
MOUSE_MIDDLE_BUTTON :: MouseButton.MOUSE_BUTTON_MIDDLE

MouseCursor :: enum {
  MOUSE_CURSOR_DEFAULT = 0,
  MOUSE_CURSOR_ARROW,
  MOUSE_CURSOR_IBEAM,
  MOUSE_CURSOR_CROSSHAIR,
  MOUSE_CURSOR_POINTING_HAND,
  MOUSE_CURSOR_RESIZE_EW,
  MOUSE_CURSOR_RESIZE_NS,
  MOUSE_CURSOR_RESIZE_NWSE,
  MOUSE_CURSOR_RESIZE_NESW,
  MOUSE_CURSOR_RESIZE_ALL,
  MOUSE_CURSOR_NOT_ALLOWED,
}

GamepadButton :: enum {
  GAMEPAD_BUTTON_UNKNOWN = 0,
  GAMEPAD_BUTTON_LEFT_FACE_UP,
  GAMEPAD_BUTTON_LEFT_FACE_RIGHT,
  GAMEPAD_BUTTON_LEFT_FACE_DOWN,
  GAMEPAD_BUTTON_LEFT_FACE_LEFT,
  GAMEPAD_BUTTON_RIGHT_FACE_UP,
  GAMEPAD_BUTTON_RIGHT_FACE_RIGHT,
  GAMEPAD_BUTTON_RIGHT_FACE_DOWN,
  GAMEPAD_BUTTON_RIGHT_FACE_LEFT,
  GAMEPAD_BUTTON_LEFT_TRIGGER_1,
  GAMEPAD_BUTTON_LEFT_TRIGGER_2,
  GAMEPAD_BUTTON_RIGHT_TRIGGER_1,
  GAMEPAD_BUTTON_RIGHT_TRIGGER_2,
  GAMEPAD_BUTTON_MIDDLE_LEFT,
  GAMEPAD_BUTTON_MIDDLE,
  GAMEPAD_BUTTON_MIDDLE_RIGHT,
  GAMEPAD_BUTTON_LEFT_THUMB,
  GAMEPAD_BUTTON_RIGHT_THUMB,
}

GamepadAxis :: enum {
  GAMEPAD_AXIS_LEFT_X = 0,
  GAMEPAD_AXIS_LEFT_Y = 1,
  GAMEPAD_AXIS_RIGHT_X = 2,
  GAMEPAD_AXIS_RIGHT_Y = 3,
  GAMEPAD_AXIS_LEFT_TRIGGER = 4,
  GAMEPAD_AXIS_RIGHT_TRIGGER = 5,
}

MaterialMapIndex :: enum {
  MATERIAL_MAP_ALBEDO = 0,
  MATERIAL_MAP_METALNESS,
  MATERIAL_MAP_NORMAL,
  MATERIAL_MAP_ROUGHNESS,
  MATERIAL_MAP_OCCLUSION,
  MATERIAL_MAP_EMISSION,
  MATERIAL_MAP_HEIGHT,
  MATERIAL_MAP_CUBEMAP,
  MATERIAL_MAP_IRRADIANCE,
  MATERIAL_MAP_PREFILTER,
  MATERIAL_MAP_BRDF,
}
MATERIAL_MAP_DIFFUSE :: MaterialMapIndex.MATERIAL_MAP_ALBEDO
MATERIAL_MAP_SPECULAR :: MaterialMapIndex.MATERIAL_MAP_METALNESS

ShaderLocationIndex :: enum {
  SHADER_LOC_VERTEX_POSITION = 0,
  SHADER_LOC_VERTEX_TEXCOORD01,
  SHADER_LOC_VERTEX_TEXCOORD02,
  SHADER_LOC_VERTEX_NORMAL,
  SHADER_LOC_VERTEX_TANGENT,
  SHADER_LOC_VERTEX_COLOR,
  SHADER_LOC_MATRIX_MVP,
  SHADER_LOC_MATRIX_VIEW,
  SHADER_LOC_MATRIX_PROJECTION,
  SHADER_LOC_MATRIX_MODEL,
  SHADER_LOC_MATRIX_NORMAL,
  SHADER_LOC_VECTOR_VIEW,
  SHADER_LOC_COLOR_DIFFUSE,
  SHADER_LOC_COLOR_SPECULAR,
  SHADER_LOC_COLOR_AMBIENT,
  SHADER_LOC_MAP_ALBEDO,
  SHADER_LOC_MAP_METALNESS,
  SHADER_LOC_MAP_NORMAL,
  SHADER_LOC_MAP_ROUGHNESS,
  SHADER_LOC_MAP_OCCLUSION,
  SHADER_LOC_MAP_EMISSION,
  SHADER_LOC_MAP_HEIGHT,
  SHADER_LOC_MAP_CUBEMAP,
  SHADER_LOC_MAP_IRRADIANCE,
  SHADER_LOC_MAP_PREFILTER,
  SHADER_LOC_MAP_BRDF,
  SHADER_LOC_VERTEX_BONEIDS,
  SHADER_LOC_VERTEX_BONEWEIGHTS,
  SHADER_LOC_BONE_MATRICES,
}
SHADER_LOC_MAP_DIFFUSE :: ShaderLocationIndex.SHADER_LOC_MAP_ALBEDO
SHADER_LOC_MAP_SPECULAR :: ShaderLocationIndex.SHADER_LOC_MAP_METALNESS

ShaderUniformDataType :: enum {
  SHADER_UNIFORM_FLOAT = 0,
  SHADER_UNIFORM_VEC2,
  SHADER_UNIFORM_VEC3,
  SHADER_UNIFORM_VEC4,
  SHADER_UNIFORM_INT,
  SHADER_UNIFORM_IVEC2,
  SHADER_UNIFORM_IVEC3,
  SHADER_UNIFORM_IVEC4,
  SHADER_UNIFORM_SAMPLER2D,
}

ShaderAttributeDataType :: enum {
  SHADER_ATTRIB_FLOAT = 0,
  SHADER_ATTRIB_VEC2,
  SHADER_ATTRIB_VEC3,
  SHADER_ATTRIB_VEC4,
}

PixelFormat :: enum {
  PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1,
  PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA,
  PIXELFORMAT_UNCOMPRESSED_R5G6B5,
  PIXELFORMAT_UNCOMPRESSED_R8G8B8,
  PIXELFORMAT_UNCOMPRESSED_R5G5B5A1,
  PIXELFORMAT_UNCOMPRESSED_R4G4B4A4,
  PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,
  PIXELFORMAT_UNCOMPRESSED_R32,
  PIXELFORMAT_UNCOMPRESSED_R32G32B32,
  PIXELFORMAT_UNCOMPRESSED_R32G32B32A32,
  PIXELFORMAT_UNCOMPRESSED_R16,
  PIXELFORMAT_UNCOMPRESSED_R16G16B16,
  PIXELFORMAT_UNCOMPRESSED_R16G16B16A16,
  PIXELFORMAT_COMPRESSED_DXT1_RGB,
  PIXELFORMAT_COMPRESSED_DXT1_RGBA,
  PIXELFORMAT_COMPRESSED_DXT3_RGBA,
  PIXELFORMAT_COMPRESSED_DXT5_RGBA,
  PIXELFORMAT_COMPRESSED_ETC1_RGB,
  PIXELFORMAT_COMPRESSED_ETC2_RGB,
  PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA,
  PIXELFORMAT_COMPRESSED_PVRT_RGB,
  PIXELFORMAT_COMPRESSED_PVRT_RGBA,
  PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA,
  PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA,
}

TextureFilter :: enum {
  TEXTURE_FILTER_POINT = 0,
  TEXTURE_FILTER_BILINEAR,
  TEXTURE_FILTER_TRILINEAR,
  TEXTURE_FILTER_ANISOTROPIC_4X,
  TEXTURE_FILTER_ANISOTROPIC_8X,
  TEXTURE_FILTER_ANISOTROPIC_16X,
}

TextureWrap :: enum {
  TEXTURE_WRAP_REPEAT = 0,
  TEXTURE_WRAP_CLAMP,
  TEXTURE_WRAP_MIRROR_REPEAT,
  TEXTURE_WRAP_MIRROR_CLAMP,
}

CubemapLayout :: enum {
  CUBEMAP_LAYOUT_AUTO_DETECT = 0,
  CUBEMAP_LAYOUT_LINE_VERTICAL,
  CUBEMAP_LAYOUT_LINE_HORIZONTAL,
  CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR,
  CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE,
}

FontType :: enum {
  FONT_DEFAULT = 0,
  FONT_BITMAP,
  FONT_SDF,
}

BlendMode :: enum {
  BLEND_ALPHA = 0,
  BLEND_ADDITIVE,
  BLEND_MULTIPLIED,
  BLEND_ADD_COLORS,
  BLEND_SUBTRACT_COLORS,
  BLEND_ALPHA_PREMULTIPLY,
  BLEND_CUSTOM,
  BLEND_CUSTOM_SEPARATE,
}

Gesture :: enum (u32) {
  GESTURE_NONE = 0,
  GESTURE_TAP = 1,
  GESTURE_DOUBLETAP = 2,
  GESTURE_HOLD = 4,
  GESTURE_DRAG = 8,
  GESTURE_SWIPE_RIGHT = 16,
  GESTURE_SWIPE_LEFT = 32,
  GESTURE_SWIPE_UP = 64,
  GESTURE_SWIPE_DOWN = 128,
  GESTURE_PINCH_IN = 256,
  GESTURE_PINCH_OUT = 512,
}

CameraMode :: enum {
  CAMERA_CUSTOM = 0,
  CAMERA_FREE,
  CAMERA_ORBITAL,
  CAMERA_FIRST_PERSON,
  CAMERA_THIRD_PERSON,
}

CameraProjection :: enum {
  CAMERA_PERSPECTIVE = 0,
  CAMERA_ORTHOGRAPHIC,
}

NPatchLayout :: enum {
  NPATCH_NINE_PATCH = 0,
  NPATCH_THREE_PATCH_VERTICAL,
  NPATCH_THREE_PATCH_HORIZONTAL,
}

// Callbacks to hook some internal functions
// WARNING: These callbacks are intended for advanced users
TraceLogCallback :: extern fn(logLevel: i32, text: string, args: any) void
LoadFileDataCallback :: extern fn(fileName: string, dataSize: *i32) *u8
SaveFileDataCallback :: extern fn(fileName: string, data: *void, dataSize: i32) bool
LoadFileTextCallback :: extern fn(fileName: string) string
SaveFileTextCallback :: extern fn(fileName: string, text: string) bool

//------------------------------------------------------------------------------------
// Window and Graphics Device Functions (Module: core)
//------------------------------------------------------------------------------------
InitWindow :: extern proc(width: i32, height: i32, title: string)
CloseWindow :: extern proc()
bool WindowShouldClose :: extern fn() bool
IsWindowReady :: extern fn() bool
IsWindowFullscreen :: extern fn() bool
IsWindowHidden :: extern fn() bool
IsWindowMinimized :: extern fn() bool
IsWindowMaximized :: extern fn() bool
IsWindowFocused :: extern fn() bool
IsWindowResized :: extern fn() bool
IsWindowState :: extern fn(flag: u32) bool
SetWindowState :: extern proc(flags: u32)
ClearWindowState :: extern proc(flags: u32)
ToggleFullscreen :: extern proc()
ToggleBorderlessWindowed :: extern proc()
MaximizeWindow :: extern proc()
MinimizeWindow :: extern proc()
RestoreWindow :: extern proc()
SetWindowIcon :: extern proc(image: Image)
SetWindowIcons :: extern proc(images: *Image, count: i32)
SetWindowTitle :: extern proc(title: string)
SetWindowPosition :: extern proc(x: i32, y: i32)
SetWindowMonitor :: extern proc(monitor: i32)
SetWindowMinSize :: extern proc(width: i32, height: i32)
SetWindowMaxSize :: extern proc(width: i32, height: i32)
SetWindowSize :: extern proc(width: i32, height: i32)
SetWindowOpacity :: extern proc(opacity: f32)
SetWindowFocused :: extern proc()
GetWindowHandle :: extern fn() *void
GetScreenWidth :: extern fn() i32
GetScreenHeight :: extern fn() i32
GetRenderWidth :: extern fn() i32
GetRenderHeight :: extern fn() i32
GetMonitorCount :: extern fn() i32
GetCurrentMonitor :: extern fn() i32
GetMonitorPosition :: extern fn(monitor: i32) Vector2
GetMonitorWidth :: extern fn(monitor: i32) i32
GetMonitorHeight :: extern fn(monitor: i32) i32
GetMonitorPhysicalWidth :: extern fn(monitor: i32) i32
GetMonitorPhysicalHeight :: extern fn(monitor: i32) i32
GetMonitorRefreshRate :: extern fn(monitor: i32) i32
GetWindowPosition :: extern fn() Vector2
GetWindowScaleDPI :: extern fn() Vector2
GetMonitorName :: extern fn(monitor: i32) string
SetClipboardText :: extern proc(text: string)
GetClipboardText :: extern fn() string
GetClipboardImage :: extern fn() Image
EnableEventWaiting :: extern proc()
DisableEventWaiting :: extern proc()
ShowCursor :: extern proc()
HideCursor :: extern proc()
IsCursorHidden :: extern fn() bool
EnableCursor :: extern proc()
DisableCursor :: extern proc()
IsCursorOnScreen :: extern fn() bool
ClearBackground :: extern proc(color: Color)
BeginDrawing :: extern proc()
EndDrawing :: extern proc()
BeginMode2D :: extern proc(camera: Camera2D)
EndMode2D :: extern proc()
BeginMode3D :: extern proc(camera: Camera3D)
EndMode3D :: extern proc()
BeginTextureMode :: extern proc(target: RenderTexture2D)
EndTextureMode :: extern proc()
BeginShaderMode :: extern proc(shader: Shader)
EndShaderMode :: extern proc()
BeginBlendMode :: extern proc(mode: i32)
EndBlendMode :: extern proc()
BeginScissorMode :: extern proc(x: i32, y: i32, width: i32, height: i32)
EndScissorMode :: extern proc()
BeginVrStereoMode :: extern proc(config: VrStereoConfig)
EndVrStereoMode :: extern proc()
LoadVrStereoConfig :: extern fn(device: VrDeviceInfo) VrStereoConfig
UnloadVrStereoConfig :: extern proc(config: VrStereoConfig)
LoadShader :: extern fn(vsFileName: string, fsFileName: string) Shader
LoadShaderFromMemory :: extern fn(vsCode: string, fsCode: string) Shader
IsShaderValid :: extern fn(shader: Shader) bool
GetShaderLocation :: extern fn(shader: Shader, uniformName: string) i32
GetShaderLocationAttrib :: extern fn(shader: Shader, attribName: string) i32
SetShaderValue :: extern proc(shader: Shader, locIndex: i32, value: *void, uniformType: i32)
SetShaderValueV :: extern proc(shader: Shader, locIndex: i32, value: *void, uniformType: i32, count: i32)
SetShaderValueMatrix :: extern proc(shader: Shader, locIndex: i32, mat: Matrix)
SetShaderValueTexture :: extern proc(shader: Shader, locIndex: i32, texture: Texture2D)
UnloadShader :: extern proc(shader: Shader)
GetScreenToWorldRay :: extern fn(position: Vector2, camera: Camera) Ray
GetScreenToWorldRayEx :: extern fn(position: Vector2, camera: Camera, width: i32, height: i32) Ray
GetWorldToScreen :: extern fn(position: Vector3, camera: Camera) Vector2
GetWorldToScreenEx :: extern fn(position: Vector3, camera: Camera, width: i32, height: i32) Vector2
GetWorldToScreen2D :: extern fn(position: Vector2, camera: Camera2D) Vector2
GetScreenToWorld2D :: extern fn(position: Vector2, camera: Camera2D) Vector2
GetCameraMatrix :: extern fn(camera: Camera) Matrix
GetCameraMatrix2D :: extern fn(camera: Camera2D) Matrix
SetTargetFPS :: extern proc(fps: i32)
GetFrameTime :: extern fn() f32
GetTime :: extern fn() f64
GetFPS :: extern fn() i32
SwapScreenBuffer :: extern proc()
PollInputEvents :: extern proc()
WaitTime :: extern proc(seconds: f64)
SetRandomSeed :: extern proc(seed: u32)
GetRandomValue :: extern fn(min: i32, max: i32) i32
LoadRandomSequence :: extern fn(count: u32, min: i32, max: i32) *i32
UnloadRandomSequence :: extern proc(sequence: *i32)
TakeScreenshot :: extern proc(fileName: string)
SetConfigFlags :: extern proc(flags: u32)
OpenURL :: extern proc(url: string)
TraceLog :: extern proc(logLevel: i32, text: string, args: any)
SetTraceLogLevel :: extern proc(logLevel: i32)
MemAlloc :: extern fn(size: u32) *void
MemRealloc :: extern fn(ptr: *void, size: u32) *void
MemFree :: extern proc(ptr: *void)
SetTraceLogCallback :: extern proc(callback: TraceLogCallback)
SetLoadFileDataCallback :: extern proc(callback: LoadFileDataCallback)
SetSaveFileDataCallback :: extern proc(callback: SaveFileDataCallback)
SetLoadFileTextCallback :: extern proc(callback: LoadFileTextCallback)
SetSaveFileTextCallback :: extern proc(callback: SaveFileTextCallback)
LoadFileData :: extern fn(fileName: string, dataSize: *i32) *u8
UnloadFileData :: extern proc(data: *u8)
SaveFileData :: extern fn(fileName: string, data: *void, dataSize: i32) bool
ExportDataAsCode :: extern fn(data: *u8, dataSize: i32, fileName: string) bool
LoadFileText :: extern fn(fileName: string) string
UnloadFileText :: extern proc(text: string)
SaveFileText :: extern fn(fileName: string, text: string) bool
FileExists :: extern fn(fileName: string) bool
DirectoryExists :: extern fn(dirPath: string) bool
IsFileExtension :: extern fn(fileName: string, ext: string) bool
GetFileLength :: extern fn(fileName: string) i32
GetFileExtension :: extern fn(fileName: string) string
GetFileName :: extern fn(filePath: string) string
GetFileNameWithoutExt :: extern fn(filePath: string) string
GetDirectoryPath :: extern fn(filePath: string) string
GetPrevDirectoryPath :: extern fn(dirPath: string) string
GetWorkingDirectory :: extern fn() string
GetApplicationDirectory :: extern fn() string
MakeDirectory :: extern fn(dirPath: string) i32
ChangeDirectory :: extern fn(dir: string) bool
IsPathFile :: extern fn(path: string) bool
IsFileNameValid :: extern fn(fileName: string) bool
LoadDirectoryFiles :: extern fn(dirPath: string) FilePathList
LoadDirectoryFilesEx :: extern fn(basePath: string, filter: string, scanSubdirs: bool) FilePathList
UnloadDirectoryFiles :: extern proc(files: FilePathList)
IsFileDropped :: extern fn() bool
LoadDroppedFiles :: extern fn() FilePathList
UnloadDroppedFiles :: extern proc(files: FilePathList)
GetFileModTime :: extern fn(fileName: string) i64
CompressData :: extern fn(data: *u8, dataSize: i32, compDataSize: *i32) *u8
DecompressData :: extern fn(compData: *u8, compDataSize: i32, dataSize: *i32) *u8
EncodeDataBase64 :: extern fn(data: *u8, dataSize: i32, outputSize: *i32) string
DecodeDataBase64 :: extern fn(data: *u8, outputSize: *i32) *u8
ComputeCRC32 :: extern fn(data: *u8, dataSize: i32) u32
ComputeMD5 :: extern fn(data: *u8, dataSize: i32) *u32
ComputeSHA1 :: extern fn(data: *u8, dataSize: i32) *u32
// LoadAutomationEventList :: extern fn(fileName: string) AutomationEventList
// UnloadAutomationEventList :: extern proc(list: AutomationEventList)
// ExportAutomationEventList :: extern fn(list: AutomationEventList, fileName: string) bool
// SetAutomationEventList :: extern proc(list: *AutomationEventList)
SetAutomationEventBaseFrame :: extern proc(frame: i32)
StartAutomationEventRecording :: extern proc()
StopAutomationEventRecording :: extern proc()
// PlayAutomationEvent :: extern proc(event: AutomationEvent)
IsKeyPressed :: extern fn(key: i32) bool
IsKeyPressedRepeat :: extern fn(key: i32) bool
IsKeyDown :: extern fn(key: i32) bool
IsKeyReleased :: extern fn(key: i32) bool
IsKeyUp :: extern fn(key: i32) bool
GetKeyPressed :: extern fn() i32
GetCharPressed :: extern fn() i32
SetExitKey :: extern proc(key: i32)
IsGamepadAvailable :: extern fn(gamepad: i32) bool
GetGamepadName :: extern fn(gamepad: i32) string
IsGamepadButtonPressed :: extern fn(gamepad: i32, button: i32) bool
IsGamepadButtonDown :: extern fn(gamepad: i32, button: i32) bool
IsGamepadButtonReleased :: extern fn(gamepad: i32, button: i32) bool
IsGamepadButtonUp :: extern fn(gamepad: i32, button: i32) bool
GetGamepadButtonPressed :: extern fn() i32
GetGamepadAxisCount :: extern fn(gamepad: i32) i32
GetGamepadAxisMovement :: extern fn(gamepad: i32, axis: i32) f32
SetGamepadMappings :: extern fn(mappings: string) i32
SetGamepadVibration :: extern proc(gamepad: i32, leftMotor: f32, rightMotor: f32, duration: f32)
IsMouseButtonPressed :: extern fn(button: i32) bool
IsMouseButtonDown :: extern fn(button: i32) bool
IsMouseButtonReleased :: extern fn(button: i32) bool
IsMouseButtonUp :: extern fn(button: i32) bool
GetMouseX :: extern fn() i32
GetMouseY :: extern fn() i32
GetMousePosition :: extern fn() Vector2
GetMouseDelta :: extern fn() Vector2
SetMousePosition :: extern proc(x: i32, y: i32)
SetMouseOffset :: extern proc(offsetX: i32, offsetY: i32)
SetMouseScale :: extern proc(scaleX: f32, scaleY: f32)
GetMouseWheelMove :: extern fn() f32
GetMouseWheelMoveV :: extern fn() Vector2
SetMouseCursor :: extern proc(cursor: i32)
GetTouchX :: extern fn() i32
GetTouchY :: extern fn() i32
GetTouchPosition :: extern fn(index: i32) Vector2
GetTouchPointId :: extern fn(index: i32) i32
GetTouchPointCount :: extern fn() i32
SetGesturesEnabled :: extern proc(flags: u32)
IsGestureDetected :: extern fn(gesture: u32) bool
GetGestureDetected :: extern fn() i32
GetGestureHoldDuration :: extern fn() f32
GetGestureDragVector :: extern fn() Vector2
GetGestureDragAngle :: extern fn() f32
GetGesturePinchVector :: extern fn() Vector2
GetGesturePinchAngle :: extern fn() f32
UpdateCamera :: extern proc(camera: *Camera, mode: i32)
UpdateCameraPro :: extern proc(camera: *Camera, movement: Vector3, rotation: Vector3, zoom: f32)

//------------------------------------------------------------------------------------
// Basic Shapes Drawing Functions (Module: shapes)
//------------------------------------------------------------------------------------
SetShapesTexture :: extern proc(texture: Texture2D, source: Rectangle)
GetShapesTexture :: extern fn() Texture2D
GetShapesTextureRectangle :: extern fn() Rectangle
DrawPixel :: extern proc(posX: i32, posY: i32, color: Color)
DrawPixelV :: extern proc(position: Vector2, color: Color)
DrawLine :: extern proc(startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, color: Color)
DrawLineV :: extern proc(startPos: Vector2, endPos: Vector2, color: Color)
DrawLineEx :: extern proc(startPos: Vector2, endPos: Vector2, thick: f32, color: Color)
DrawLineStrip :: extern proc(points: *const Vector2, pointCount: i32, color: Color)
DrawLineBezier :: extern proc(startPos: Vector2, endPos: Vector2, thick: f32, color: Color)
DrawCircle :: extern proc(centerX: i32, centerY: i32, radius: f32, color: Color)
DrawCircleSector :: extern proc(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color)
DrawCircleSectorLines :: extern proc(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color)
DrawCircleGradient :: extern proc(centerX: i32, centerY: i32, radius: f32, inner: Color, outer: Color)
DrawCircleV :: extern proc(center: Vector2, radius: f32, color: Color)
DrawCircleLines :: extern proc(centerX: i32, centerY: i32, radius: f32, color: Color)
DrawCircleLinesV :: extern proc(center: Vector2, radius: f32, color: Color)
DrawEllipse :: extern proc(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: Color)
DrawEllipseLines :: extern proc(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: Color)
DrawRing :: extern proc(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color)
DrawRingLines :: extern proc(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color)
DrawRectangle :: extern proc(posX: i32, posY: i32, width: i32, height: i32, color: Color)
DrawRectangleV :: extern proc(position: Vector2, size: Vector2, color: Color)
DrawRectangleRec :: extern proc(rec: Rectangle, color: Color)
DrawRectanglePro :: extern proc(rec: Rectangle, origin: Vector2, rotation: f32, color: Color)
DrawRectangleGradientV :: extern proc(posX: i32, posY: i32, width: i32, height: i32, top: Color, bottom: Color)
DrawRectangleGradientH :: extern proc(posX: i32, posY: i32, width: i32, height: i32, left: Color, right: Color)
DrawRectangleGradientEx :: extern proc(rec: Rectangle, topLeft: Color, bottomLeft: Color, topRight: Color, bottomRight: Color)
DrawRectangleLines :: extern proc(posX: i32, posY: i32, width: i32, height: i32, color: Color)
DrawRectangleLinesEx :: extern proc(rec: Rectangle, lineThick: f32, color: Color)
DrawRectangleRounded :: extern proc(rec: Rectangle, roundness: f32, segments: i32, color: Color)
DrawRectangleRoundedLines :: extern proc(rec: Rectangle, roundness: f32, segments: i32, color: Color)
DrawRectangleRoundedLinesEx :: extern proc(rec: Rectangle, roundness: f32, segments: i32, lineThick: f32, color: Color)
DrawTriangle :: extern proc(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)
DrawTriangleLines :: extern proc(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)
DrawTriangleFan :: extern proc(points: *const Vector2, pointCount: i32, color: Color)
DrawTriangleStrip :: extern proc(points: *const Vector2, pointCount: i32, color: Color)
DrawPoly :: extern proc(center: Vector2, sides: i32, radius: f32, rotation: f32, color: Color)
DrawPolyLines :: extern proc(center: Vector2, sides: i32, radius: f32, rotation: f32, color: Color)
DrawPolyLinesEx :: extern proc(center: Vector2, sides: i32, radius: f32, rotation: f32, lineThick: f32, color: Color)
DrawSplineLinear :: extern proc(points: *const Vector2, pointCount: i32, thick: f32, color: Color)
DrawSplineBasis :: extern proc(points: *const Vector2, pointCount: i32, thick: f32, color: Color)
DrawSplineCatmullRom :: extern proc(points: *const Vector2, pointCount: i32, thick: f32, color: Color)
DrawSplineBezierQuadratic :: extern proc(points: *const Vector2, pointCount: i32, thick: f32, color: Color)
DrawSplineBezierCubic :: extern proc(points: *const Vector2, pointCount: i32, thick: f32, color: Color)
DrawSplineSegmentLinear :: extern proc(p1: Vector2, p2: Vector2, thick: f32, color: Color)
DrawSplineSegmentBasis :: extern proc(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: f32, color: Color)
DrawSplineSegmentCatmullRom :: extern proc(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: f32, color: Color)
DrawSplineSegmentBezierQuadratic :: extern proc(p1: Vector2, c2: Vector2, p3: Vector2, thick: f32, color: Color)
DrawSplineSegmentBezierCubic :: extern proc(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, thick: f32, color: Color)
GetSplinePointLinear :: extern fn(startPos: Vector2, endPos: Vector2, t: f32) Vector2
GetSplinePointBasis :: extern fn(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: f32) Vector2
GetSplinePointCatmullRom :: extern fn(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: f32) Vector2
GetSplinePointBezierQuad :: extern fn(p1: Vector2, c2: Vector2, p3: Vector2, t: f32) Vector2
GetSplinePointBezierCubic :: extern fn(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, t: f32) Vector2
CheckCollisionRecs :: extern fn(rec1: Rectangle, rec2: Rectangle) bool
CheckCollisionCircles :: extern fn(center1: Vector2, radius1: f32, center2: Vector2, radius2: f32) bool
CheckCollisionCircleRec :: extern fn(center: Vector2, radius: f32, rec: Rectangle) bool
CheckCollisionCircleLine :: extern fn(center: Vector2, radius: f32, p1: Vector2, p2: Vector2) bool
CheckCollisionPointRec :: extern fn(point: Vector2, rec: Rectangle) bool
CheckCollisionPointCircle :: extern fn(point: Vector2, center: Vector2, radius: f32) bool
CheckCollisionPointTriangle :: extern fn(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) bool
CheckCollisionPointLine :: extern fn(point: Vector2, p1: Vector2, p2: Vector2, threshold: i32) bool
CheckCollisionPointPoly :: extern fn(point: Vector2, points: *const Vector2, pointCount: i32) bool
CheckCollisionLines :: extern fn(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: *Vector2) bool
GetCollisionRec :: extern fn(rec1: Rectangle, rec2: Rectangle) Rectangle
LoadImage :: extern fn(fileName: string) Image
LoadImageRaw :: extern fn(fileName: string, width: i32, height: i32, format: i32, headerSize: i32) Image
LoadImageAnim :: extern fn(fileName: string, frames: *i32) Image
LoadImageAnimFromMemory :: extern fn(fileType: string, fileData: *const u8, dataSize: i32, frames: *i32) Image
LoadImageFromMemory :: extern fn(fileType: string, fileData: *const u8, dataSize: i32) Image
LoadImageFromTexture :: extern fn(texture: Texture2D) Image
LoadImageFromScreen :: extern fn() Image
IsImageValid :: extern fn(image: Image) bool
UnloadImage :: extern proc(image: Image)
ExportImage :: extern fn(image: Image, fileName: string) bool
ExportImageToMemory :: extern fn(image: Image, fileType: string, fileSize: *i32) *u8
ExportImageAsCode :: extern fn(image: Image, fileName: string) bool
GenImageColor :: extern fn(width: i32, height: i32, color: Color) Image
GenImageGradientLinear :: extern fn(width: i32, height: i32, direction: i32, start: Color, end: Color) Image
GenImageGradientRadial :: extern fn(width: i32, height: i32, density: f32, inner: Color, outer: Color) Image
GenImageGradientSquare :: extern fn(width: i32, height: i32, density: f32, inner: Color, outer: Color) Image
GenImageChecked :: extern fn(width: i32, height: i32, checksX: i32, checksY: i32, col1: Color, col2: Color) Image
GenImageWhiteNoise :: extern fn(width: i32, height: i32, factor: f32) Image
GenImagePerlinNoise :: extern fn(width: i32, height: i32, offsetX: i32, offsetY: i32, scale: f32) Image
GenImageCellular :: extern fn(width: i32, height: i32, tileSize: i32) Image
GenImageText :: extern fn(width: i32, height: i32, text: string) Image
ImageCopy :: extern fn(image: Image) Image
ImageFromImage :: extern fn(image: Image, rec: Rectangle) Image
ImageFromChannel :: extern fn(image: Image, selectedChannel: i32) Image
ImageText :: extern fn(text: string, fontSize: i32, color: Color) Image
ImageTextEx :: extern fn(font: Font, text: string, fontSize: f32, spacing: f32, tint: Color) Image
ImageFormat :: extern proc(image: *Image, newFormat: i32)
ImageToPOT :: extern proc(image: *Image, fill: Color)
ImageCrop :: extern proc(image: *Image, crop: Rectangle)
ImageAlphaCrop :: extern proc(image: *Image, threshold: f32)
ImageAlphaClear :: extern proc(image: *Image, color: Color, threshold: f32)
ImageAlphaMask :: extern proc(image: *Image, alphaMask: Image)
ImageAlphaPremultiply :: extern proc(image: *Image)
ImageBlurGaussian :: extern proc(image: *Image, blurSize: i32)
ImageKernelConvolution :: extern proc(image: *Image, kernel: *const f32, kernelSize: i32)
ImageResize :: extern proc(image: *Image, newWidth: i32, newHeight: i32)
ImageResizeNN :: extern proc(image: *Image, newWidth: i32, newHeight: i32)
ImageResizeCanvas :: extern proc(image: *Image, newWidth: i32, newHeight: i32, offsetX: i32, offsetY: i32, fill: Color)
ImageMipmaps :: extern proc(image: *Image)
ImageDither :: extern proc(image: *Image, rBpp: i32, gBpp: i32, bBpp: i32, aBpp: i32)
ImageFlipVertical :: extern proc(image: *Image)
ImageFlipHorizontal :: extern proc(image: *Image)
ImageRotate :: extern proc(image: *Image, degrees: i32)
ImageRotateCW :: extern proc(image: *Image)
ImageRotateCCW :: extern proc(image: *Image)
ImageColorTint :: extern proc(image: *Image, color: Color)
ImageColorInvert :: extern proc(image: *Image)
ImageColorGrayscale :: extern proc(image: *Image)
ImageColorContrast :: extern proc(image: *Image, contrast: f32)
ImageColorBrightness :: extern proc(image: *Image, brightness: i32)
ImageColorReplace :: extern proc(image: *Image, color: Color, replace: Color)
LoadImageColors :: extern fn(image: Image) *Color
LoadImagePalette :: extern fn(image: Image, maxPaletteSize: i32, colorCount: *i32) *Color
UnloadImageColors :: extern proc(colors: *Color)
UnloadImagePalette :: extern proc(colors: *Color)
GetImageAlphaBorder :: extern fn(image: Image, threshold: f32) Rectangle
GetImageColor :: extern fn(image: Image, x: i32, y: i32) Color

// Image drawing functions
// NOTE: Image software-rendering functions (CPU)
ImageClearBackground :: extern proc(dst: *Image, color: Color)
ImageDrawPixel :: extern proc(dst: *Image, posX: i32, posY: i32, color: Color)
ImageDrawPixelV :: extern proc(dst: *Image, position: Vector2, color: Color)
ImageDrawLine :: extern proc(dst: *Image, startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, color: Color)
ImageDrawLineV :: extern proc(dst: *Image, start: Vector2, end: Vector2, color: Color)
ImageDrawLineEx :: extern proc(dst: *Image, start: Vector2, end: Vector2, thick: i32, color: Color)
ImageDrawCircle :: extern proc(dst: *Image, centerX: i32, centerY: i32, radius: i32, color: Color)
ImageDrawCircleV :: extern proc(dst: *Image, center: Vector2, radius: i32, color: Color)
ImageDrawCircleLines :: extern proc(dst: *Image, centerX: i32, centerY: i32, radius: i32, color: Color)
ImageDrawCircleLinesV :: extern proc(dst: *Image, center: Vector2, radius: i32, color: Color)
ImageDrawRectangle :: extern proc(dst: *Image, posX: i32, posY: i32, width: i32, height: i32, color: Color)
ImageDrawRectangleV :: extern proc(dst: *Image, position: Vector2, size: Vector2, color: Color)
ImageDrawRectangleRec :: extern proc(dst: *Image, rec: Rectangle, color: Color)
ImageDrawRectangleLines :: extern proc(dst: *Image, rec: Rectangle, thick: i32, color: Color)
ImageDrawTriangle :: extern proc(dst: *Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color)
ImageDrawTriangleEx :: extern proc(dst: *Image, v1: Vector2, v2: Vector2, v3: Vector2, c1: Color, c2: Color, c3: Color)
ImageDrawTriangleLines :: extern proc(dst: *Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color)
ImageDrawTriangleFan :: extern proc(dst: *Image, points: *Vector2, pointCount: i32, color: Color)
ImageDrawTriangleStrip :: extern proc(dst: *Image, points: *Vector2, pointCount: i32, color: Color)
ImageDraw :: extern proc(dst: *Image, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color)
ImageDrawText :: extern proc(dst: *Image, text: string, posX: i32, posY: i32, fontSize: i32, color: Color)
ImageDrawTextEx :: extern proc(dst: *Image, font: Font, text: string, position: Vector2, fontSize: f32, spacing: f32, tint: Color)

// Texture loading functions
// NOTE: These functions require GPU access
LoadTexture :: extern fn(fileName: string) Texture2D
LoadTextureFromImage :: extern fn(image: Image) Texture2D
LoadTextureCubemap :: extern fn(image: Image, layout: i32) TextureCubemap
LoadRenderTexture :: extern fn(width: i32, height: i32) RenderTexture2D
IsTextureValid :: extern fn(texture: Texture2D) bool
UnloadTexture :: extern proc(texture: Texture2D)
IsRenderTextureValid :: extern fn(target: RenderTexture2D) bool
UnloadRenderTexture :: extern proc(target: RenderTexture2D)
UpdateTexture :: extern proc(texture: Texture2D, pixels: *const void)
UpdateTextureRec :: extern proc(texture: Texture2D, rec: Rectangle, pixels: *const void)

// Texture configuration functions
GenTextureMipmaps :: extern proc(texture: *Texture2D)
SetTextureFilter :: extern proc(texture: Texture2D, filter: i32)
SetTextureWrap :: extern proc(texture: Texture2D, wrap: i32)

// Texture drawing functions
DrawTexture :: extern proc(texture: Texture2D, posX: i32, posY: i32, tint: Color)
DrawTextureV :: extern proc(texture: Texture2D, position: Vector2, tint: Color)
DrawTextureEx :: extern proc(texture: Texture2D, position: Vector2, rotation: f32, scale: f32, tint: Color)
DrawTextureRec :: extern proc(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color)
DrawTexturePro :: extern proc(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color)
DrawTextureNPatch :: extern proc(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color)

// Color/pixel related functions
ColorIsEqual :: extern fn(col1: Color, col2: Color) bool
Fade :: extern fn(color: Color, alpha: f32) Color
ColorToInt :: extern fn(color: Color) i32
ColorNormalize :: extern fn(color: Color) Vector4
ColorFromNormalized :: extern fn(normalized: Vector4) Color
ColorToHSV :: extern fn(color: Color) Vector3
ColorFromHSV :: extern fn(hue: f32, saturation: f32, value: f32) Color
ColorTint :: extern fn(color: Color, tint: Color) Color
ColorBrightness :: extern fn(color: Color, factor: f32) Color
ColorContrast :: extern fn(color: Color, contrast: f32) Color
ColorAlpha :: extern fn(color: Color, alpha: f32) Color
ColorAlphaBlend :: extern fn(dst: Color, src: Color, tint: Color) Color
ColorLerp :: extern fn(color1: Color, color2: Color, factor: f32) Color
GetColor :: extern fn(hexValue: u32) Color
GetPixelColor :: extern fn(srcPtr: *void, format: i32) Color
SetPixelColor :: extern proc(dstPtr: *void, color: Color, format: i32)
GetPixelDataSize :: extern fn(width: i32, height: i32, format: i32) i32

// Font loading/unloading functions
GetFontDefault :: extern fn() Font
LoadFont :: extern fn(fileName: string) Font
LoadFontEx :: extern fn(fileName: string, fontSize: i32, codepoints: *i32, codepointCount: i32) Font
LoadFontFromImage :: extern fn(image: Image, key: Color, firstChar: i32) Font
LoadFontFromMemory :: extern fn(fileType: string, fileData: *const u8, dataSize: i32, fontSize: i32, codepoints: *i32, codepointCount: i32) Font
IsFontValid :: extern fn(font: Font) bool
// LoadFontData :: extern fn(fileData: *const u8, dataSize: i32, fontSize: i32, codepoints: *i32, codepointCount: i32, type: i32) *GlyphInfo
GenImageFontAtlas :: extern fn(glyphs: *const GlyphInfo, glyphRecs: **Rectangle, glyphCount: i32, fontSize: i32, padding: i32, packMethod: i32) Image
UnloadFontData :: extern proc(glyphs: *GlyphInfo, glyphCount: i32)
UnloadFont :: extern proc(font: Font)
ExportFontAsCode :: extern fn(font: Font, fileName: string) bool

// Text drawing functions
DrawFPS :: extern proc(posX: i32, posY: i32)
DrawText :: extern proc(text: string, posX: i32, posY: i32, fontSize: i32, color: Color)
DrawTextEx :: extern proc(font: Font, text: string, position: Vector2, fontSize: f32, spacing: f32, tint: Color)
DrawTextPro :: extern proc(font: Font, text: string, position: Vector2, origin: Vector2, rotation: f32, fontSize: f32, spacing: f32, tint: Color)
DrawTextCodepoint :: extern proc(font: Font, codepoint: i32, position: Vector2, fontSize: f32, tint: Color)
DrawTextCodepoints :: extern proc(font: Font, codepoints: *const i32, codepointCount: i32, position: Vector2, fontSize: f32, spacing: f32, tint: Color)

// Text font info functions
SetTextLineSpacing :: extern proc(spacing: i32)
MeasureText :: extern fn(text: string, fontSize: i32) i32
MeasureTextEx :: extern fn(font: Font, text: string, fontSize: f32, spacing: f32) Vector2
GetGlyphIndex :: extern fn(font: Font, codepoint: i32) i32
GetGlyphInfo :: extern fn(font: Font, codepoint: i32) GlyphInfo
GetGlyphAtlasRec :: extern fn(font: Font, codepoint: i32) Rectangle

// Text codepoints management functions (unicode characters)
LoadUTF8 :: extern fn(codepoints: *const i32, length: i32) string
UnloadUTF8 :: extern proc(text: string)
LoadCodepoints :: extern fn(text: string, count: *i32) *i32
UnloadCodepoints :: extern proc(codepoints: *i32)
GetCodepointCount :: extern fn(text: string) i32
GetCodepoint :: extern fn(text: string, codepointSize: *i32) i32
GetCodepointNext :: extern fn(text: string, codepointSize: *i32) i32
GetCodepointPrevious :: extern fn(text: string, codepointSize: *i32) i32
CodepointToUTF8 :: extern fn(codepoint: i32, utf8Size: *i32) string

// Text strings management functions (no UTF-8 strings, only byte chars)
// NOTE: Some strings allocate memory internally for returned strings, just be careful!
TextCopy :: extern fn(dst: *i8, src: string) i32
TextIsEqual :: extern fn(text1: string, text2: string) bool
TextLength :: extern fn(text: string) u32
TextFormat :: extern fn(text: string, args: any) string
TextSubtext :: extern fn(text: string, position: i32, length: i32) string
TextReplace :: extern fn(text: string, replace: string, by: string) string
TextInsert :: extern fn(text: string, insert: string, position: i32) string
TextJoin :: extern fn(textList: **const string, count: i32, delimiter: string) string
TextSplit :: extern fn(text: string, delimiter: i8, count: *i32) **string
TextAppend :: extern proc(text: *i8, append: string, position: *i32)
TextFindIndex :: extern fn(text: string, find: string) i32
TextToUpper :: extern fn(text: string) string
TextToLower :: extern fn(text: string) string
TextToPascal :: extern fn(text: string) string
TextToSnake :: extern fn(text: string) string
TextToCamel :: extern fn(text: string) string
TextToInteger :: extern fn(text: string) i32
TextToFloat :: extern fn(text: string) f32

//------------------------------------------------------------------------------------
// Basic 3d Shapes Drawing Functions (Module: models)
//------------------------------------------------------------------------------------
DrawLine3D :: extern proc(startPos: Vector3, endPos: Vector3, color: Color)
DrawPoint3D :: extern proc(position: Vector3, color: Color)
DrawCircle3D :: extern proc(center: Vector3, radius: f32, rotationAxis: Vector3, rotationAngle: f32, color: Color)
DrawTriangle3D :: extern proc(v1: Vector3, v2: Vector3, v3: Vector3, color: Color)
DrawTriangleStrip3D :: extern proc(points: *const Vector3, pointCount: i32, color: Color)
DrawCube :: extern proc(position: Vector3, width: f32, height: f32, length: f32, color: Color)
DrawCubeV :: extern proc(position: Vector3, size: Vector3, color: Color)
DrawCubeWires :: extern proc(position: Vector3, width: f32, height: f32, length: f32, color: Color)
DrawCubeWiresV :: extern proc(position: Vector3, size: Vector3, color: Color)
DrawSphere :: extern proc(centerPos: Vector3, radius: f32, color: Color)
DrawSphereEx :: extern proc(centerPos: Vector3, radius: f32, rings: i32, slices: i32, color: Color)
DrawSphereWires :: extern proc(centerPos: Vector3, radius: f32, rings: i32, slices: i32, color: Color)
DrawCylinder :: extern proc(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: i32, color: Color)
DrawCylinderEx :: extern proc(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: i32, color: Color)
DrawCylinderWires :: extern proc(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: i32, color: Color)
DrawCylinderWiresEx :: extern proc(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: i32, color: Color)
DrawCapsule :: extern proc(startPos: Vector3, endPos: Vector3, radius: f32, slices: i32, rings: i32, color: Color)
DrawCapsuleWires :: extern proc(startPos: Vector3, endPos: Vector3, radius: f32, slices: i32, rings: i32, color: Color)
DrawPlane :: extern proc(centerPos: Vector3, size: Vector2, color: Color)
DrawRay :: extern proc(ray: Ray, color: Color)
DrawGrid :: extern proc(slices: i32, spacing: f32)

//------------------------------------------------------------------------------------
// Model 3d Loading and Drawing Functions (Module: models)
//------------------------------------------------------------------------------------

// Model management functions
LoadModel :: extern fn(fileName: string) Model
LoadModelFromMesh :: extern fn(mesh: Mesh) Model
IsModelValid :: extern fn(model: Model) bool
UnloadModel :: extern proc(model: Model)
GetModelBoundingBox :: extern fn(model: Model) BoundingBox

// Model drawing functions
DrawModel :: extern proc(model: Model, position: Vector3, scale: f32, tint: Color)
DrawModelEx :: extern proc(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color)
DrawModelWires :: extern proc(model: Model, position: Vector3, scale: f32, tint: Color)
DrawModelWiresEx :: extern proc(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color)
DrawModelPoints :: extern proc(model: Model, position: Vector3, scale: f32, tint: Color)
DrawModelPointsEx :: extern proc(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color)
DrawBoundingBox :: extern proc(box: BoundingBox, color: Color)
DrawBillboard :: extern proc(camera: Camera, texture: Texture2D, position: Vector3, scale: f32, tint: Color)
DrawBillboardRec :: extern proc(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color)
DrawBillboardPro :: extern proc(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: f32, tint: Color)

// Mesh management functions
UploadMesh :: extern proc(mesh: *Mesh, dynamic: bool)
UpdateMeshBuffer :: extern proc(mesh: Mesh, index: i32, data: *const void, dataSize: i32, offset: i32)
UnloadMesh :: extern proc(mesh: Mesh)
DrawMesh :: extern proc(mesh: Mesh, material: Material, transform: Matrix)
DrawMeshInstanced :: extern proc(mesh: Mesh, material: Material, transforms: *const Matrix, instances: i32)
GetMeshBoundingBox :: extern fn(mesh: Mesh) BoundingBox
GenMeshTangents :: extern proc(mesh: *Mesh)
ExportMesh :: extern fn(mesh: Mesh, fileName: string) bool
ExportMeshAsCode :: extern fn(mesh: Mesh, fileName: string) bool

// Mesh generation functions
GenMeshPoly :: extern fn(sides: i32, radius: f32) Mesh
GenMeshPlane :: extern fn(width: f32, length: f32, resX: i32, resZ: i32) Mesh
GenMeshCube :: extern fn(width: f32, height: f32, length: f32) Mesh
GenMeshSphere :: extern fn(radius: f32, rings: i32, slices: i32) Mesh
GenMeshHemiSphere :: extern fn(radius: f32, rings: i32, slices: i32) Mesh
GenMeshCylinder :: extern fn(radius: f32, height: f32, slices: i32) Mesh
GenMeshCone :: extern fn(radius: f32, height: f32, slices: i32) Mesh
GenMeshTorus :: extern fn(radius: f32, size: f32, radSeg: i32, sides: i32) Mesh
GenMeshKnot :: extern fn(radius: f32, size: f32, radSeg: i32, sides: i32) Mesh
GenMeshHeightmap :: extern fn(heightmap: Image, size: Vector3) Mesh
GenMeshCubicmap :: extern fn(cubicmap: Image, cubeSize: Vector3) Mesh

// Material loading/unloading functions
LoadMaterials :: extern fn(fileName: string, materialCount: *i32) *Material
LoadMaterialDefault :: extern fn() Material
IsMaterialValid :: extern fn(material: Material) bool
UnloadMaterial :: extern proc(material: Material)
SetMaterialTexture :: extern proc(material: *Material, mapType: i32, texture: Texture2D)
SetModelMeshMaterial :: extern proc(model: *Model, meshId: i32, materialId: i32)

// Model animations loading/unloading functions
LoadModelAnimations :: extern fn(fileName: string, animCount: *i32) *ModelAnimation
UpdateModelAnimation :: extern proc(model: Model, anim: ModelAnimation, frame: i32)
UpdateModelAnimationBones :: extern proc(model: Model, anim: ModelAnimation, frame: i32)
UnloadModelAnimation :: extern proc(anim: ModelAnimation)
UnloadModelAnimations :: extern proc(animations: *ModelAnimation, animCount: i32)
IsModelAnimationValid :: extern fn(model: Model, anim: ModelAnimation) bool

// Collision detection functions
CheckCollisionSpheres :: extern fn(center1: Vector3, radius1: f32, center2: Vector3, radius2: f32) bool
CheckCollisionBoxes :: extern fn(box1: BoundingBox, box2: BoundingBox) bool
CheckCollisionBoxSphere :: extern fn(box: BoundingBox, center: Vector3, radius: f32) bool
GetRayCollisionSphere :: extern fn(ray: Ray, center: Vector3, radius: f32) RayCollision
GetRayCollisionBox :: extern fn(ray: Ray, box: BoundingBox) RayCollision
GetRayCollisionMesh :: extern fn(ray: Ray, mesh: Mesh, transform: Matrix) RayCollision
GetRayCollisionTriangle :: extern fn(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) RayCollision
GetRayCollisionQuad :: extern fn(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3) RayCollision

//------------------------------------------------------------------------------------
// Audio Loading and Playing Functions (Module: audio)
//------------------------------------------------------------------------------------
AudioCallback :: extern fn(bufferData: *void, frames: u32) void

// Audio device management functions
InitAudioDevice :: extern proc()
CloseAudioDevice :: extern proc()
IsAudioDeviceReady :: extern fn() bool
SetMasterVolume :: extern proc(volume: f32)
GetMasterVolume :: extern fn() f32

// Wave/Sound loading/unloading functions
LoadWave :: extern fn(fileName: string) Wave
LoadWaveFromMemory :: extern fn(fileType: string, fileData: *const u8, dataSize: i32) Wave
IsWaveValid :: extern fn(wave: Wave) bool
LoadSound :: extern fn(fileName: string) Sound
LoadSoundFromWave :: extern fn(wave: Wave) Sound
LoadSoundAlias :: extern fn(source: Sound) Sound
IsSoundValid :: extern fn(sound: Sound) bool
UpdateSound :: extern proc(sound: Sound, data: *const void, sampleCount: i32)
UnloadWave :: extern proc(wave: Wave)
UnloadSound :: extern proc(sound: Sound)
UnloadSoundAlias :: extern proc(alias: Sound)
ExportWave :: extern fn(wave: Wave, fileName: string) bool
ExportWaveAsCode :: extern fn(wave: Wave, fileName: string) bool

// Wave/Sound management functions
PlaySound :: extern proc(sound: Sound)
StopSound :: extern proc(sound: Sound)
PauseSound :: extern proc(sound: Sound)
ResumeSound :: extern proc(sound: Sound)
IsSoundPlaying :: extern fn(sound: Sound) bool
SetSoundVolume :: extern proc(sound: Sound, volume: f32)
SetSoundPitch :: extern proc(sound: Sound, pitch: f32)
SetSoundPan :: extern proc(sound: Sound, pan: f32)
WaveCopy :: extern fn(wave: Wave) Wave
WaveCrop :: extern proc(wave: *Wave, initFrame: i32, finalFrame: i32)
WaveFormat :: extern proc(wave: *Wave, sampleRate: i32, sampleSize: i32, channels: i32)
LoadWaveSamples :: extern fn(wave: Wave) *f32
UnloadWaveSamples :: extern proc(samples: *f32)

// Music management functions
LoadMusicStream :: extern fn(fileName: string) Music
LoadMusicStreamFromMemory :: extern fn(fileType: string, data: *const u8, dataSize: i32) Music
IsMusicValid :: extern fn(music: Music) bool
UnloadMusicStream :: extern proc(music: Music)
PlayMusicStream :: extern proc(music: Music)
IsMusicStreamPlaying :: extern fn(music: Music) bool
UpdateMusicStream :: extern proc(music: Music)
StopMusicStream :: extern proc(music: Music)
PauseMusicStream :: extern proc(music: Music)
ResumeMusicStream :: extern proc(music: Music)
SeekMusicStream :: extern proc(music: Music, position: f32)
SetMusicVolume :: extern proc(music: Music, volume: f32)
SetMusicPitch :: extern proc(music: Music, pitch: f32)
SetMusicPan :: extern proc(music: Music, pan: f32)
GetMusicTimeLength :: extern fn(music: Music) f32
GetMusicTimePlayed :: extern fn(music: Music) f32

// AudioStream management functions
LoadAudioStream :: extern fn(sampleRate: u32, sampleSize: u32, channels: u32) AudioStream
IsAudioStreamValid :: extern fn(stream: AudioStream) bool
UnloadAudioStream :: extern proc(stream: AudioStream)
UpdateAudioStream :: extern proc(stream: AudioStream, data: *const void, frameCount: i32)
IsAudioStreamProcessed :: extern fn(stream: AudioStream) bool
PlayAudioStream :: extern proc(stream: AudioStream)
PauseAudioStream :: extern proc(stream: AudioStream)
ResumeAudioStream :: extern proc(stream: AudioStream)
IsAudioStreamPlaying :: extern fn(stream: AudioStream) bool
StopAudioStream :: extern proc(stream: AudioStream)
SetAudioStreamVolume :: extern proc(stream: AudioStream, volume: f32)
SetAudioStreamPitch :: extern proc(stream: AudioStream, pitch: f32)
SetAudioStreamPan :: extern proc(stream: AudioStream, pan: f32)
SetAudioStreamBufferSizeDefault :: extern proc(size: i32)
SetAudioStreamCallback :: extern proc(stream: AudioStream, callback: AudioCallback)
AttachAudioStreamProcessor :: extern proc(stream: AudioStream, processor: AudioCallback)
DetachAudioStreamProcessor :: extern proc(stream: AudioStream, processor: AudioCallback)
AttachAudioMixedProcessor :: extern proc(processor: AudioCallback)
DetachAudioMixedProcessor :: extern proc(processor: AudioCallback)
