package raylib

// ------------------------------------------------------------
// Basic Types
// ------------------------------------------------------------
Color :: struct {r: u8, g: u8, b: u8, a: u8}

// ------------------------------------------------------------
// Constants
// ------------------------------------------------------------
PI :: 3.14159265358979323846
DEG2RAD :: (PI / 180.0)
RAD2DEG :: (180.0 / PI)

// ------------------------------------------------------------
// Colors (subset)
// ------------------------------------------------------------
LIGHTGRAY :: Color{ r: 200, g: 200, b: 200, a: 255 }

// Light Gray
GRAY :: Color{ r: 130, g: 130, b: 130, a: 255 }

// Gray
DARKGRAY :: Color{ r: 80, g: 80, b: 80, a: 255 }

// Dark Gray
YELLOW :: Color{ r: 253, g: 249, b: 0, a: 255 }

// Yellow
GOLD :: Color{ r: 255, g: 203, b: 0, a: 255 }

// Gold
ORANGE :: Color{ r: 255, g: 161, b: 0, a: 255 }

// Orange
PINK :: Color{ r: 255, g: 109, b: 194, a: 255 }

// Pink
RED :: Color{ r: 230, g: 41, b: 55, a: 255 }

// Red
MAROON :: Color{ r: 190, g: 33, b: 55, a: 255 }

// Maroon
GREEN :: Color{ r: 0, g: 228, b: 48, a: 255 }

// Green
LIME :: Color{ r: 0, g: 158, b: 47, a: 255 }

// Lime
DARKGREEN :: Color{ r: 0, g: 117, b: 44, a: 255 }

// Dark Green
SKYBLUE :: Color{ r: 102, g: 191, b: 255, a: 255 }

// Sky Blue
BLUE :: Color{ r: 0, g: 121, b: 241, a: 255 }

// Blue
DARKBLUE :: Color{ r: 0, g: 82, b: 172, a: 255 }

// Dark Blue
PURPLE :: Color{ r: 200, g: 122, b: 255, a: 255 }

// Purple
VIOLET :: Color{ r: 135, g: 60, b: 190, a: 255 }

// Violet
DARKPURPLE :: Color{ r: 112, g: 31, b: 126, a: 255 }

// Dark Purple
BEIGE :: Color{ r: 211, g: 176, b: 131, a: 255 }

// Beige
BROWN :: Color{ r: 127, g: 106, b: 79, a: 255 }

// Brown
DARKBROWN :: Color{ r: 76, g: 63, b: 47, a: 255 }

// Dark Brown
WHITE :: Color{ r: 255, g: 255, b: 255, a: 255 }

// White
BLACK :: Color{ r: 0, g: 0, b: 0, a: 255 }

// Black
BLANK :: Color{ r: 0, g: 0, b: 0, a: 0 }

// Blank (Transparent)
MAGENTA :: Color{ r: 255, g: 0, b: 255, a: 255 }

// Magenta
RAYWHITE :: Color{ r: 245, g: 245, b: 245, a: 255 }

// My own White (raylib logo)

//----------------------------------------------------------------------------------
// Structures Definition
//----------------------------------------------------------------------------------
Vector2 :: struct {x: f32, y: f32}
Vector3 :: struct {x: f32, y: f32, z: f32}
Vector4 :: struct {x: f32, y: f32, z: f32, w: f32}
Quaternion :: Vector4
Matrix :: struct {
    m0: f32,
    m4: f32,
    m8: f32,
    m12: f32,
    m1: f32,
    m5: f32,
    m9: f32,
    m13: f32,
    m2: f32,
    m6: f32,
    m10: f32,
    m14: f32,
    m3: f32,
    m7: f32,
    m11: f32,
    m15: f32,
}

Rectangle :: struct {x: f32, y: f32, width: f32, height: f32}
Image :: struct {data: *void, width: i32, height: i32, mipmaps: i32, format: i32}
Texture :: struct {id: u32, width: i32, height: i32, mipmaps: i32, format: i32}
Texture2D :: Texture
TextureCubemap :: Texture
RenderTexture :: struct {id: u32, texture: Texture, depth: Texture}
RenderTexture2D :: RenderTexture
NPatchInfo :: struct {source: Rectangle, left: i32, top: i32, right: i32, bottom: i32, layout: i32}
GlyphInfo :: struct {value: i32, offsetX: i32, offsetY: i32, advanceX: i32, image: Image}
Font :: struct {baseSize: i32, glyphCount: i32, glyphPadding: i32, texture: Texture2D, recs: *Rectangle, glyphs: *GlyphInfo}
Camera3D :: struct {position: Vector3, target: Vector3, up: Vector3, fovy: f32, projection: i32}
Camera :: Camera3D
Camera2D :: struct {offset: Vector2, target: Vector2, rotation: f32, zoom: f32}
Mesh :: struct {
    vertexCount: i32,
    triangleCount: i32,
    vertices: *f32,
    texcoords: *f32,
    texcoords2: *f32,
    normals: *f32,
    tangents: *f32,
    colors: *u8,
    indices: *u16,
    animVertices: *f32,
    animNormals: *f32,
    boneIds: *u8,
    boneWeights: *f32,
    boneMatrices: *Matrix,
    boneCount: i32,
    vaoId: u32,
    vboId: *u32,
}

Shader :: struct {id: u32, locs: *i32}
MaterialMap :: struct {texture: Texture2D, color: Color, value: f32}
Material :: struct {shader: Shader, maps: *MaterialMap, params: [4]f32}
Transform :: struct {translation: Vector3, rotation: Quaternion, scale: Vector3}
BoneInfo :: struct {name: [32]i8, parent: i32}
Model :: struct {
    transform: Matrix,
    meshCount: i32,
    materialCount: i32,
    meshes: *Mesh,
    materials: *Material,
    meshMaterial: *i32,
    boneCount: i32,
    bones: *BoneInfo,
    bindPose: *Transform,
}

ModelAnimation :: struct {boneCount: i32, frameCount: i32, bones: *BoneInfo, framePoses: **Transform, name: [32]i8}
Ray :: struct {position: Vector3, direction: Vector3}
RayCollision :: struct {hit: bool, distance: f32, point: Vector3, normal: Vector3}
BoundingBox :: struct {min: Vector3, max: Vector3}
Wave :: struct {frameCount: u32, sampleRate: u32, sampleSize: u32, channels: u32, data: *void}
rAudioBuffer :: *void
rAudioProcessor :: *void
AudioStream :: struct {buffer: *rAudioBuffer, processor: *rAudioProcessor, sampleRate: u32, sampleSize: u32, channels: u32}
Sound :: struct {stream: AudioStream, frameCount: u32}
Music :: struct {stream: AudioStream, frameCount: u32, looping: bool, ctxType: i32, ctxData: *void}
VrDeviceInfo :: struct {
    hResolution: i32,
    vResolution: i32,
    hScreenSize: f32,
    vScreenSize: f32,
    eyeToScreenDistance: f32,
    lensSeparationDistance: f32,
    interpupillaryDistance: f32,
    lensDistortionValues: [4]f32,
    chromaAbCorrection: [4]f32,
}

VrStereoConfig :: struct {
    projection: [2]Matrix,
    viewOffset: [2]Matrix,
    leftLensCenter: [2]f32,
    rightLensCenter: [2]f32,
    leftScreenCenter: [2]f32,
    rightScreenCenter: [2]f32,
    scale: [2]f32,
    scaleIn: [2]f32,
}

FilePathList :: struct {capacity: u32, count: u32, paths: **i8}

// AutomationEvent :: struct { frame: u32, type: u32, params: [4]i32 }
// AutomationEventList :: struct { capacity: u32, count: u32, events: *AutomationEvent }

//----------------------------------------------------------------------------------
// Enumerators Definition
//----------------------------------------------------------------------------------
ConfigFlags :: enum(u32) {
    VSYNC_HINT = 0x40,
    FULLSCREEN_MODE = 0x2,
    WINDOW_RESIZABLE = 0x4,
    WINDOW_UNDECORATED = 0x8,
    WINDOW_HIDDEN = 0x80,
    WINDOW_MINIMIZED = 0x200,
    WINDOW_MAXIMIZED = 0x400,
    WINDOW_UNFOCUSED = 0x800,
    WINDOW_TOPMOST = 0x1000,
    WINDOW_ALWAYS_RUN = 0x100,
    WINDOW_TRANSPARENT = 0x10,
    WINDOW_HIGHDPI = 0x2000,
    WINDOW_MOUSE_PASSTHROUGH = 0x4000,
    BORDERLESS_WINDOWED_MODE = 0x8000,
    MSAA_4X_HINT = 0x20,
    INTERLACED_HINT = 0x10000,
}

TraceLogLevel :: enum {
    ALL = 0,
    TRACE,
    DEBUG,
    INFO,
    WARNING,
    ERROR,
    FATAL,
    NONE,
}

KeyboardKey :: enum {
    NULL = 0,
    APOSTROPHE = 39,
    COMMA = 44,
    MINUS = 45,
    PERIOD = 46,
    SLASH = 47,
    ZERO = 48,
    ONE = 49,
    TWO = 50,
    THREE = 51,
    FOUR = 52,
    FIVE = 53,
    SIX = 54,
    SEVEN = 55,
    EIGHT = 56,
    NINE = 57,
    SEMICOLON = 59,
    EQUAL = 61,
    A = 65,
    B = 66,
    C = 67,
    D = 68,
    E = 69,
    F = 70,
    G = 71,
    H = 72,
    I = 73,
    J = 74,
    K = 75,
    L = 76,
    M = 77,
    N = 78,
    O = 79,
    P = 80,
    Q = 81,
    R = 82,
    S = 83,
    T = 84,
    U = 85,
    V = 86,
    W = 87,
    X = 88,
    Y = 89,
    Z = 90,
    LEFT_BRACKET = 91,
    BACKSLASH = 92,
    RIGHT_BRACKET = 93,
    GRAVE = 96,
    SPACE = 32,
    ESCAPE = 256,
    ENTER = 257,
    TAB = 258,
    BACKSPACE = 259,
    INSERT = 260,
    DELETE = 261,
    RIGHT = 262,
    LEFT = 263,
    DOWN = 264,
    UP = 265,
    PAGE_UP = 266,
    PAGE_DOWN = 267,
    HOME = 268,
    END = 269,
    CAPS_LOCK = 280,
    SCROLL_LOCK = 281,
    NUM_LOCK = 282,
    PRINT_SCREEN = 283,
    PAUSE = 284,
    F1 = 290,
    F2 = 291,
    F3 = 292,
    F4 = 293,
    F5 = 294,
    F6 = 295,
    F7 = 296,
    F8 = 297,
    F9 = 298,
    F10 = 299,
    F11 = 300,
    F12 = 301,
    LEFT_SHIFT = 340,
    LEFT_CONTROL = 341,
    LEFT_ALT = 342,
    LEFT_SUPER = 343,
    RIGHT_SHIFT = 344,
    RIGHT_CONTROL = 345,
    RIGHT_ALT = 346,
    RIGHT_SUPER = 347,
    KB_MENU = 348,
    KP_0 = 320,
    KP_1 = 321,
    KP_2 = 322,
    KP_3 = 323,
    KP_4 = 324,
    KP_5 = 325,
    KP_6 = 326,
    KP_7 = 327,
    KP_8 = 328,
    KP_9 = 329,
    KP_DECIMAL = 330,
    KP_DIVIDE = 331,
    KP_MULTIPLY = 332,
    KP_SUBTRACT = 333,
    KP_ADD = 334,
    KP_ENTER = 335,
    KP_EQUAL = 336,
    BACK = 4,
    MENU = 5,
    VOLUME_UP = 24,
    VOLUME_DOWN = 25,
}

MouseButton :: enum {
    LEFT = 0,
    RIGHT = 1,
    MIDDLE = 2,
    SIDE = 3,
    EXTRA = 4,
    FORWARD = 5,
    BACK = 6,
}

MOUSE_LEFT_BUTTON :: MouseButton.LEFT
MOUSE_RIGHT_BUTTON :: MouseButton.RIGHT
MOUSE_MIDDLE_BUTTON :: MouseButton.MIDDLE

MouseCursor :: enum {
    DEFAULT = 0,
    ARROW,
    IBEAM,
    CROSSHAIR,
    POINTING_HAND,
    RESIZE_EW,
    RESIZE_NS,
    RESIZE_NWSE,
    RESIZE_NESW,
    RESIZE_ALL,
    NOT_ALLOWED,
}

GamepadButton :: enum {
    UNKNOWN = 0,
    LEFT_FACE_UP,
    LEFT_FACE_RIGHT,
    LEFT_FACE_DOWN,
    LEFT_FACE_LEFT,
    RIGHT_FACE_UP,
    RIGHT_FACE_RIGHT,
    RIGHT_FACE_DOWN,
    RIGHT_FACE_LEFT,
    LEFT_TRIGGER_1,
    LEFT_TRIGGER_2,
    RIGHT_TRIGGER_1,
    RIGHT_TRIGGER_2,
    MIDDLE_LEFT,
    MIDDLE,
    MIDDLE_RIGHT,
    LEFT_THUMB,
    RIGHT_THUMB,
}

GamepadAxis :: enum {
    LEFT_X = 0,
    LEFT_Y = 1,
    RIGHT_X = 2,
    RIGHT_Y = 3,
    LEFT_TRIGGER = 4,
    RIGHT_TRIGGER = 5,
}

MaterialMapIndex :: enum {
    ALBEDO = 0,
    METALNESS,
    NORMAL,
    ROUGHNESS,
    OCCLUSION,
    EMISSION,
    HEIGHT,
    CUBEMAP,
    IRRADIANCE,
    PREFILTER,
    BRDF,
}

MATERIAL_MAP_DIFFUSE :: MaterialMapIndex.ALBEDO
MATERIAL_MAP_SPECULAR :: MaterialMapIndex.METALNESS

ShaderLocationIndex :: enum {
    VERTEX_POSITION = 0,
    VERTEX_TEXCOORD01,
    VERTEX_TEXCOORD02,
    VERTEX_NORMAL,
    VERTEX_TANGENT,
    VERTEX_COLOR,
    MATRIX_MVP,
    MATRIX_VIEW,
    MATRIX_PROJECTION,
    MATRIX_MODEL,
    MATRIX_NORMAL,
    VECTOR_VIEW,
    COLOR_DIFFUSE,
    COLOR_SPECULAR,
    COLOR_AMBIENT,
    MAP_ALBEDO,
    MAP_METALNESS,
    MAP_NORMAL,
    MAP_ROUGHNESS,
    MAP_OCCLUSION,
    MAP_EMISSION,
    MAP_HEIGHT,
    MAP_CUBEMAP,
    MAP_IRRADIANCE,
    MAP_PREFILTER,
    MAP_BRDF,
    VERTEX_BONEIDS,
    VERTEX_BONEWEIGHTS,
    BONE_MATRICES,
}

SHADER_LOC_MAP_DIFFUSE :: ShaderLocationIndex.MAP_ALBEDO
SHADER_LOC_MAP_SPECULAR :: ShaderLocationIndex.MAP_METALNESS

ShaderUniformDataType :: enum {
    FLOAT = 0,
    VEC2,
    VEC3,
    VEC4,
    INT,
    IVEC2,
    IVEC3,
    IVEC4,
    SAMPLER2D,
}

ShaderAttributeDataType :: enum {
    FLOAT = 0,
    VEC2,
    VEC3,
    VEC4,
}

PixelFormat :: enum {
    UNCOMPRESSED_GRAYSCALE = 1,
    UNCOMPRESSED_GRAY_ALPHA,
    UNCOMPRESSED_R5G6B5,
    UNCOMPRESSED_R8G8B8,
    UNCOMPRESSED_R5G5B5A1,
    UNCOMPRESSED_R4G4B4A4,
    UNCOMPRESSED_R8G8B8A8,
    UNCOMPRESSED_R32,
    UNCOMPRESSED_R32G32B32,
    UNCOMPRESSED_R32G32B32A32,
    UNCOMPRESSED_R16,
    UNCOMPRESSED_R16G16B16,
    UNCOMPRESSED_R16G16B16A16,
    COMPRESSED_DXT1_RGB,
    COMPRESSED_DXT1_RGBA,
    COMPRESSED_DXT3_RGBA,
    COMPRESSED_DXT5_RGBA,
    COMPRESSED_ETC1_RGB,
    COMPRESSED_ETC2_RGB,
    COMPRESSED_ETC2_EAC_RGBA,
    COMPRESSED_PVRT_RGB,
    COMPRESSED_PVRT_RGBA,
    COMPRESSED_ASTC_4x4_RGBA,
    COMPRESSED_ASTC_8x8_RGBA,
}

TextureFilter :: enum {
    POINT = 0,
    BILINEAR,
    TRILINEAR,
    ANISOTROPIC_4X,
    ANISOTROPIC_8X,
    ANISOTROPIC_16X,
}

TextureWrap :: enum {
    REPEAT = 0,
    CLAMP,
    MIRROR_REPEAT,
    MIRROR_CLAMP,
}

CubemapLayout :: enum {
    AUTO_DETECT = 0,
    LINE_VERTICAL,
    LINE_HORIZONTAL,
    CROSS_THREE_BY_FOUR,
    CROSS_FOUR_BY_THREE,
}

FontType :: enum {
    DEFAULT = 0,
    BITMAP,
    SDF,
}

BlendMode :: enum {
    ALPHA = 0,
    ADDITIVE,
    MULTIPLIED,
    ADD_COLORS,
    SUBTRACT_COLORS,
    ALPHA_PREMULTIPLY,
    CUSTOM,
    CUSTOM_SEPARATE,
}

Gesture :: enum(u32) {
    NONE = 0,
    TAP = 1,
    DOUBLETAP = 2,
    HOLD = 4,
    DRAG = 8,
    SWIPE_RIGHT = 16,
    SWIPE_LEFT = 32,
    SWIPE_UP = 64,
    SWIPE_DOWN = 128,
    PINCH_IN = 256,
    PINCH_OUT = 512,
}

CameraMode :: enum {
    CUSTOM = 0,
    FREE,
    ORBITAL,
    FIRST_PERSON,
    THIRD_PERSON,
}

CameraProjection :: enum {
    PERSPECTIVE = 0,
    ORTHOGRAPHIC,
}

NPatchLayout :: enum {
    NINE_PATCH = 0,
    THREE_PATCH_VERTICAL,
    THREE_PATCH_HORIZONTAL,
}

// Callbacks to hook some internal functions
// WARNING: These callbacks are intended for advanced users
TraceLogCallback :: extern fn(logLevel: i32, text: string, args: any) void
LoadFileDataCallback :: extern fn(fileName: string, dataSize: *i32) *u8
SaveFileDataCallback :: extern fn(fileName: string, data: *void, dataSize: i32) bool
LoadFileTextCallback :: extern fn(fileName: string) string
SaveFileTextCallback :: extern fn(fileName: string, text: string) bool

//------------------------------------------------------------------------------------
// Window and Graphics Device Functions (Module: core)
//------------------------------------------------------------------------------------
InitWindow :: extern proc(width: i32, height: i32, title: string)
CloseWindow :: extern proc()
bool
WindowShouldClose :: extern fn() bool
IsWindowReady :: extern fn() bool
IsWindowFullscreen :: extern fn() bool
IsWindowHidden :: extern fn() bool
IsWindowMinimized :: extern fn() bool
IsWindowMaximized :: extern fn() bool
IsWindowFocused :: extern fn() bool
IsWindowResized :: extern fn() bool
IsWindowState :: extern fn(flag: u32) bool
SetWindowState :: extern proc(flags: u32)
ClearWindowState :: extern proc(flags: u32)
ToggleFullscreen :: extern proc()
ToggleBorderlessWindowed :: extern proc()
MaximizeWindow :: extern proc()
MinimizeWindow :: extern proc()
RestoreWindow :: extern proc()
SetWindowIcon :: extern proc(image: Image)
SetWindowIcons :: extern proc(images: *Image, count: i32)
SetWindowTitle :: extern proc(title: string)
SetWindowPosition :: extern proc(x: i32, y: i32)
SetWindowMonitor :: extern proc(monitor: i32)
SetWindowMinSize :: extern proc(width: i32, height: i32)
SetWindowMaxSize :: extern proc(width: i32, height: i32)
SetWindowSize :: extern proc(width: i32, height: i32)
SetWindowOpacity :: extern proc(opacity: f32)
SetWindowFocused :: extern proc()
GetWindowHandle :: extern fn() *void
GetScreenWidth :: extern fn() i32
GetScreenHeight :: extern fn() i32
GetRenderWidth :: extern fn() i32
GetRenderHeight :: extern fn() i32
GetMonitorCount :: extern fn() i32
GetCurrentMonitor :: extern fn() i32
GetMonitorPosition :: extern fn(monitor: i32) Vector2
GetMonitorWidth :: extern fn(monitor: i32) i32
GetMonitorHeight :: extern fn(monitor: i32) i32
GetMonitorPhysicalWidth :: extern fn(monitor: i32) i32
GetMonitorPhysicalHeight :: extern fn(monitor: i32) i32
GetMonitorRefreshRate :: extern fn(monitor: i32) i32
GetWindowPosition :: extern fn() Vector2
GetWindowScaleDPI :: extern fn() Vector2
GetMonitorName :: extern fn(monitor: i32) string
SetClipboardText :: extern proc(text: string)
GetClipboardText :: extern fn() string
GetClipboardImage :: extern fn() Image
EnableEventWaiting :: extern proc()
DisableEventWaiting :: extern proc()
ShowCursor :: extern proc()
HideCursor :: extern proc()
IsCursorHidden :: extern fn() bool
EnableCursor :: extern proc()
DisableCursor :: extern proc()
IsCursorOnScreen :: extern fn() bool
ClearBackground :: extern proc(color: Color)
BeginDrawing :: extern proc()
EndDrawing :: extern proc()
BeginMode2D :: extern proc(camera: Camera2D)
EndMode2D :: extern proc()
BeginMode3D :: extern proc(camera: Camera3D)
EndMode3D :: extern proc()
BeginTextureMode :: extern proc(target: RenderTexture2D)
EndTextureMode :: extern proc()
BeginShaderMode :: extern proc(shader: Shader)
EndShaderMode :: extern proc()
BeginBlendMode :: extern proc(mode: i32)
EndBlendMode :: extern proc()
BeginScissorMode :: extern proc(x: i32, y: i32, width: i32, height: i32)
EndScissorMode :: extern proc()
BeginVrStereoMode :: extern proc(config: VrStereoConfig)
EndVrStereoMode :: extern proc()
LoadVrStereoConfig :: extern fn(device: VrDeviceInfo) VrStereoConfig
UnloadVrStereoConfig :: extern proc(config: VrStereoConfig)
LoadShader :: extern fn(vsFileName: string, fsFileName: string) Shader
LoadShaderFromMemory :: extern fn(vsCode: string, fsCode: string) Shader
IsShaderValid :: extern fn(shader: Shader) bool
GetShaderLocation :: extern fn(shader: Shader, uniformName: string) i32
GetShaderLocationAttrib :: extern fn(shader: Shader, attribName: string) i32
SetShaderValue :: extern proc(shader: Shader, locIndex: i32, value: *void, uniformType: i32)
SetShaderValueV :: extern proc(shader: Shader, locIndex: i32, value: *void, uniformType: i32, count: i32)
SetShaderValueMatrix :: extern proc(shader: Shader, locIndex: i32, mat: Matrix)
SetShaderValueTexture :: extern proc(shader: Shader, locIndex: i32, texture: Texture2D)
UnloadShader :: extern proc(shader: Shader)
GetScreenToWorldRay :: extern fn(position: Vector2, camera: Camera) Ray
GetScreenToWorldRayEx :: extern fn(position: Vector2, camera: Camera, width: i32, height: i32) Ray
GetWorldToScreen :: extern fn(position: Vector3, camera: Camera) Vector2
GetWorldToScreenEx :: extern fn(position: Vector3, camera: Camera, width: i32, height: i32) Vector2
GetWorldToScreen2D :: extern fn(position: Vector2, camera: Camera2D) Vector2
GetScreenToWorld2D :: extern fn(position: Vector2, camera: Camera2D) Vector2
GetCameraMatrix :: extern fn(camera: Camera) Matrix
GetCameraMatrix2D :: extern fn(camera: Camera2D) Matrix
SetTargetFPS :: extern proc(fps: i32)
GetFrameTime :: extern fn() f32
GetTime :: extern fn() f64
GetFPS :: extern fn() i32
SwapScreenBuffer :: extern proc()
PollInputEvents :: extern proc()
WaitTime :: extern proc(seconds: f64)
SetRandomSeed :: extern proc(seed: u32)
GetRandomValue :: extern fn(min: i32, max: i32) i32
LoadRandomSequence :: extern fn(count: u32, min: i32, max: i32) *i32
UnloadRandomSequence :: extern proc(sequence: *i32)
TakeScreenshot :: extern proc(fileName: string)
SetConfigFlags :: extern proc(flags: u32)
OpenURL :: extern proc(url: string)
TraceLog :: extern proc(logLevel: i32, text: string, args: any)
SetTraceLogLevel :: extern proc(logLevel: i32)
MemAlloc :: extern fn(size: u32) *void
MemRealloc :: extern fn(ptr: *void, size: u32) *void
MemFree :: extern proc(ptr: *void)
SetTraceLogCallback :: extern proc(callback: TraceLogCallback)
SetLoadFileDataCallback :: extern proc(callback: LoadFileDataCallback)
SetSaveFileDataCallback :: extern proc(callback: SaveFileDataCallback)
SetLoadFileTextCallback :: extern proc(callback: LoadFileTextCallback)
SetSaveFileTextCallback :: extern proc(callback: SaveFileTextCallback)
LoadFileData :: extern fn(fileName: string, dataSize: *i32) *u8
UnloadFileData :: extern proc(data: *u8)
SaveFileData :: extern fn(fileName: string, data: *void, dataSize: i32) bool
ExportDataAsCode :: extern fn(data: *u8, dataSize: i32, fileName: string) bool
LoadFileText :: extern fn(fileName: string) string
UnloadFileText :: extern proc(text: string)
SaveFileText :: extern fn(fileName: string, text: string) bool
FileExists :: extern fn(fileName: string) bool
DirectoryExists :: extern fn(dirPath: string) bool
IsFileExtension :: extern fn(fileName: string, ext: string) bool
GetFileLength :: extern fn(fileName: string) i32
GetFileExtension :: extern fn(fileName: string) string
GetFileName :: extern fn(filePath: string) string
GetFileNameWithoutExt :: extern fn(filePath: string) string
GetDirectoryPath :: extern fn(filePath: string) string
GetPrevDirectoryPath :: extern fn(dirPath: string) string
GetWorkingDirectory :: extern fn() string
GetApplicationDirectory :: extern fn() string
MakeDirectory :: extern fn(dirPath: string) i32
ChangeDirectory :: extern fn(dir: string) bool
IsPathFile :: extern fn(path: string) bool
IsFileNameValid :: extern fn(fileName: string) bool
LoadDirectoryFiles :: extern fn(dirPath: string) FilePathList
LoadDirectoryFilesEx :: extern fn(basePath: string, filter: string, scanSubdirs: bool) FilePathList
UnloadDirectoryFiles :: extern proc(files: FilePathList)
IsFileDropped :: extern fn() bool
LoadDroppedFiles :: extern fn() FilePathList
UnloadDroppedFiles :: extern proc(files: FilePathList)
GetFileModTime :: extern fn(fileName: string) i64
CompressData :: extern fn(data: *u8, dataSize: i32, compDataSize: *i32) *u8
DecompressData :: extern fn(compData: *u8, compDataSize: i32, dataSize: *i32) *u8
EncodeDataBase64 :: extern fn(data: *u8, dataSize: i32, outputSize: *i32) string
DecodeDataBase64 :: extern fn(data: *u8, outputSize: *i32) *u8
ComputeCRC32 :: extern fn(data: *u8, dataSize: i32) u32
ComputeMD5 :: extern fn(data: *u8, dataSize: i32) *u32
ComputeSHA1 :: extern fn(data: *u8, dataSize: i32) *u32

// LoadAutomationEventList :: extern fn(fileName: string) AutomationEventList
// UnloadAutomationEventList :: extern proc(list: AutomationEventList)
// ExportAutomationEventList :: extern fn(list: AutomationEventList, fileName: string) bool
// SetAutomationEventList :: extern proc(list: *AutomationEventList)
SetAutomationEventBaseFrame :: extern proc(frame: i32)
StartAutomationEventRecording :: extern proc()
StopAutomationEventRecording :: extern proc()

// PlayAutomationEvent :: extern proc(event: AutomationEvent)
IsKeyPressed :: extern fn(key: i32) bool
IsKeyPressedRepeat :: extern fn(key: i32) bool
IsKeyDown :: extern fn(key: i32) bool
IsKeyReleased :: extern fn(key: i32) bool
IsKeyUp :: extern fn(key: i32) bool
GetKeyPressed :: extern fn() i32
GetCharPressed :: extern fn() i32
SetExitKey :: extern proc(key: i32)
IsGamepadAvailable :: extern fn(gamepad: i32) bool
GetGamepadName :: extern fn(gamepad: i32) string
IsGamepadButtonPressed :: extern fn(gamepad: i32, button: i32) bool
IsGamepadButtonDown :: extern fn(gamepad: i32, button: i32) bool
IsGamepadButtonReleased :: extern fn(gamepad: i32, button: i32) bool
IsGamepadButtonUp :: extern fn(gamepad: i32, button: i32) bool
GetGamepadButtonPressed :: extern fn() i32
GetGamepadAxisCount :: extern fn(gamepad: i32) i32
GetGamepadAxisMovement :: extern fn(gamepad: i32, axis: i32) f32
SetGamepadMappings :: extern fn(mappings: string) i32
SetGamepadVibration :: extern proc(gamepad: i32, leftMotor: f32, rightMotor: f32, duration: f32)
IsMouseButtonPressed :: extern fn(button: i32) bool
IsMouseButtonDown :: extern fn(button: i32) bool
IsMouseButtonReleased :: extern fn(button: i32) bool
IsMouseButtonUp :: extern fn(button: i32) bool
GetMouseX :: extern fn() i32
GetMouseY :: extern fn() i32
GetMousePosition :: extern fn() Vector2
GetMouseDelta :: extern fn() Vector2
SetMousePosition :: extern proc(x: i32, y: i32)
SetMouseOffset :: extern proc(offsetX: i32, offsetY: i32)
SetMouseScale :: extern proc(scaleX: f32, scaleY: f32)
GetMouseWheelMove :: extern fn() f32
GetMouseWheelMoveV :: extern fn() Vector2
SetMouseCursor :: extern proc(cursor: i32)
GetTouchX :: extern fn() i32
GetTouchY :: extern fn() i32
GetTouchPosition :: extern fn(index: i32) Vector2
GetTouchPointId :: extern fn(index: i32) i32
GetTouchPointCount :: extern fn() i32
SetGesturesEnabled :: extern proc(flags: u32)
IsGestureDetected :: extern fn(gesture: u32) bool
GetGestureDetected :: extern fn() i32
GetGestureHoldDuration :: extern fn() f32
GetGestureDragVector :: extern fn() Vector2
GetGestureDragAngle :: extern fn() f32
GetGesturePinchVector :: extern fn() Vector2
GetGesturePinchAngle :: extern fn() f32
UpdateCamera :: extern proc(camera: *Camera, mode: i32)
UpdateCameraPro :: extern proc(camera: *Camera, movement: Vector3, rotation: Vector3, zoom: f32)

//------------------------------------------------------------------------------------
// Basic Shapes Drawing Functions (Module: shapes)
//------------------------------------------------------------------------------------
SetShapesTexture :: extern proc(texture: Texture2D, source: Rectangle)
GetShapesTexture :: extern fn() Texture2D
GetShapesTextureRectangle :: extern fn() Rectangle
DrawPixel :: extern proc(posX: i32, posY: i32, color: Color)
DrawPixelV :: extern proc(position: Vector2, color: Color)
DrawLine :: extern proc(startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, color: Color)
DrawLineV :: extern proc(startPos: Vector2, endPos: Vector2, color: Color)
DrawLineEx :: extern proc(startPos: Vector2, endPos: Vector2, thick: f32, color: Color)
DrawLineStrip :: extern proc(points: *const Vector2, pointCount: i32, color: Color)
DrawLineBezier :: extern proc(startPos: Vector2, endPos: Vector2, thick: f32, color: Color)
DrawCircle :: extern proc(centerX: i32, centerY: i32, radius: f32, color: Color)
DrawCircleSector :: extern proc(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color)
DrawCircleSectorLines :: extern proc(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color)
DrawCircleGradient :: extern proc(centerX: i32, centerY: i32, radius: f32, inner: Color, outer: Color)
DrawCircleV :: extern proc(center: Vector2, radius: f32, color: Color)
DrawCircleLines :: extern proc(centerX: i32, centerY: i32, radius: f32, color: Color)
DrawCircleLinesV :: extern proc(center: Vector2, radius: f32, color: Color)
DrawEllipse :: extern proc(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: Color)
DrawEllipseLines :: extern proc(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: Color)
DrawRing :: extern proc(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color)
DrawRingLines :: extern proc(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color)
DrawRectangle :: extern proc(posX: i32, posY: i32, width: i32, height: i32, color: Color)
DrawRectangleV :: extern proc(position: Vector2, size: Vector2, color: Color)
DrawRectangleRec :: extern proc(rec: Rectangle, color: Color)
DrawRectanglePro :: extern proc(rec: Rectangle, origin: Vector2, rotation: f32, color: Color)
DrawRectangleGradientV :: extern proc(posX: i32, posY: i32, width: i32, height: i32, top: Color, bottom: Color)
DrawRectangleGradientH :: extern proc(posX: i32, posY: i32, width: i32, height: i32, left: Color, right: Color)
DrawRectangleGradientEx :: extern proc(rec: Rectangle, topLeft: Color, bottomLeft: Color, topRight: Color, bottomRight: Color)
DrawRectangleLines :: extern proc(posX: i32, posY: i32, width: i32, height: i32, color: Color)
DrawRectangleLinesEx :: extern proc(rec: Rectangle, lineThick: f32, color: Color)
DrawRectangleRounded :: extern proc(rec: Rectangle, roundness: f32, segments: i32, color: Color)
DrawRectangleRoundedLines :: extern proc(rec: Rectangle, roundness: f32, segments: i32, color: Color)
DrawRectangleRoundedLinesEx :: extern proc(rec: Rectangle, roundness: f32, segments: i32, lineThick: f32, color: Color)
DrawTriangle :: extern proc(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)
DrawTriangleLines :: extern proc(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)
DrawTriangleFan :: extern proc(points: *const Vector2, pointCount: i32, color: Color)
DrawTriangleStrip :: extern proc(points: *const Vector2, pointCount: i32, color: Color)
DrawPoly :: extern proc(center: Vector2, sides: i32, radius: f32, rotation: f32, color: Color)
DrawPolyLines :: extern proc(center: Vector2, sides: i32, radius: f32, rotation: f32, color: Color)
DrawPolyLinesEx :: extern proc(center: Vector2, sides: i32, radius: f32, rotation: f32, lineThick: f32, color: Color)
DrawSplineLinear :: extern proc(points: *const Vector2, pointCount: i32, thick: f32, color: Color)
DrawSplineBasis :: extern proc(points: *const Vector2, pointCount: i32, thick: f32, color: Color)
DrawSplineCatmullRom :: extern proc(points: *const Vector2, pointCount: i32, thick: f32, color: Color)
DrawSplineBezierQuadratic :: extern proc(points: *const Vector2, pointCount: i32, thick: f32, color: Color)
DrawSplineBezierCubic :: extern proc(points: *const Vector2, pointCount: i32, thick: f32, color: Color)
DrawSplineSegmentLinear :: extern proc(p1: Vector2, p2: Vector2, thick: f32, color: Color)
DrawSplineSegmentBasis :: extern proc(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: f32, color: Color)
DrawSplineSegmentCatmullRom :: extern proc(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: f32, color: Color)
DrawSplineSegmentBezierQuadratic :: extern proc(p1: Vector2, c2: Vector2, p3: Vector2, thick: f32, color: Color)
DrawSplineSegmentBezierCubic :: extern proc(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, thick: f32, color: Color)
GetSplinePointLinear :: extern fn(startPos: Vector2, endPos: Vector2, t: f32) Vector2
GetSplinePointBasis :: extern fn(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: f32) Vector2
GetSplinePointCatmullRom :: extern fn(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: f32) Vector2
GetSplinePointBezierQuad :: extern fn(p1: Vector2, c2: Vector2, p3: Vector2, t: f32) Vector2
GetSplinePointBezierCubic :: extern fn(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, t: f32) Vector2
CheckCollisionRecs :: extern fn(rec1: Rectangle, rec2: Rectangle) bool
CheckCollisionCircles :: extern fn(center1: Vector2, radius1: f32, center2: Vector2, radius2: f32) bool
CheckCollisionCircleRec :: extern fn(center: Vector2, radius: f32, rec: Rectangle) bool
CheckCollisionCircleLine :: extern fn(center: Vector2, radius: f32, p1: Vector2, p2: Vector2) bool
CheckCollisionPointRec :: extern fn(point: Vector2, rec: Rectangle) bool
CheckCollisionPointCircle :: extern fn(point: Vector2, center: Vector2, radius: f32) bool
CheckCollisionPointTriangle :: extern fn(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) bool
CheckCollisionPointLine :: extern fn(point: Vector2, p1: Vector2, p2: Vector2, threshold: i32) bool
CheckCollisionPointPoly :: extern fn(point: Vector2, points: *const Vector2, pointCount: i32) bool
CheckCollisionLines :: extern fn(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: *Vector2) bool
GetCollisionRec :: extern fn(rec1: Rectangle, rec2: Rectangle) Rectangle
LoadImage :: extern fn(fileName: string) Image
LoadImageRaw :: extern fn(fileName: string, width: i32, height: i32, format: i32, headerSize: i32) Image
LoadImageAnim :: extern fn(fileName: string, frames: *i32) Image
LoadImageAnimFromMemory :: extern fn(fileType: string, fileData: *const u8, dataSize: i32, frames: *i32) Image
LoadImageFromMemory :: extern fn(fileType: string, fileData: *const u8, dataSize: i32) Image
LoadImageFromTexture :: extern fn(texture: Texture2D) Image
LoadImageFromScreen :: extern fn() Image
IsImageValid :: extern fn(image: Image) bool
UnloadImage :: extern proc(image: Image)
ExportImage :: extern fn(image: Image, fileName: string) bool
ExportImageToMemory :: extern fn(image: Image, fileType: string, fileSize: *i32) *u8
ExportImageAsCode :: extern fn(image: Image, fileName: string) bool
GenImageColor :: extern fn(width: i32, height: i32, color: Color) Image
GenImageGradientLinear :: extern fn(width: i32, height: i32, direction: i32, start: Color, end: Color) Image
GenImageGradientRadial :: extern fn(width: i32, height: i32, density: f32, inner: Color, outer: Color) Image
GenImageGradientSquare :: extern fn(width: i32, height: i32, density: f32, inner: Color, outer: Color) Image
GenImageChecked :: extern fn(width: i32, height: i32, checksX: i32, checksY: i32, col1: Color, col2: Color) Image
GenImageWhiteNoise :: extern fn(width: i32, height: i32, factor: f32) Image
GenImagePerlinNoise :: extern fn(width: i32, height: i32, offsetX: i32, offsetY: i32, scale: f32) Image
GenImageCellular :: extern fn(width: i32, height: i32, tileSize: i32) Image
GenImageText :: extern fn(width: i32, height: i32, text: string) Image
ImageCopy :: extern fn(image: Image) Image
ImageFromImage :: extern fn(image: Image, rec: Rectangle) Image
ImageFromChannel :: extern fn(image: Image, selectedChannel: i32) Image
ImageText :: extern fn(text: string, fontSize: i32, color: Color) Image
ImageTextEx :: extern fn(font: Font, text: string, fontSize: f32, spacing: f32, tint: Color) Image
ImageFormat :: extern proc(image: *Image, newFormat: i32)
ImageToPOT :: extern proc(image: *Image, fill: Color)
ImageCrop :: extern proc(image: *Image, crop: Rectangle)
ImageAlphaCrop :: extern proc(image: *Image, threshold: f32)
ImageAlphaClear :: extern proc(image: *Image, color: Color, threshold: f32)
ImageAlphaMask :: extern proc(image: *Image, alphaMask: Image)
ImageAlphaPremultiply :: extern proc(image: *Image)
ImageBlurGaussian :: extern proc(image: *Image, blurSize: i32)
ImageKernelConvolution :: extern proc(image: *Image, kernel: *const f32, kernelSize: i32)
ImageResize :: extern proc(image: *Image, newWidth: i32, newHeight: i32)
ImageResizeNN :: extern proc(image: *Image, newWidth: i32, newHeight: i32)
ImageResizeCanvas :: extern proc(image: *Image, newWidth: i32, newHeight: i32, offsetX: i32, offsetY: i32, fill: Color)
ImageMipmaps :: extern proc(image: *Image)
ImageDither :: extern proc(image: *Image, rBpp: i32, gBpp: i32, bBpp: i32, aBpp: i32)
ImageFlipVertical :: extern proc(image: *Image)
ImageFlipHorizontal :: extern proc(image: *Image)
ImageRotate :: extern proc(image: *Image, degrees: i32)
ImageRotateCW :: extern proc(image: *Image)
ImageRotateCCW :: extern proc(image: *Image)
ImageColorTint :: extern proc(image: *Image, color: Color)
ImageColorInvert :: extern proc(image: *Image)
ImageColorGrayscale :: extern proc(image: *Image)
ImageColorContrast :: extern proc(image: *Image, contrast: f32)
ImageColorBrightness :: extern proc(image: *Image, brightness: i32)
ImageColorReplace :: extern proc(image: *Image, color: Color, replace: Color)
LoadImageColors :: extern fn(image: Image) *Color
LoadImagePalette :: extern fn(image: Image, maxPaletteSize: i32, colorCount: *i32) *Color
UnloadImageColors :: extern proc(colors: *Color)
UnloadImagePalette :: extern proc(colors: *Color)
GetImageAlphaBorder :: extern fn(image: Image, threshold: f32) Rectangle
GetImageColor :: extern fn(image: Image, x: i32, y: i32) Color

// Image drawing functions
// NOTE: Image software-rendering functions (CPU)
ImageClearBackground :: extern proc(dst: *Image, color: Color)
ImageDrawPixel :: extern proc(dst: *Image, posX: i32, posY: i32, color: Color)
ImageDrawPixelV :: extern proc(dst: *Image, position: Vector2, color: Color)
ImageDrawLine :: extern proc(dst: *Image, startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, color: Color)
ImageDrawLineV :: extern proc(dst: *Image, start: Vector2, end: Vector2, color: Color)
ImageDrawLineEx :: extern proc(dst: *Image, start: Vector2, end: Vector2, thick: i32, color: Color)
ImageDrawCircle :: extern proc(dst: *Image, centerX: i32, centerY: i32, radius: i32, color: Color)
ImageDrawCircleV :: extern proc(dst: *Image, center: Vector2, radius: i32, color: Color)
ImageDrawCircleLines :: extern proc(dst: *Image, centerX: i32, centerY: i32, radius: i32, color: Color)
ImageDrawCircleLinesV :: extern proc(dst: *Image, center: Vector2, radius: i32, color: Color)
ImageDrawRectangle :: extern proc(dst: *Image, posX: i32, posY: i32, width: i32, height: i32, color: Color)
ImageDrawRectangleV :: extern proc(dst: *Image, position: Vector2, size: Vector2, color: Color)
ImageDrawRectangleRec :: extern proc(dst: *Image, rec: Rectangle, color: Color)
ImageDrawRectangleLines :: extern proc(dst: *Image, rec: Rectangle, thick: i32, color: Color)
ImageDrawTriangle :: extern proc(dst: *Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color)
ImageDrawTriangleEx :: extern proc(dst: *Image, v1: Vector2, v2: Vector2, v3: Vector2, c1: Color, c2: Color, c3: Color)
ImageDrawTriangleLines :: extern proc(dst: *Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color)
ImageDrawTriangleFan :: extern proc(dst: *Image, points: *Vector2, pointCount: i32, color: Color)
ImageDrawTriangleStrip :: extern proc(dst: *Image, points: *Vector2, pointCount: i32, color: Color)
ImageDraw :: extern proc(dst: *Image, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color)
ImageDrawText :: extern proc(dst: *Image, text: string, posX: i32, posY: i32, fontSize: i32, color: Color)
ImageDrawTextEx :: extern proc(dst: *Image, font: Font, text: string, position: Vector2, fontSize: f32, spacing: f32, tint: Color)

// Texture loading functions
// NOTE: These functions require GPU access
LoadTexture :: extern fn(fileName: string) Texture2D
LoadTextureFromImage :: extern fn(image: Image) Texture2D
LoadTextureCubemap :: extern fn(image: Image, layout: i32) TextureCubemap
LoadRenderTexture :: extern fn(width: i32, height: i32) RenderTexture2D
IsTextureValid :: extern fn(texture: Texture2D) bool
UnloadTexture :: extern proc(texture: Texture2D)
IsRenderTextureValid :: extern fn(target: RenderTexture2D) bool
UnloadRenderTexture :: extern proc(target: RenderTexture2D)
UpdateTexture :: extern proc(texture: Texture2D, pixels: *const void)
UpdateTextureRec :: extern proc(texture: Texture2D, rec: Rectangle, pixels: *const void)

// Texture configuration functions
GenTextureMipmaps :: extern proc(texture: *Texture2D)
SetTextureFilter :: extern proc(texture: Texture2D, filter: i32)
SetTextureWrap :: extern proc(texture: Texture2D, wrap: i32)

// Texture drawing functions
DrawTexture :: extern proc(texture: Texture2D, posX: i32, posY: i32, tint: Color)
DrawTextureV :: extern proc(texture: Texture2D, position: Vector2, tint: Color)
DrawTextureEx :: extern proc(texture: Texture2D, position: Vector2, rotation: f32, scale: f32, tint: Color)
DrawTextureRec :: extern proc(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color)
DrawTexturePro :: extern proc(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color)
DrawTextureNPatch :: extern proc(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color)

// Color/pixel related functions
ColorIsEqual :: extern fn(col1: Color, col2: Color) bool
Fade :: extern fn(color: Color, alpha: f32) Color
ColorToInt :: extern fn(color: Color) i32
ColorNormalize :: extern fn(color: Color) Vector4
ColorFromNormalized :: extern fn(normalized: Vector4) Color
ColorToHSV :: extern fn(color: Color) Vector3
ColorFromHSV :: extern fn(hue: f32, saturation: f32, value: f32) Color
ColorTint :: extern fn(color: Color, tint: Color) Color
ColorBrightness :: extern fn(color: Color, factor: f32) Color
ColorContrast :: extern fn(color: Color, contrast: f32) Color
ColorAlpha :: extern fn(color: Color, alpha: f32) Color
ColorAlphaBlend :: extern fn(dst: Color, src: Color, tint: Color) Color
ColorLerp :: extern fn(color1: Color, color2: Color, factor: f32) Color
GetColor :: extern fn(hexValue: u32) Color
GetPixelColor :: extern fn(srcPtr: *void, format: i32) Color
SetPixelColor :: extern proc(dstPtr: *void, color: Color, format: i32)
GetPixelDataSize :: extern fn(width: i32, height: i32, format: i32) i32

// Font loading/unloading functions
GetFontDefault :: extern fn() Font
LoadFont :: extern fn(fileName: string) Font
LoadFontEx :: extern fn(fileName: string, fontSize: i32, codepoints: *i32, codepointCount: i32) Font
LoadFontFromImage :: extern fn(image: Image, key: Color, firstChar: i32) Font
LoadFontFromMemory :: extern fn(fileType: string, fileData: *const u8, dataSize: i32, fontSize: i32, codepoints: *i32, codepointCount: i32) Font
IsFontValid :: extern fn(font: Font) bool

// LoadFontData :: extern fn(fileData: *const u8, dataSize: i32, fontSize: i32, codepoints: *i32, codepointCount: i32, type: i32) *GlyphInfo
GenImageFontAtlas :: extern fn(glyphs: *const GlyphInfo, glyphRecs: **Rectangle, glyphCount: i32, fontSize: i32, padding: i32, packMethod: i32) Image
UnloadFontData :: extern proc(glyphs: *GlyphInfo, glyphCount: i32)
UnloadFont :: extern proc(font: Font)
ExportFontAsCode :: extern fn(font: Font, fileName: string) bool

// Text drawing functions
DrawFPS :: extern proc(posX: i32, posY: i32)
DrawText :: extern proc(text: string, posX: i32, posY: i32, fontSize: i32, color: Color)
DrawTextEx :: extern proc(font: Font, text: string, position: Vector2, fontSize: f32, spacing: f32, tint: Color)
DrawTextPro :: extern proc(font: Font, text: string, position: Vector2, origin: Vector2, rotation: f32, fontSize: f32, spacing: f32, tint: Color)
DrawTextCodepoint :: extern proc(font: Font, codepoint: i32, position: Vector2, fontSize: f32, tint: Color)
DrawTextCodepoints :: extern proc(font: Font, codepoints: *const i32, codepointCount: i32, position: Vector2, fontSize: f32, spacing: f32, tint: Color)

// Text font info functions
SetTextLineSpacing :: extern proc(spacing: i32)
MeasureText :: extern fn(text: string, fontSize: i32) i32
MeasureTextEx :: extern fn(font: Font, text: string, fontSize: f32, spacing: f32) Vector2
GetGlyphIndex :: extern fn(font: Font, codepoint: i32) i32
GetGlyphInfo :: extern fn(font: Font, codepoint: i32) GlyphInfo
GetGlyphAtlasRec :: extern fn(font: Font, codepoint: i32) Rectangle

// Text codepoints management functions (unicode characters)
LoadUTF8 :: extern fn(codepoints: *const i32, length: i32) string
UnloadUTF8 :: extern proc(text: string)
LoadCodepoints :: extern fn(text: string, count: *i32) *i32
UnloadCodepoints :: extern proc(codepoints: *i32)
GetCodepointCount :: extern fn(text: string) i32
GetCodepoint :: extern fn(text: string, codepointSize: *i32) i32
GetCodepointNext :: extern fn(text: string, codepointSize: *i32) i32
GetCodepointPrevious :: extern fn(text: string, codepointSize: *i32) i32
CodepointToUTF8 :: extern fn(codepoint: i32, utf8Size: *i32) string

// Text strings management functions (no UTF-8 strings, only byte chars)
// NOTE: Some strings allocate memory internally for returned strings, just be careful!
TextCopy :: extern fn(dst: *i8, src: string) i32
TextIsEqual :: extern fn(text1: string, text2: string) bool
TextLength :: extern fn(text: string) u32
TextFormat :: extern fn(text: string, args: any) string
TextSubtext :: extern fn(text: string, position: i32, length: i32) string
TextReplace :: extern fn(text: string, replace: string, by: string) string
TextInsert :: extern fn(text: string, r#insert: string, position: i32) string
TextJoin :: extern fn(textList: **const string, count: i32, delimiter: string) string
TextSplit :: extern fn(text: string, delimiter: i8, count: *i32) **string
TextAppend :: extern proc(text: *i8, append: string, position: *i32)
TextFindIndex :: extern fn(text: string, find: string) i32
TextToUpper :: extern fn(text: string) string
TextToLower :: extern fn(text: string) string
TextToPascal :: extern fn(text: string) string
TextToSnake :: extern fn(text: string) string
TextToCamel :: extern fn(text: string) string
TextToInteger :: extern fn(text: string) i32
TextToFloat :: extern fn(text: string) f32

//------------------------------------------------------------------------------------
// Basic 3d Shapes Drawing Functions (Module: models)
//------------------------------------------------------------------------------------
DrawLine3D :: extern proc(startPos: Vector3, endPos: Vector3, color: Color)
DrawPoint3D :: extern proc(position: Vector3, color: Color)
DrawCircle3D :: extern proc(center: Vector3, radius: f32, rotationAxis: Vector3, rotationAngle: f32, color: Color)
DrawTriangle3D :: extern proc(v1: Vector3, v2: Vector3, v3: Vector3, color: Color)
DrawTriangleStrip3D :: extern proc(points: *const Vector3, pointCount: i32, color: Color)
DrawCube :: extern proc(position: Vector3, width: f32, height: f32, length: f32, color: Color)
DrawCubeV :: extern proc(position: Vector3, size: Vector3, color: Color)
DrawCubeWires :: extern proc(position: Vector3, width: f32, height: f32, length: f32, color: Color)
DrawCubeWiresV :: extern proc(position: Vector3, size: Vector3, color: Color)
DrawSphere :: extern proc(centerPos: Vector3, radius: f32, color: Color)
DrawSphereEx :: extern proc(centerPos: Vector3, radius: f32, rings: i32, slices: i32, color: Color)
DrawSphereWires :: extern proc(centerPos: Vector3, radius: f32, rings: i32, slices: i32, color: Color)
DrawCylinder :: extern proc(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: i32, color: Color)
DrawCylinderEx :: extern proc(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: i32, color: Color)
DrawCylinderWires :: extern proc(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: i32, color: Color)
DrawCylinderWiresEx :: extern proc(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: i32, color: Color)
DrawCapsule :: extern proc(startPos: Vector3, endPos: Vector3, radius: f32, slices: i32, rings: i32, color: Color)
DrawCapsuleWires :: extern proc(startPos: Vector3, endPos: Vector3, radius: f32, slices: i32, rings: i32, color: Color)
DrawPlane :: extern proc(centerPos: Vector3, size: Vector2, color: Color)
DrawRay :: extern proc(ray: Ray, color: Color)
DrawGrid :: extern proc(slices: i32, spacing: f32)

//------------------------------------------------------------------------------------
// Model 3d Loading and Drawing Functions (Module: models)
//------------------------------------------------------------------------------------

// Model management functions
LoadModel :: extern fn(fileName: string) Model
LoadModelFromMesh :: extern fn(mesh: Mesh) Model
IsModelValid :: extern fn(model: Model) bool
UnloadModel :: extern proc(model: Model)
GetModelBoundingBox :: extern fn(model: Model) BoundingBox

// Model drawing functions
DrawModel :: extern proc(model: Model, position: Vector3, scale: f32, tint: Color)
DrawModelEx :: extern proc(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color)
DrawModelWires :: extern proc(model: Model, position: Vector3, scale: f32, tint: Color)
DrawModelWiresEx :: extern proc(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color)
DrawModelPoints :: extern proc(model: Model, position: Vector3, scale: f32, tint: Color)
DrawModelPointsEx :: extern proc(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color)
DrawBoundingBox :: extern proc(box: BoundingBox, color: Color)
DrawBillboard :: extern proc(camera: Camera, texture: Texture2D, position: Vector3, scale: f32, tint: Color)
DrawBillboardRec :: extern proc(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color)
DrawBillboardPro :: extern proc(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: f32, tint: Color)

// Mesh management functions
UploadMesh :: extern proc(mesh: *Mesh, dynamic: bool)
UpdateMeshBuffer :: extern proc(mesh: Mesh, index: i32, data: *const void, dataSize: i32, offset: i32)
UnloadMesh :: extern proc(mesh: Mesh)
DrawMesh :: extern proc(mesh: Mesh, material: Material, transform: Matrix)
DrawMeshInstanced :: extern proc(mesh: Mesh, material: Material, transforms: *const Matrix, instances: i32)
GetMeshBoundingBox :: extern fn(mesh: Mesh) BoundingBox
GenMeshTangents :: extern proc(mesh: *Mesh)
ExportMesh :: extern fn(mesh: Mesh, fileName: string) bool
ExportMeshAsCode :: extern fn(mesh: Mesh, fileName: string) bool

// Mesh generation functions
GenMeshPoly :: extern fn(sides: i32, radius: f32) Mesh
GenMeshPlane :: extern fn(width: f32, length: f32, resX: i32, resZ: i32) Mesh
GenMeshCube :: extern fn(width: f32, height: f32, length: f32) Mesh
GenMeshSphere :: extern fn(radius: f32, rings: i32, slices: i32) Mesh
GenMeshHemiSphere :: extern fn(radius: f32, rings: i32, slices: i32) Mesh
GenMeshCylinder :: extern fn(radius: f32, height: f32, slices: i32) Mesh
GenMeshCone :: extern fn(radius: f32, height: f32, slices: i32) Mesh
GenMeshTorus :: extern fn(radius: f32, size: f32, radSeg: i32, sides: i32) Mesh
GenMeshKnot :: extern fn(radius: f32, size: f32, radSeg: i32, sides: i32) Mesh
GenMeshHeightmap :: extern fn(heightmap: Image, size: Vector3) Mesh
GenMeshCubicmap :: extern fn(cubicmap: Image, cubeSize: Vector3) Mesh

// Material loading/unloading functions
LoadMaterials :: extern fn(fileName: string, materialCount: *i32) *Material
LoadMaterialDefault :: extern fn() Material
IsMaterialValid :: extern fn(material: Material) bool
UnloadMaterial :: extern proc(material: Material)
SetMaterialTexture :: extern proc(material: *Material, mapType: i32, texture: Texture2D)
SetModelMeshMaterial :: extern proc(model: *Model, meshId: i32, materialId: i32)

// Model animations loading/unloading functions
LoadModelAnimations :: extern fn(fileName: string, animCount: *i32) *ModelAnimation
UpdateModelAnimation :: extern proc(model: Model, anim: ModelAnimation, frame: i32)
UpdateModelAnimationBones :: extern proc(model: Model, anim: ModelAnimation, frame: i32)
UnloadModelAnimation :: extern proc(anim: ModelAnimation)
UnloadModelAnimations :: extern proc(animations: *ModelAnimation, animCount: i32)
IsModelAnimationValid :: extern fn(model: Model, anim: ModelAnimation) bool

// Collision detection functions
CheckCollisionSpheres :: extern fn(center1: Vector3, radius1: f32, center2: Vector3, radius2: f32) bool
CheckCollisionBoxes :: extern fn(box1: BoundingBox, box2: BoundingBox) bool
CheckCollisionBoxSphere :: extern fn(box: BoundingBox, center: Vector3, radius: f32) bool
GetRayCollisionSphere :: extern fn(ray: Ray, center: Vector3, radius: f32) RayCollision
GetRayCollisionBox :: extern fn(ray: Ray, box: BoundingBox) RayCollision
GetRayCollisionMesh :: extern fn(ray: Ray, mesh: Mesh, transform: Matrix) RayCollision
GetRayCollisionTriangle :: extern fn(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) RayCollision
GetRayCollisionQuad :: extern fn(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3) RayCollision

//------------------------------------------------------------------------------------
// Audio Loading and Playing Functions (Module: audio)
//------------------------------------------------------------------------------------
AudioCallback :: extern fn(bufferData: *void, frames: u32) void

// Audio device management functions
InitAudioDevice :: extern proc()
CloseAudioDevice :: extern proc()
IsAudioDeviceReady :: extern fn() bool
SetMasterVolume :: extern proc(volume: f32)
GetMasterVolume :: extern fn() f32

// Wave/Sound loading/unloading functions
LoadWave :: extern fn(fileName: string) Wave
LoadWaveFromMemory :: extern fn(fileType: string, fileData: *const u8, dataSize: i32) Wave
IsWaveValid :: extern fn(wave: Wave) bool
LoadSound :: extern fn(fileName: string) Sound
LoadSoundFromWave :: extern fn(wave: Wave) Sound
LoadSoundAlias :: extern fn(source: Sound) Sound
IsSoundValid :: extern fn(sound: Sound) bool
UpdateSound :: extern proc(sound: Sound, data: *const void, sampleCount: i32)
UnloadWave :: extern proc(wave: Wave)
UnloadSound :: extern proc(sound: Sound)
UnloadSoundAlias :: extern proc(alias: Sound)
ExportWave :: extern fn(wave: Wave, fileName: string) bool
ExportWaveAsCode :: extern fn(wave: Wave, fileName: string) bool

// Wave/Sound management functions
PlaySound :: extern proc(sound: Sound)
StopSound :: extern proc(sound: Sound)
PauseSound :: extern proc(sound: Sound)
ResumeSound :: extern proc(sound: Sound)
IsSoundPlaying :: extern fn(sound: Sound) bool
SetSoundVolume :: extern proc(sound: Sound, volume: f32)
SetSoundPitch :: extern proc(sound: Sound, pitch: f32)
SetSoundPan :: extern proc(sound: Sound, pan: f32)
WaveCopy :: extern fn(wave: Wave) Wave
WaveCrop :: extern proc(wave: *Wave, initFrame: i32, finalFrame: i32)
WaveFormat :: extern proc(wave: *Wave, sampleRate: i32, sampleSize: i32, channels: i32)
LoadWaveSamples :: extern fn(wave: Wave) *f32
UnloadWaveSamples :: extern proc(samples: *f32)

// Music management functions
LoadMusicStream :: extern fn(fileName: string) Music
LoadMusicStreamFromMemory :: extern fn(fileType: string, data: *const u8, dataSize: i32) Music
IsMusicValid :: extern fn(music: Music) bool
UnloadMusicStream :: extern proc(music: Music)
PlayMusicStream :: extern proc(music: Music)
IsMusicStreamPlaying :: extern fn(music: Music) bool
UpdateMusicStream :: extern proc(music: Music)
StopMusicStream :: extern proc(music: Music)
PauseMusicStream :: extern proc(music: Music)
ResumeMusicStream :: extern proc(music: Music)
SeekMusicStream :: extern proc(music: Music, position: f32)
SetMusicVolume :: extern proc(music: Music, volume: f32)
SetMusicPitch :: extern proc(music: Music, pitch: f32)
SetMusicPan :: extern proc(music: Music, pan: f32)
GetMusicTimeLength :: extern fn(music: Music) f32
GetMusicTimePlayed :: extern fn(music: Music) f32

// AudioStream management functions
LoadAudioStream :: extern fn(sampleRate: u32, sampleSize: u32, channels: u32) AudioStream
IsAudioStreamValid :: extern fn(stream: AudioStream) bool
UnloadAudioStream :: extern proc(stream: AudioStream)
UpdateAudioStream :: extern proc(stream: AudioStream, data: *const void, frameCount: i32)
IsAudioStreamProcessed :: extern fn(stream: AudioStream) bool
PlayAudioStream :: extern proc(stream: AudioStream)
PauseAudioStream :: extern proc(stream: AudioStream)
ResumeAudioStream :: extern proc(stream: AudioStream)
IsAudioStreamPlaying :: extern fn(stream: AudioStream) bool
StopAudioStream :: extern proc(stream: AudioStream)
SetAudioStreamVolume :: extern proc(stream: AudioStream, volume: f32)
SetAudioStreamPitch :: extern proc(stream: AudioStream, pitch: f32)
SetAudioStreamPan :: extern proc(stream: AudioStream, pan: f32)
SetAudioStreamBufferSizeDefault :: extern proc(size: i32)
SetAudioStreamCallback :: extern proc(stream: AudioStream, callback: AudioCallback)
AttachAudioStreamProcessor :: extern proc(stream: AudioStream, processor: AudioCallback)
DetachAudioStreamProcessor :: extern proc(stream: AudioStream, processor: AudioCallback)
AttachAudioMixedProcessor :: extern proc(processor: AudioCallback)
DetachAudioMixedProcessor :: extern proc(processor: AudioCallback)
