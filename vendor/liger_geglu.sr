package liger_geglu

triton :: import "vendor/triton"

PtrF32 :: triton.Ptr(f32)

/// GEGLU forward kernel using GELU tanh approximation.
geglu_tanh_forward_kernel :: @[triton_kernel, triton_target = "cuda:75", triton_ptx_version = 80] proc(
    a_ptr: PtrF32,
    b_ptr: PtrF32,
    c_ptr: PtrF32,
    stride: i32,
    n_cols: i32,
    comptime BLOCK_SIZE: i32 = 1024,
) {
    pid := triton.program_id(0)
    offs := triton.make_range(0, BLOCK_SIZE)
    mask := offs < triton.splat(n_cols, BLOCK_SIZE)

    row_offset := pid * stride
    row_offset_b := triton.splat(row_offset, BLOCK_SIZE)

    a_ptrs := a_ptr + (offs + row_offset_b)
    b_ptrs := b_ptr + (offs + row_offset_b)

    zero := triton.splat(0.(f32), BLOCK_SIZE)
    a_row := triton.load(a_ptrs, mask, zero)
    b_row := triton.load(b_ptrs, mask, zero)

    sqrt_2_over_pi := triton.splat(0.7978845608.(f32), BLOCK_SIZE)
    coeff := triton.splat(0.044715.(f32), BLOCK_SIZE)

    a_sq := a_row * a_row
    a_cubed := a_sq * a_row
    tanh_arg := sqrt_2_over_pi * (a_row + coeff * a_cubed)
    tanh_val := triton.tanh(tanh_arg)
    half := triton.splat(0.5.(f32), BLOCK_SIZE)
    geglu_a := half * a_row * (triton.splat(1.0.(f32), BLOCK_SIZE) + tanh_val)
    c_row := geglu_a * b_row

    c_ptrs := c_ptr + (offs + row_offset_b)
    triton.store(c_ptrs, c_row, mask)
}

/// Tiled GEGLU forward kernel (tiles along columns using 2D grid).
geglu_tanh_forward_kernel_tiled :: @[triton_kernel, triton_target = "cuda:75", triton_ptx_version = 80] proc(
    a_ptr: PtrF32,
    b_ptr: PtrF32,
    c_ptr: PtrF32,
    stride: i32,
    n_cols: i32,
    comptime BLOCK_SIZE: i32 = 256,
) {
    pid_m := triton.program_id(0)
    pid_n := triton.program_id(1)

    col_tile := pid_n * BLOCK_SIZE
    offs := triton.make_range(0, BLOCK_SIZE) + triton.splat(col_tile, BLOCK_SIZE)
    mask := offs < triton.splat(n_cols, BLOCK_SIZE)

    row_offset := pid_m * stride
    row_offset_b := triton.splat(row_offset, BLOCK_SIZE)

    a_ptrs := a_ptr + (offs + row_offset_b)
    b_ptrs := b_ptr + (offs + row_offset_b)

    zero := triton.splat(0.(f32), BLOCK_SIZE)
    a_row := triton.load(a_ptrs, mask, zero)
    b_row := triton.load(b_ptrs, mask, zero)

    sqrt_2_over_pi := triton.splat(0.7978845608.(f32), BLOCK_SIZE)
    coeff := triton.splat(0.044715.(f32), BLOCK_SIZE)

    a_sq := a_row * a_row
    a_cubed := a_sq * a_row
    tanh_arg := sqrt_2_over_pi * (a_row + coeff * a_cubed)
    tanh_val := triton.tanh(tanh_arg)
    half := triton.splat(0.5.(f32), BLOCK_SIZE)
    geglu_a := half * a_row * (triton.splat(1.0.(f32), BLOCK_SIZE) + tanh_val)
    c_row := geglu_a * b_row

    c_ptrs := c_ptr + (offs + row_offset_b)
    triton.store(c_ptrs, c_row, mask)
}

/// GEGLU backward kernel using GELU tanh approximation.
geglu_tanh_backward_kernel :: @[triton_kernel, triton_target = "cuda:75", triton_ptx_version = 80] proc(
    dc_ptr: PtrF32,
    a_ptr: PtrF32,
    b_ptr: PtrF32,
    stride: i32,
    n_cols: i32,
    comptime BLOCK_SIZE: i32 = 1024,
) {
    pid := triton.program_id(0)
    offs := triton.make_range(0, BLOCK_SIZE)
    mask := offs < triton.splat(n_cols, BLOCK_SIZE)

    row_offset := pid * stride
    row_offset_b := triton.splat(row_offset, BLOCK_SIZE)

    dc_ptrs := dc_ptr + (offs + row_offset_b)
    a_ptrs := a_ptr + (offs + row_offset_b)
    b_ptrs := b_ptr + (offs + row_offset_b)

    zero := triton.splat(0.(f32), BLOCK_SIZE)
    dc_row := triton.load(dc_ptrs, mask, zero)
    a_row := triton.load(a_ptrs, mask, zero)
    b_row := triton.load(b_ptrs, mask, zero)

    sqrt_2_over_pi := triton.splat(0.7978845608.(f32), BLOCK_SIZE)
    coeff := triton.splat(0.044715.(f32), BLOCK_SIZE)

    a_sq := a_row * a_row
    a_cubed := a_sq * a_row
    tanh_arg := sqrt_2_over_pi * (a_row + coeff * a_cubed)
    tanh_val := triton.tanh(tanh_arg)

    half := triton.splat(0.5.(f32), BLOCK_SIZE)
    geglu_a := half * a_row * (triton.splat(1.0.(f32), BLOCK_SIZE) + tanh_val)

    db_row := dc_row * geglu_a

    one := triton.splat(1.0.(f32), BLOCK_SIZE)
    term1 := half * (one + tanh_val)
    tanh_sq := tanh_val * tanh_val
    three := triton.splat(3.0.(f32), BLOCK_SIZE)
    term2 := half * a_row * (one - tanh_sq) * (sqrt_2_over_pi * (one + three * coeff * a_sq))
    da_row := dc_row * b_row * (term1 + term2)

    triton.store(a_ptrs, da_row, mask)
    triton.store(b_ptrs, db_row, mask)
}
