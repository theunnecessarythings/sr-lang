package liger_layer_norm

triton :: import "vendor/triton"

PtrF32 :: triton.Ptr(f32)

/// LayerNorm forward kernel (simplified CUDA path).
layer_norm_forward_kernel :: @[triton_kernel, triton_target = "cuda:75", triton_ptx_version = 80] proc(
    y_ptr: PtrF32,
    y_row_stride: i32,
    x_ptr: PtrF32,
    x_row_stride: i32,
    w_ptr: PtrF32,
    w_row_stride: i32,
    b_ptr: PtrF32,
    b_row_stride: i32,
    mean_ptr: PtrF32,
    mean_row_stride: i32,
    rstd_ptr: PtrF32,
    rstd_row_stride: i32,
    n_cols: i32,
    eps: f32,
    comptime BLOCK_SIZE: i32 = 1024,
) {
    row_id := triton.program_id(0)
    offs := triton.make_range(0, BLOCK_SIZE)
    mask := offs < triton.splat(n_cols, BLOCK_SIZE)
    mask0 := offs < 1.(i32)

    row_offset := row_id * x_row_stride
    row_offset_b := triton.splat(row_offset, BLOCK_SIZE)
    x_ptrs := x_ptr + (offs + row_offset_b)
    x_row := triton.load(x_ptrs, mask, triton.splat(0.(f32), BLOCK_SIZE))

    mean := triton.reduce_sum(f32, x_row, 0) / n_cols.(f32)
    mean_b := triton.splat(mean, BLOCK_SIZE)
    x_centered := x_row - mean_b
    var := triton.reduce_sum(f32, x_centered * x_centered, 0) / n_cols.(f32)
    rstd := triton.rsqrt(var + eps)
    rstd_b := triton.splat(rstd, BLOCK_SIZE)

    mean_ptrs := mean_ptr + (offs + triton.splat(row_id * mean_row_stride, BLOCK_SIZE))
    rstd_ptrs := rstd_ptr + (offs + triton.splat(row_id * rstd_row_stride, BLOCK_SIZE))
    triton.store(mean_ptrs, mean_b, mask0)
    triton.store(rstd_ptrs, rstd_b, mask0)

    w_ptrs := w_ptr + (offs + triton.splat(row_id * w_row_stride, BLOCK_SIZE))
    b_ptrs := b_ptr + (offs + triton.splat(row_id * b_row_stride, BLOCK_SIZE))
    w_row := triton.load(w_ptrs, mask, triton.splat(0.(f32), BLOCK_SIZE))
    b_row := triton.load(b_ptrs, mask, triton.splat(0.(f32), BLOCK_SIZE))

    y_row := x_centered * rstd_b * w_row + b_row
    y_ptrs := y_ptr + (offs + triton.splat(row_id * y_row_stride, BLOCK_SIZE))
    triton.store(y_ptrs, y_row, mask)
}

/// LayerNorm backward kernel (simplified, per-row dW/dB).
layer_norm_backward_kernel :: @[triton_kernel, triton_target = "cuda:75", triton_ptx_version = 80] proc(
    x_ptr: PtrF32,
    x_row_stride: i32,
    w_ptr: PtrF32,
    w_row_stride: i32,
    mean_ptr: PtrF32,
    mean_row_stride: i32,
    rstd_ptr: PtrF32,
    rstd_row_stride: i32,
    dx_ptr: PtrF32,
    dx_row_stride: i32,
    dw_ptr: PtrF32,
    dw_row_stride: i32,
    db_ptr: PtrF32,
    db_row_stride: i32,
    dy_ptr: PtrF32,
    dy_row_stride: i32,
    n_cols: i32,
    comptime BLOCK_SIZE: i32 = 1024,
) {
    row_id := triton.program_id(0)
    offs := triton.make_range(0, BLOCK_SIZE)
    mask := offs < triton.splat(n_cols, BLOCK_SIZE)
    mask0 := offs < 1.(i32)

    x_ptrs := x_ptr + (offs + triton.splat(row_id * x_row_stride, BLOCK_SIZE))
    dy_ptrs := dy_ptr + (offs + triton.splat(row_id * dy_row_stride, BLOCK_SIZE))
    w_ptrs := w_ptr + (offs + triton.splat(row_id * w_row_stride, BLOCK_SIZE))
    x_row := triton.load(x_ptrs, mask, triton.splat(0.(f32), BLOCK_SIZE))
    dy_row := triton.load(dy_ptrs, mask, triton.splat(0.(f32), BLOCK_SIZE))
    w_row := triton.load(w_ptrs, mask, triton.splat(0.(f32), BLOCK_SIZE))

    mean_ptrs := mean_ptr + (offs + triton.splat(row_id * mean_row_stride, BLOCK_SIZE))
    rstd_ptrs := rstd_ptr + (offs + triton.splat(row_id * rstd_row_stride, BLOCK_SIZE))
    mean_vec := triton.load(mean_ptrs, mask0, triton.splat(0.(f32), BLOCK_SIZE))
    rstd_vec := triton.load(rstd_ptrs, mask0, triton.splat(0.(f32), BLOCK_SIZE))
    mean := triton.reduce_sum(f32, mean_vec, 0)
    rstd := triton.reduce_sum(f32, rstd_vec, 0)
    mean_b := triton.splat(mean, BLOCK_SIZE)
    rstd_b := triton.splat(rstd, BLOCK_SIZE)

    x_hat := (x_row - mean_b) * rstd_b
    wdy := w_row * dy_row
    c1 := triton.reduce_sum(f32, x_hat * wdy, 0) / n_cols.(f32)
    c2 := triton.reduce_sum(f32, wdy, 0) / n_cols.(f32)
    c1_b := triton.splat(c1, BLOCK_SIZE)
    c2_b := triton.splat(c2, BLOCK_SIZE)

    dx_row := (wdy - (x_hat * c1_b + c2_b)) * rstd_b

    dx_ptrs := dx_ptr + (offs + triton.splat(row_id * dx_row_stride, BLOCK_SIZE))
    triton.store(dx_ptrs, dx_row, mask)

    dw_row := dy_row * x_hat
    db_row := dy_row
    dw_ptrs := dw_ptr + (offs + triton.splat(row_id * dw_row_stride, BLOCK_SIZE))
    db_ptrs := db_ptr + (offs + triton.splat(row_id * db_row_stride, BLOCK_SIZE))
    triton.store(dw_ptrs, dw_row, mask)
    triton.store(db_ptrs, db_row, mask)
}
