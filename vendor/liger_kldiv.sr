package liger_kldiv

triton :: import "vendor/triton"

PtrF32 :: triton.Ptr(f32)

/// KLDiv forward kernel (simplified: log_target = false, reduction = sum).
kldiv_forward_kernel :: @[triton_kernel, triton_target = "cuda:75", triton_ptx_version = 80] proc(
    y_ptr: PtrF32,
    y_stride: i32,
    gt_ptr: PtrF32,
    gt_stride: i32,
    loss_ptr: PtrF32,
    loss_stride: i32,
    n_cols: i32,
    eps: f32,
    comptime BLOCK_SIZE: i32 = 1024,
) {
    pid := triton.program_id(0)
    row_offset_b := triton.splat(pid * y_stride, BLOCK_SIZE)
    gt_offset_b := triton.splat(pid * gt_stride, BLOCK_SIZE)
    offs := triton.make_range(0, BLOCK_SIZE)

    loss_sum: f32 = 0.0
    i: i32 = 0
    while i < n_cols {
        idx := offs + triton.splat(i, BLOCK_SIZE)
        mask := idx < triton.splat(n_cols, BLOCK_SIZE)
        y_ptrs := y_ptr + (row_offset_b + idx)
        gt_ptrs := gt_ptr + (gt_offset_b + idx)
        y := triton.load(y_ptrs, mask, triton.splat(0.(f32), BLOCK_SIZE))
        gt := triton.load(gt_ptrs, mask, triton.splat(0.(f32), BLOCK_SIZE))

        clipped := triton.maximum(gt, triton.splat(eps, BLOCK_SIZE))
        loss_vec := gt * (triton.log(clipped) - y)
        loss_sum = loss_sum + triton.reduce_sum(f32, loss_vec, 0)

        i = i + BLOCK_SIZE
    }

    loss_ptrs := loss_ptr + triton.splat(pid * loss_stride, BLOCK_SIZE)
    triton.store(loss_ptrs, triton.splat(loss_sum, BLOCK_SIZE), offs < 1.(i32))
}
